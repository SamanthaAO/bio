{"ast":null,"code":"import _classCallCheck from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/createClass\";\n// tslint:disable:member-ordering\n// tslint:disable:prefer-for-of\nimport { contrastRatio } from \"./color-converters\";\nimport { ColorInterpolationSpace, interpolateByColorSpace } from \"./color-interpolation\";\nexport var ColorScale =\n/*#__PURE__*/\nfunction () {\n  _createClass(ColorScale, null, [{\n    key: \"createBalancedColorScale\",\n    value: function createBalancedColorScale(colors) {\n      if (colors == null || colors.length === 0) {\n        throw new Error(\"The colors argument must be non-empty\");\n      }\n\n      var stops = new Array(colors.length);\n\n      for (var i = 0; i < colors.length; i++) {\n        // Special case first and last in order to avoid floating point jaggies\n        if (i === 0) {\n          stops[i] = {\n            color: colors[i],\n            position: 0\n          };\n        } else if (i === colors.length - 1) {\n          stops[i] = {\n            color: colors[i],\n            position: 1\n          };\n        } else {\n          stops[i] = {\n            color: colors[i],\n            position: i * (1 / (colors.length - 1))\n          };\n        }\n      }\n\n      return new ColorScale(stops);\n    }\n  }]);\n\n  function ColorScale(stops) {\n    _classCallCheck(this, ColorScale);\n\n    if (stops == null || stops.length === 0) {\n      throw new Error(\"The stops argument must be non-empty\");\n    } else {\n      this.stops = this.sortColorScaleStops(stops);\n    }\n  }\n\n  _createClass(ColorScale, [{\n    key: \"getColor\",\n    value: function getColor(position) {\n      var interpolationMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorInterpolationSpace.RGB;\n\n      if (this.stops.length === 1) {\n        return this.stops[0].color;\n      } else if (position <= 0) {\n        return this.stops[0].color;\n      } else if (position >= 1) {\n        return this.stops[this.stops.length - 1].color;\n      }\n\n      var lowerIndex = 0;\n\n      for (var i = 0; i < this.stops.length; i++) {\n        if (this.stops[i].position <= position) {\n          lowerIndex = i;\n        }\n      }\n\n      var upperIndex = lowerIndex + 1;\n\n      if (upperIndex >= this.stops.length) {\n        upperIndex = this.stops.length - 1;\n      }\n\n      var scalePosition = (position - this.stops[lowerIndex].position) * (1.0 / (this.stops[upperIndex].position - this.stops[lowerIndex].position));\n      return interpolateByColorSpace(scalePosition, interpolationMode, this.stops[lowerIndex].color, this.stops[upperIndex].color);\n    }\n  }, {\n    key: \"trim\",\n    value: function trim(lowerBound, upperBound) {\n      var interpolationMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ColorInterpolationSpace.RGB;\n\n      if (lowerBound < 0 || upperBound > 1 || upperBound < lowerBound) {\n        throw new Error(\"Invalid bounds\");\n      }\n\n      if (lowerBound === upperBound) {\n        return new ColorScale([{\n          color: this.getColor(lowerBound, interpolationMode),\n          position: 0\n        }]);\n      }\n\n      var containedStops = [];\n\n      for (var i = 0; i < this.stops.length; i++) {\n        if (this.stops[i].position >= lowerBound && this.stops[i].position <= upperBound) {\n          containedStops.push(this.stops[i]);\n        }\n      }\n\n      if (containedStops.length === 0) {\n        return new ColorScale([{\n          color: this.getColor(lowerBound),\n          position: lowerBound\n        }, {\n          color: this.getColor(upperBound),\n          position: upperBound\n        }]);\n      }\n\n      if (containedStops[0].position !== lowerBound) {\n        containedStops.unshift({\n          color: this.getColor(lowerBound),\n          position: lowerBound\n        });\n      }\n\n      if (containedStops[containedStops.length - 1].position !== upperBound) {\n        containedStops.push({\n          color: this.getColor(upperBound),\n          position: upperBound\n        });\n      }\n\n      var range = upperBound - lowerBound;\n      var finalStops = new Array(containedStops.length);\n\n      for (var _i = 0; _i < containedStops.length; _i++) {\n        finalStops[_i] = {\n          color: containedStops[_i].color,\n          position: (containedStops[_i].position - lowerBound) / range\n        };\n      }\n\n      return new ColorScale(finalStops);\n    }\n  }, {\n    key: \"findNextColor\",\n    value: function findNextColor(position, contrast) {\n      var searchDown = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var interpolationMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ColorInterpolationSpace.RGB;\n      var contrastErrorMargin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.005;\n      var maxSearchIterations = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 32;\n\n      if (isNaN(position) || position <= 0) {\n        position = 0;\n      } else if (position >= 1) {\n        position = 1;\n      }\n\n      var startingColor = this.getColor(position, interpolationMode);\n      var finalPosition = searchDown ? 0 : 1;\n      var finalColor = this.getColor(finalPosition, interpolationMode);\n      var finalContrast = contrastRatio(startingColor, finalColor);\n\n      if (finalContrast <= contrast) {\n        return finalPosition;\n      }\n\n      var testRangeMin = searchDown ? 0 : position;\n      var testRangeMax = searchDown ? position : 0;\n      var mid = finalPosition;\n      var iterations = 0;\n\n      while (iterations <= maxSearchIterations) {\n        mid = Math.abs(testRangeMax - testRangeMin) / 2 + testRangeMin;\n        var midColor = this.getColor(mid, interpolationMode);\n        var midContrast = contrastRatio(startingColor, midColor);\n\n        if (Math.abs(midContrast - contrast) <= contrastErrorMargin) {\n          return mid;\n        } else if (midContrast > contrast) {\n          if (searchDown) {\n            testRangeMin = mid;\n          } else {\n            testRangeMax = mid;\n          }\n        } else {\n          if (searchDown) {\n            testRangeMax = mid;\n          } else {\n            testRangeMin = mid;\n          }\n        }\n\n        iterations++;\n      }\n\n      return mid;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var newStops = new Array(this.stops.length);\n\n      for (var i = 0; i < newStops.length; i++) {\n        newStops[i] = {\n          color: this.stops[i].color,\n          position: this.stops[i].position\n        };\n      }\n\n      return new ColorScale(newStops);\n    }\n  }, {\n    key: \"sortColorScaleStops\",\n    value: function sortColorScaleStops(stops) {\n      return stops.sort(function (a, b) {\n        var A = a.position;\n        var B = b.position;\n\n        if (A < B) {\n          return -1;\n        } else if (A > B) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n    }\n  }]);\n\n  return ColorScale;\n}();","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-colors/dist/color-scale.js"],"names":["contrastRatio","ColorInterpolationSpace","interpolateByColorSpace","ColorScale","colors","length","Error","stops","Array","i","color","position","sortColorScaleStops","interpolationMode","RGB","lowerIndex","upperIndex","scalePosition","lowerBound","upperBound","getColor","containedStops","push","unshift","range","finalStops","contrast","searchDown","contrastErrorMargin","maxSearchIterations","isNaN","startingColor","finalPosition","finalColor","finalContrast","testRangeMin","testRangeMax","mid","iterations","Math","abs","midColor","midContrast","newStops","sort","a","b","A","B"],"mappings":"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","sourcesContent":["// tslint:disable:member-ordering\n// tslint:disable:prefer-for-of\nimport { contrastRatio } from \"./color-converters\";\nimport { ColorInterpolationSpace, interpolateByColorSpace } from \"./color-interpolation\";\nexport class ColorScale {\n    static createBalancedColorScale(colors) {\n        if (colors == null || colors.length === 0) {\n            throw new Error(\"The colors argument must be non-empty\");\n        }\n        const stops = new Array(colors.length);\n        for (let i = 0; i < colors.length; i++) {\n            // Special case first and last in order to avoid floating point jaggies\n            if (i === 0) {\n                stops[i] = { color: colors[i], position: 0 };\n            }\n            else if (i === colors.length - 1) {\n                stops[i] = { color: colors[i], position: 1 };\n            }\n            else {\n                stops[i] = {\n                    color: colors[i],\n                    position: i * (1 / (colors.length - 1)),\n                };\n            }\n        }\n        return new ColorScale(stops);\n    }\n    constructor(stops) {\n        if (stops == null || stops.length === 0) {\n            throw new Error(\"The stops argument must be non-empty\");\n        }\n        else {\n            this.stops = this.sortColorScaleStops(stops);\n        }\n    }\n    getColor(position, interpolationMode = ColorInterpolationSpace.RGB) {\n        if (this.stops.length === 1) {\n            return this.stops[0].color;\n        }\n        else if (position <= 0) {\n            return this.stops[0].color;\n        }\n        else if (position >= 1) {\n            return this.stops[this.stops.length - 1].color;\n        }\n        let lowerIndex = 0;\n        for (let i = 0; i < this.stops.length; i++) {\n            if (this.stops[i].position <= position) {\n                lowerIndex = i;\n            }\n        }\n        let upperIndex = lowerIndex + 1;\n        if (upperIndex >= this.stops.length) {\n            upperIndex = this.stops.length - 1;\n        }\n        const scalePosition = (position - this.stops[lowerIndex].position) *\n            (1.0 / (this.stops[upperIndex].position - this.stops[lowerIndex].position));\n        return interpolateByColorSpace(scalePosition, interpolationMode, this.stops[lowerIndex].color, this.stops[upperIndex].color);\n    }\n    trim(lowerBound, upperBound, interpolationMode = ColorInterpolationSpace.RGB) {\n        if (lowerBound < 0 || upperBound > 1 || upperBound < lowerBound) {\n            throw new Error(\"Invalid bounds\");\n        }\n        if (lowerBound === upperBound) {\n            return new ColorScale([\n                { color: this.getColor(lowerBound, interpolationMode), position: 0 },\n            ]);\n        }\n        const containedStops = [];\n        for (let i = 0; i < this.stops.length; i++) {\n            if (this.stops[i].position >= lowerBound &&\n                this.stops[i].position <= upperBound) {\n                containedStops.push(this.stops[i]);\n            }\n        }\n        if (containedStops.length === 0) {\n            return new ColorScale([\n                { color: this.getColor(lowerBound), position: lowerBound },\n                { color: this.getColor(upperBound), position: upperBound },\n            ]);\n        }\n        if (containedStops[0].position !== lowerBound) {\n            containedStops.unshift({\n                color: this.getColor(lowerBound),\n                position: lowerBound,\n            });\n        }\n        if (containedStops[containedStops.length - 1].position !== upperBound) {\n            containedStops.push({\n                color: this.getColor(upperBound),\n                position: upperBound,\n            });\n        }\n        const range = upperBound - lowerBound;\n        const finalStops = new Array(containedStops.length);\n        for (let i = 0; i < containedStops.length; i++) {\n            finalStops[i] = {\n                color: containedStops[i].color,\n                position: (containedStops[i].position - lowerBound) / range,\n            };\n        }\n        return new ColorScale(finalStops);\n    }\n    findNextColor(position, contrast, searchDown = false, interpolationMode = ColorInterpolationSpace.RGB, contrastErrorMargin = 0.005, maxSearchIterations = 32) {\n        if (isNaN(position) || position <= 0) {\n            position = 0;\n        }\n        else if (position >= 1) {\n            position = 1;\n        }\n        const startingColor = this.getColor(position, interpolationMode);\n        const finalPosition = searchDown ? 0 : 1;\n        const finalColor = this.getColor(finalPosition, interpolationMode);\n        const finalContrast = contrastRatio(startingColor, finalColor);\n        if (finalContrast <= contrast) {\n            return finalPosition;\n        }\n        let testRangeMin = searchDown ? 0 : position;\n        let testRangeMax = searchDown ? position : 0;\n        let mid = finalPosition;\n        let iterations = 0;\n        while (iterations <= maxSearchIterations) {\n            mid = Math.abs(testRangeMax - testRangeMin) / 2 + testRangeMin;\n            const midColor = this.getColor(mid, interpolationMode);\n            const midContrast = contrastRatio(startingColor, midColor);\n            if (Math.abs(midContrast - contrast) <= contrastErrorMargin) {\n                return mid;\n            }\n            else if (midContrast > contrast) {\n                if (searchDown) {\n                    testRangeMin = mid;\n                }\n                else {\n                    testRangeMax = mid;\n                }\n            }\n            else {\n                if (searchDown) {\n                    testRangeMax = mid;\n                }\n                else {\n                    testRangeMin = mid;\n                }\n            }\n            iterations++;\n        }\n        return mid;\n    }\n    clone() {\n        const newStops = new Array(this.stops.length);\n        for (let i = 0; i < newStops.length; i++) {\n            newStops[i] = {\n                color: this.stops[i].color,\n                position: this.stops[i].position,\n            };\n        }\n        return new ColorScale(newStops);\n    }\n    sortColorScaleStops(stops) {\n        return stops.sort((a, b) => {\n            const A = a.position;\n            const B = b.position;\n            if (A < B) {\n                return -1;\n            }\n            else if (A > B) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}