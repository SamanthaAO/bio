{"ast":null,"code":"import Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames, keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnter, keyCodeEscape, keyCodeSpace } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isEqual, isNil, uniqueId } from \"lodash-es\";\nimport React from \"react\";\nimport Listbox from \"../listbox\";\nimport { DisplayNamePrefix } from \"../utilities\";\nimport ViewportPositioner from \"../viewport-positioner\";\n\nclass Select extends Foundation {\n  /**\n   * constructor\n   */\n  constructor(props) {\n    super(props);\n    /**\n     * Handled props instantiation\n     */\n\n    this.handledProps = {\n      isMenuOpen: void 0,\n      disabled: void 0,\n      displayStringFormatter: void 0,\n      form: void 0,\n      labelledBy: void 0,\n      multiselectable: void 0,\n      trigger: void 0,\n      menu: void 0,\n      required: void 0,\n      managedClasses: void 0,\n      selectedItems: void 0,\n      defaultSelection: void 0,\n      onValueChange: void 0,\n      placeholder: void 0,\n      autoFocus: void 0,\n      menuFlyoutConfig: void 0,\n      onMenuSelectionChange: void 0\n    };\n    this.rootElement = React.createRef();\n    this.triggerId = uniqueId(Select.triggerUniqueIdPrefix);\n    /**\n     * Determine menu state based on props\n     */\n\n    this.checkPropsForMenuState = () => {\n      let shouldMenuBeOpen = false;\n\n      if (this.props.isMenuOpen !== undefined) {\n        shouldMenuBeOpen = this.props.isMenuOpen;\n      } else if (this.props.multiselectable === true) {\n        shouldMenuBeOpen = true;\n      }\n\n      return shouldMenuBeOpen;\n    };\n    /**\n     * This exists only to suppress a build warning\n     */\n\n\n    this.onSelectValueChange = event => {\n      return null;\n    };\n    /**\n     * Handles selection changes from menu\n     */\n\n\n    this.menuSelectionChange = newSelection => {\n      if (typeof this.props.onMenuSelectionChange === \"function\") {\n        this.props.onMenuSelectionChange(newSelection);\n      }\n\n      this.updateSelection(newSelection);\n    };\n    /**\n     * Updates selection state and associated values\n     */\n\n\n    this.updateSelection = newSelection => {\n      newSelection = this.trimSelection(newSelection);\n      const newValue = this.getValueFromSelection(newSelection);\n\n      if (this.state.value === newValue) {\n        // no change, abort\n        return;\n      }\n\n      const newDisplayString = this.getFormattedDisplayString(newSelection);\n\n      if (typeof this.props.onValueChange === \"function\" && !isEqual(newSelection, this.state.selectedItems)) {\n        this.props.onValueChange(newValue, newSelection, newDisplayString);\n      }\n\n      if (this.props.selectedItems === undefined) {\n        const validOptions = this.getValidOptions();\n        this.setState({\n          selectedItems: newSelection,\n          value: newValue,\n          displayString: newDisplayString,\n          selectedItemIndex: this.getSelectedItemPosInSet(validOptions, newSelection),\n          selectableItemCount: validOptions.length\n        });\n      }\n    };\n    /**\n     * Updates selection state and associated values from props\n     */\n\n\n    this.updateSelectionFromProps = () => {\n      const controlledSelection = this.trimSelection(Listbox.getListboxItemDataFromIds(this.props.selectedItems, this.props.children));\n      this.setState({\n        selectedItems: controlledSelection,\n        value: this.getValueFromSelection(controlledSelection),\n        displayString: this.getFormattedDisplayString(controlledSelection)\n      });\n    };\n    /**\n     * Trims the selection for single item mode\n     */\n\n\n    this.trimSelection = selection => {\n      return this.props.multiselectable === false && selection.length > 1 ? [this.state.selectedItems[0]] : selection;\n    };\n    /**\n     * Extracts values in the correct format (string in single select and string[] in multi-select) from an array of items.\n     */\n\n\n    this.getValueFromSelection = newSelection => {\n      if (this.props.multiselectable) {\n        return newSelection.map(thisItem => {\n          return thisItem.value;\n        });\n      } else {\n        if (newSelection.length === 0) {\n          return \"\";\n        }\n\n        return newSelection[0].value;\n      }\n    };\n    /**\n     * get the index of the provided selection\n     * (excludes children that aren't valid options)\n     */\n\n\n    this.getSelectedItemPosInSet = (options, selection) => {\n      if (!this.props.multiselectable && selection.length === 1) {\n        const selectionId = selection[0].id;\n        const optionCount = options.length;\n\n        for (let i = 0; i < optionCount; i++) {\n          if (options[i].props[Select.idPropertyKey] === selectionId) {\n            return i + 1;\n          }\n        }\n      }\n\n      return 0;\n    };\n    /**\n     * The default function that renders an unstyled content display\n     */\n\n\n    this.defaultTriggerRenderFunction = (props, state, triggerId) => {\n      if (props.multiselectable) {\n        return null;\n      }\n\n      const labelledBy = `${this.props.labelledBy} ${triggerId}`;\n      return React.createElement(\"button\", {\n        disabled: props.disabled,\n        id: triggerId,\n        \"aria-haspopup\": \"listbox\",\n        \"aria-labelledby\": labelledBy,\n        \"aria-expanded\": state.isMenuOpen,\n        \"aria-live\": \"polite\"\n      }, state.displayString);\n    };\n    /**\n     * The default function that formats the display string generated based on selection.\n     * This implementation should match the default formatting a base html select control applies.\n     * Developers can provide an alternate formatter if desired.\n     */\n\n\n    this.defaultDisplayStringFormatter = (selectedOptions, placeholder) => {\n      const optionValues = selectedOptions.map(selectedOption => {\n        return selectedOption.displayString || selectedOption.value;\n      });\n      return selectedOptions.length > 0 ? optionValues.join(\", \") : placeholder;\n    };\n    /**\n     * Handles clicks\n     */\n\n\n    this.handleClick = e => {\n      if (this.props.disabled || e.defaultPrevented) {\n        return;\n      }\n\n      this.toggleMenu(!this.state.isMenuOpen);\n    };\n    /**\n     * Handles key events\n     */\n\n\n    this.handleKeydown = e => {\n      if (this.props.disabled || e.defaultPrevented) {\n        return;\n      }\n\n      switch (e.keyCode) {\n        case keyCodeEnter:\n        case keyCodeSpace:\n          // preventing default here because when we change focus to the trigger the keydown event gets\n          // emitted from the button again which otherwise toggles the menu a second time on a single key press\n          e.preventDefault();\n          this.toggleMenu(!this.state.isMenuOpen);\n\n          if (this.validateMenuState(!this.state.isMenuOpen) === false) {\n            this.focusTriggerElement();\n          }\n\n          break;\n\n        case keyCodeEscape:\n          e.preventDefault();\n          this.toggleMenu(false);\n          this.focusTriggerElement();\n          break;\n\n        case keyCodeArrowDown:\n        case keyCodeArrowRight:\n          e.preventDefault();\n\n          if (!this.props.multiselectable && !this.state.isMenuOpen) {\n            this.incrementSelectedOption(+1);\n          }\n\n          break;\n\n        case keyCodeArrowUp:\n        case keyCodeArrowLeft:\n          e.preventDefault();\n\n          if (!this.props.multiselectable && !this.state.isMenuOpen) {\n            this.incrementSelectedOption(-1);\n          }\n\n          break;\n      }\n    };\n    /**\n     * Increment selection\n     */\n\n\n    this.incrementSelectedOption = increment => {\n      const childrenAsArray = React.Children.toArray(this.props.children);\n\n      if (this.state.selectedItems.length === 1) {\n        const selectedItemIndex = Listbox.getItemIndexById(this.state.selectedItems[0].id, this.props.children);\n\n        if (selectedItemIndex !== -1) {\n          const startIndex = selectedItemIndex + increment;\n          const endIndex = increment > -1 ? childrenAsArray.length - 1 : 0;\n          this.selectItemInRange(startIndex, endIndex, childrenAsArray, increment);\n        }\n      } else {\n        const isLastChild = increment > -1;\n        const lastChildIndex = childrenAsArray.length - 1;\n        this.selectItemInRange(isLastChild ? 0 : lastChildIndex, isLastChild ? lastChildIndex : 0, childrenAsArray, increment);\n      }\n    };\n    /**\n     * Select a child in a range\n     */\n\n\n    this.selectItemInRange = (startIndex, endIndex, childrenAsArray, increment) => {\n      const validOption = Listbox.getFirstValidOptionInRange(startIndex, endIndex, childrenAsArray, increment);\n\n      if (!isNil(validOption)) {\n        this.updateSelection([validOption.props]);\n      }\n    };\n    /**\n     * Toggles the menu\n     */\n\n\n    this.toggleMenu = desiredMenuState => {\n      const updatedIsMenuOpen = this.validateMenuState(desiredMenuState);\n\n      if (updatedIsMenuOpen !== this.state.isMenuOpen) {\n        this.setState({\n          isMenuOpen: updatedIsMenuOpen\n        });\n      }\n    };\n    /**\n     * Validate desired menu state against props\n     */\n\n\n    this.validateMenuState = desiredMenuState => {\n      let shouldOpenMenu = desiredMenuState;\n\n      if (this.props.isMenuOpen !== undefined) {\n        shouldOpenMenu = this.props.isMenuOpen;\n      } else if (this.props.multiselectable === true) {\n        shouldOpenMenu = true;\n      }\n\n      return shouldOpenMenu;\n    };\n    /**\n     * handle menu blur\n     */\n\n\n    this.handleMenuBlur = event => {\n      if (this.state.isMenuOpen && !this.props.multiselectable && this.rootElement.current !== null && !this.rootElement.current.contains(event.relatedTarget)) {\n        this.toggleMenu(false);\n      }\n    };\n    /**\n     * Determines what function needs to be called to format the result string and\n     * calls it with the appropriate params\n     */\n\n\n    this.getFormattedDisplayString = selectedOptions => {\n      return this.props.displayStringFormatter === undefined ? this.defaultDisplayStringFormatter(selectedOptions, this.props.placeholder) : this.props.displayStringFormatter(selectedOptions, this.props.placeholder);\n    };\n    /**\n     * Determines if a given element is a focusable button\n     */\n\n\n    this.isFocusableButton = element => {\n      return element instanceof HTMLButtonElement && element.getAttribute(\"aria-disabled\") !== \"true\";\n    };\n    /**\n     * focus on the trigger button\n     */\n\n\n    this.focusTriggerElement = () => {\n      const triggerButton = this.getTriggerButton();\n\n      if (triggerButton !== null) {\n        triggerButton.focus();\n      }\n    };\n    /**\n     * get valid options\n     */\n\n\n    this.getValidOptions = () => {\n      return Listbox.getValidOptions(React.Children.toArray(this.props.children));\n    };\n\n    let initialSelection = this.trimSelection(Listbox.getListboxItemDataFromIds(this.props.selectedItems !== undefined ? this.props.selectedItems : this.props.defaultSelection, this.props.children));\n\n    if (!this.props.multiselectable && initialSelection.length > 1) {\n      initialSelection = initialSelection.slice(0, 1);\n    }\n\n    const validOptions = this.getValidOptions();\n    this.state = {\n      selectedItems: initialSelection,\n      value: this.getValueFromSelection(initialSelection),\n      displayString: this.getFormattedDisplayString(initialSelection),\n      isMenuOpen: this.validateMenuState(false),\n      selectedItemIndex: this.getSelectedItemPosInSet(validOptions, initialSelection),\n      selectableItemCount: validOptions.length\n    };\n  }\n\n  componentDidUpdate(prevProps) {\n    let shouldUpdateSelection = false;\n    let updatedMenuVisibility = this.state.isMenuOpen;\n\n    if (prevProps.multiselectable !== this.props.multiselectable) {\n      shouldUpdateSelection = true;\n      updatedMenuVisibility = this.checkPropsForMenuState();\n    }\n\n    if (prevProps.isMenuOpen !== this.props.isMenuOpen) {\n      updatedMenuVisibility = this.checkPropsForMenuState();\n    }\n\n    if (updatedMenuVisibility !== this.state.isMenuOpen) {\n      this.toggleMenu(updatedMenuVisibility);\n    }\n\n    if (prevProps.selectedItems !== this.props.selectedItems) {\n      this.updateSelectionFromProps();\n      return;\n    }\n\n    if (shouldUpdateSelection) {\n      this.updateSelection(this.state.selectedItems.map(thisItem => {\n        return thisItem;\n      }));\n    }\n  }\n\n  componentDidMount() {\n    this.toggleMenu(this.checkPropsForMenuState());\n\n    if (this.props.autoFocus && !this.state.isMenuOpen && !this.props.multiselectable) {\n      this.focusTriggerElement();\n    }\n  }\n  /**\n   * Renders the component\n   */\n\n\n  render() {\n    return React.createElement(\"div\", Object.assign({}, this.unhandledProps(), {\n      ref: this.rootElement,\n      className: this.generateClassNames(),\n      onKeyDown: this.handleKeydown,\n      onClick: this.handleClick,\n      tabIndex: -1\n    }), this.renderTrigger(), this.renderHiddenSelectElement(), this.renderMenu());\n  }\n  /**\n   * Create class names\n   */\n\n\n  generateClassNames() {\n    const _this$props$managedCl = this.props.managedClasses,\n          select = _this$props$managedCl.select,\n          select__disabled = _this$props$managedCl.select__disabled,\n          select_menu__open = _this$props$managedCl.select_menu__open,\n          select__multiSelectable = _this$props$managedCl.select__multiSelectable;\n    return super.generateClassNames(classNames(select, [select__disabled, this.props.disabled], [select_menu__open, this.state.isMenuOpen], [select__multiSelectable, this.props.multiselectable]));\n  }\n  /**\n   * Renders a hidden select element which can interact with a\n   * form hosting this component\n   */\n\n\n  renderHiddenSelectElement() {\n    return React.createElement(\"select\", {\n      required: this.props.required || null,\n      name: this.props.name || null,\n      form: this.props.form || null,\n      value: this.state.value,\n      multiple: this.props.multiselectable || null,\n      disabled: this.props.disabled || null,\n      onChange: this.onSelectValueChange,\n      style: {\n        display: \"none\"\n      }\n    });\n  }\n  /**\n   * Determine which function to use to render the trigger (ie. the part of the control that shows when the menu isn't open)\n   * and invokes it\n   */\n\n\n  renderTrigger() {\n    if (this.props.trigger !== undefined) {\n      return this.props.trigger(this.props, this.state, this.triggerId);\n    } else {\n      return this.defaultTriggerRenderFunction(this.props, this.state, this.triggerId);\n    }\n  }\n  /**\n   * Determine which function to use to render the menu and invokes it\n   */\n\n\n  renderMenu() {\n    if (!this.state.isMenuOpen) {\n      return;\n    } // in single select mode we always focus on an item when menu is opened,\n    // multi-select lists only auto focus on an item if explicitly set to do so via props\n\n\n    let shouldFocusOnMount = !this.props.multiselectable;\n\n    if (this.props.multiselectable && this.props.autoFocus) {\n      shouldFocusOnMount = this.props.multiselectable;\n    }\n\n    const defaultMenu = React.createElement(Listbox, {\n      labelledBy: this.props.labelledBy,\n      disabled: this.props.disabled,\n      focusItemOnMount: shouldFocusOnMount,\n      multiselectable: this.props.multiselectable,\n      defaultSelection: this.state.selectedItems,\n      selectedItems: this.props.selectedItems,\n      onSelectedItemsChanged: this.menuSelectionChange,\n      onBlur: this.handleMenuBlur,\n      selectOnFocus: false,\n      managedClasses: {\n        listbox: get(this.props.managedClasses, \"select_menu\", \"\"),\n        listbox__disabled: get(this.props.managedClasses, \"select_menuDisabled\", \"\")\n      }\n    }, this.props.children);\n    const customMenu = typeof this.props.menu === \"function\" ? this.props.menu(this.props, this.state, defaultMenu) : defaultMenu;\n\n    if (isNil(this.props.menuFlyoutConfig)) {\n      return customMenu;\n    } else {\n      return React.createElement(ViewportPositioner, Object.assign({\n        anchor: this.rootElement\n      }, this.props.menuFlyoutConfig, {\n        managedClasses: this.generateViewportPositionerClassNames()\n      }), customMenu);\n    }\n  }\n  /**\n   * Returns viewport positioner managedclasses for select\n   */\n\n\n  generateViewportPositionerClassNames() {\n    const _this$props$managedCl2 = this.props.managedClasses,\n          select__menuPositioningRegion = _this$props$managedCl2.select__menuPositioningRegion,\n          select__menuPositionLeft = _this$props$managedCl2.select__menuPositionLeft,\n          select__menuPositionRight = _this$props$managedCl2.select__menuPositionRight,\n          select__menuPositionTop = _this$props$managedCl2.select__menuPositionTop,\n          select__menuPositionBottom = _this$props$managedCl2.select__menuPositionBottom,\n          select__menuPositionHorizontalInset = _this$props$managedCl2.select__menuPositionHorizontalInset,\n          select__menuPositionVerticalInset = _this$props$managedCl2.select__menuPositionVerticalInset;\n    return {\n      viewportPositioner: select__menuPositioningRegion,\n      viewportPositioner__left: select__menuPositionLeft,\n      viewportPositioner__right: select__menuPositionRight,\n      viewportPositioner__top: select__menuPositionTop,\n      viewportPositioner__bottom: select__menuPositionBottom,\n      viewportPositioner__horizontalInset: select__menuPositionHorizontalInset,\n      viewportPositioner__verticalInset: select__menuPositionVerticalInset\n    };\n  }\n  /**\n   * Return the first child of the select that is a non-disabled button\n   */\n\n\n  getTriggerButton() {\n    const children = canUseDOM() && this.rootElement.current instanceof HTMLElement ? Array.from(this.rootElement.current.children) : [];\n    const focusChildIndex = children.findIndex(this.isFocusableButton);\n    return focusChildIndex !== -1 ? children[focusChildIndex] : null;\n  }\n\n}\n\nSelect.displayName = `${DisplayNamePrefix}Select`;\nSelect.defaultProps = {\n  multiselectable: false,\n  disabled: false,\n  defaultSelection: [],\n  placeholder: \"\",\n  managedClasses: {}\n};\nSelect.idPropertyKey = \"id\";\nSelect.triggerUniqueIdPrefix = \"selecttrigger-\";\nexport default Select;","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-react-base/dist/select/select.js"],"names":["Foundation","classNames","keyCodeArrowDown","keyCodeArrowLeft","keyCodeArrowRight","keyCodeArrowUp","keyCodeEnter","keyCodeEscape","keyCodeSpace","canUseDOM","get","isEqual","isNil","uniqueId","React","Listbox","DisplayNamePrefix","ViewportPositioner","Select","constructor","props","handledProps","isMenuOpen","disabled","displayStringFormatter","form","labelledBy","multiselectable","trigger","menu","required","managedClasses","selectedItems","defaultSelection","onValueChange","placeholder","autoFocus","menuFlyoutConfig","onMenuSelectionChange","rootElement","createRef","triggerId","triggerUniqueIdPrefix","checkPropsForMenuState","shouldMenuBeOpen","undefined","onSelectValueChange","event","menuSelectionChange","newSelection","updateSelection","trimSelection","newValue","getValueFromSelection","state","value","newDisplayString","getFormattedDisplayString","validOptions","getValidOptions","setState","displayString","selectedItemIndex","getSelectedItemPosInSet","selectableItemCount","length","updateSelectionFromProps","controlledSelection","getListboxItemDataFromIds","children","selection","map","thisItem","options","selectionId","id","optionCount","i","idPropertyKey","defaultTriggerRenderFunction","createElement","defaultDisplayStringFormatter","selectedOptions","optionValues","selectedOption","join","handleClick","e","defaultPrevented","toggleMenu","handleKeydown","keyCode","preventDefault","validateMenuState","focusTriggerElement","incrementSelectedOption","increment","childrenAsArray","Children","toArray","getItemIndexById","startIndex","endIndex","selectItemInRange","isLastChild","lastChildIndex","validOption","getFirstValidOptionInRange","desiredMenuState","updatedIsMenuOpen","shouldOpenMenu","handleMenuBlur","current","contains","relatedTarget","isFocusableButton","element","HTMLButtonElement","getAttribute","triggerButton","getTriggerButton","focus","initialSelection","slice","componentDidUpdate","prevProps","shouldUpdateSelection","updatedMenuVisibility","componentDidMount","render","Object","assign","unhandledProps","ref","className","generateClassNames","onKeyDown","onClick","tabIndex","renderTrigger","renderHiddenSelectElement","renderMenu","select","select__disabled","select_menu__open","select__multiSelectable","name","multiple","onChange","style","display","shouldFocusOnMount","defaultMenu","focusItemOnMount","onSelectedItemsChanged","onBlur","selectOnFocus","listbox","listbox__disabled","customMenu","anchor","generateViewportPositionerClassNames","select__menuPositioningRegion","select__menuPositionLeft","select__menuPositionRight","select__menuPositionTop","select__menuPositionBottom","select__menuPositionHorizontalInset","select__menuPositionVerticalInset","viewportPositioner","viewportPositioner__left","viewportPositioner__right","viewportPositioner__top","viewportPositioner__bottom","viewportPositioner__horizontalInset","viewportPositioner__verticalInset","HTMLElement","Array","from","focusChildIndex","findIndex","displayName","defaultProps"],"mappings":"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","sourcesContent":["import Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames, keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnter, keyCodeEscape, keyCodeSpace, } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isEqual, isNil, uniqueId } from \"lodash-es\";\nimport React from \"react\";\nimport Listbox from \"../listbox\";\nimport { DisplayNamePrefix } from \"../utilities\";\nimport ViewportPositioner from \"../viewport-positioner\";\nclass Select extends Foundation {\n    /**\n     * constructor\n     */\n    constructor(props) {\n        super(props);\n        /**\n         * Handled props instantiation\n         */\n        this.handledProps = {\n            isMenuOpen: void 0,\n            disabled: void 0,\n            displayStringFormatter: void 0,\n            form: void 0,\n            labelledBy: void 0,\n            multiselectable: void 0,\n            trigger: void 0,\n            menu: void 0,\n            required: void 0,\n            managedClasses: void 0,\n            selectedItems: void 0,\n            defaultSelection: void 0,\n            onValueChange: void 0,\n            placeholder: void 0,\n            autoFocus: void 0,\n            menuFlyoutConfig: void 0,\n            onMenuSelectionChange: void 0,\n        };\n        this.rootElement = React.createRef();\n        this.triggerId = uniqueId(Select.triggerUniqueIdPrefix);\n        /**\n         * Determine menu state based on props\n         */\n        this.checkPropsForMenuState = () => {\n            let shouldMenuBeOpen = false;\n            if (this.props.isMenuOpen !== undefined) {\n                shouldMenuBeOpen = this.props.isMenuOpen;\n            }\n            else if (this.props.multiselectable === true) {\n                shouldMenuBeOpen = true;\n            }\n            return shouldMenuBeOpen;\n        };\n        /**\n         * This exists only to suppress a build warning\n         */\n        this.onSelectValueChange = (event) => {\n            return null;\n        };\n        /**\n         * Handles selection changes from menu\n         */\n        this.menuSelectionChange = (newSelection) => {\n            if (typeof this.props.onMenuSelectionChange === \"function\") {\n                this.props.onMenuSelectionChange(newSelection);\n            }\n            this.updateSelection(newSelection);\n        };\n        /**\n         * Updates selection state and associated values\n         */\n        this.updateSelection = (newSelection) => {\n            newSelection = this.trimSelection(newSelection);\n            const newValue = this.getValueFromSelection(newSelection);\n            if (this.state.value === newValue) {\n                // no change, abort\n                return;\n            }\n            const newDisplayString = this.getFormattedDisplayString(newSelection);\n            if (typeof this.props.onValueChange === \"function\" &&\n                !isEqual(newSelection, this.state.selectedItems)) {\n                this.props.onValueChange(newValue, newSelection, newDisplayString);\n            }\n            if (this.props.selectedItems === undefined) {\n                const validOptions = this.getValidOptions();\n                this.setState({\n                    selectedItems: newSelection,\n                    value: newValue,\n                    displayString: newDisplayString,\n                    selectedItemIndex: this.getSelectedItemPosInSet(validOptions, newSelection),\n                    selectableItemCount: validOptions.length,\n                });\n            }\n        };\n        /**\n         * Updates selection state and associated values from props\n         */\n        this.updateSelectionFromProps = () => {\n            const controlledSelection = this.trimSelection(Listbox.getListboxItemDataFromIds(this.props.selectedItems, this.props.children));\n            this.setState({\n                selectedItems: controlledSelection,\n                value: this.getValueFromSelection(controlledSelection),\n                displayString: this.getFormattedDisplayString(controlledSelection),\n            });\n        };\n        /**\n         * Trims the selection for single item mode\n         */\n        this.trimSelection = (selection) => {\n            return this.props.multiselectable === false && selection.length > 1\n                ? [this.state.selectedItems[0]]\n                : selection;\n        };\n        /**\n         * Extracts values in the correct format (string in single select and string[] in multi-select) from an array of items.\n         */\n        this.getValueFromSelection = (newSelection) => {\n            if (this.props.multiselectable) {\n                return newSelection.map((thisItem) => {\n                    return thisItem.value;\n                });\n            }\n            else {\n                if (newSelection.length === 0) {\n                    return \"\";\n                }\n                return newSelection[0].value;\n            }\n        };\n        /**\n         * get the index of the provided selection\n         * (excludes children that aren't valid options)\n         */\n        this.getSelectedItemPosInSet = (options, selection) => {\n            if (!this.props.multiselectable && selection.length === 1) {\n                const selectionId = selection[0].id;\n                const optionCount = options.length;\n                for (let i = 0; i < optionCount; i++) {\n                    if (options[i].props[Select.idPropertyKey] === selectionId) {\n                        return i + 1;\n                    }\n                }\n            }\n            return 0;\n        };\n        /**\n         * The default function that renders an unstyled content display\n         */\n        this.defaultTriggerRenderFunction = (props, state, triggerId) => {\n            if (props.multiselectable) {\n                return null;\n            }\n            const labelledBy = `${this.props.labelledBy} ${triggerId}`;\n            return (React.createElement(\"button\", { disabled: props.disabled, id: triggerId, \"aria-haspopup\": \"listbox\", \"aria-labelledby\": labelledBy, \"aria-expanded\": state.isMenuOpen, \"aria-live\": \"polite\" }, state.displayString));\n        };\n        /**\n         * The default function that formats the display string generated based on selection.\n         * This implementation should match the default formatting a base html select control applies.\n         * Developers can provide an alternate formatter if desired.\n         */\n        this.defaultDisplayStringFormatter = (selectedOptions, placeholder) => {\n            const optionValues = selectedOptions.map((selectedOption) => {\n                return selectedOption.displayString || selectedOption.value;\n            });\n            return selectedOptions.length > 0 ? optionValues.join(\", \") : placeholder;\n        };\n        /**\n         * Handles clicks\n         */\n        this.handleClick = (e) => {\n            if (this.props.disabled || e.defaultPrevented) {\n                return;\n            }\n            this.toggleMenu(!this.state.isMenuOpen);\n        };\n        /**\n         * Handles key events\n         */\n        this.handleKeydown = (e) => {\n            if (this.props.disabled || e.defaultPrevented) {\n                return;\n            }\n            switch (e.keyCode) {\n                case keyCodeEnter:\n                case keyCodeSpace:\n                    // preventing default here because when we change focus to the trigger the keydown event gets\n                    // emitted from the button again which otherwise toggles the menu a second time on a single key press\n                    e.preventDefault();\n                    this.toggleMenu(!this.state.isMenuOpen);\n                    if (this.validateMenuState(!this.state.isMenuOpen) === false) {\n                        this.focusTriggerElement();\n                    }\n                    break;\n                case keyCodeEscape:\n                    e.preventDefault();\n                    this.toggleMenu(false);\n                    this.focusTriggerElement();\n                    break;\n                case keyCodeArrowDown:\n                case keyCodeArrowRight:\n                    e.preventDefault();\n                    if (!this.props.multiselectable && !this.state.isMenuOpen) {\n                        this.incrementSelectedOption(+1);\n                    }\n                    break;\n                case keyCodeArrowUp:\n                case keyCodeArrowLeft:\n                    e.preventDefault();\n                    if (!this.props.multiselectable && !this.state.isMenuOpen) {\n                        this.incrementSelectedOption(-1);\n                    }\n                    break;\n            }\n        };\n        /**\n         * Increment selection\n         */\n        this.incrementSelectedOption = (increment) => {\n            const childrenAsArray = React.Children.toArray(this.props.children);\n            if (this.state.selectedItems.length === 1) {\n                const selectedItemIndex = Listbox.getItemIndexById(this.state.selectedItems[0].id, this.props.children);\n                if (selectedItemIndex !== -1) {\n                    const startIndex = selectedItemIndex + increment;\n                    const endIndex = increment > -1 ? childrenAsArray.length - 1 : 0;\n                    this.selectItemInRange(startIndex, endIndex, childrenAsArray, increment);\n                }\n            }\n            else {\n                const isLastChild = increment > -1;\n                const lastChildIndex = childrenAsArray.length - 1;\n                this.selectItemInRange(isLastChild ? 0 : lastChildIndex, isLastChild ? lastChildIndex : 0, childrenAsArray, increment);\n            }\n        };\n        /**\n         * Select a child in a range\n         */\n        this.selectItemInRange = (startIndex, endIndex, childrenAsArray, increment) => {\n            const validOption = Listbox.getFirstValidOptionInRange(startIndex, endIndex, childrenAsArray, increment);\n            if (!isNil(validOption)) {\n                this.updateSelection([validOption.props]);\n            }\n        };\n        /**\n         * Toggles the menu\n         */\n        this.toggleMenu = (desiredMenuState) => {\n            const updatedIsMenuOpen = this.validateMenuState(desiredMenuState);\n            if (updatedIsMenuOpen !== this.state.isMenuOpen) {\n                this.setState({\n                    isMenuOpen: updatedIsMenuOpen,\n                });\n            }\n        };\n        /**\n         * Validate desired menu state against props\n         */\n        this.validateMenuState = (desiredMenuState) => {\n            let shouldOpenMenu = desiredMenuState;\n            if (this.props.isMenuOpen !== undefined) {\n                shouldOpenMenu = this.props.isMenuOpen;\n            }\n            else if (this.props.multiselectable === true) {\n                shouldOpenMenu = true;\n            }\n            return shouldOpenMenu;\n        };\n        /**\n         * handle menu blur\n         */\n        this.handleMenuBlur = (event) => {\n            if (this.state.isMenuOpen &&\n                !this.props.multiselectable &&\n                this.rootElement.current !== null &&\n                !this.rootElement.current.contains(event.relatedTarget)) {\n                this.toggleMenu(false);\n            }\n        };\n        /**\n         * Determines what function needs to be called to format the result string and\n         * calls it with the appropriate params\n         */\n        this.getFormattedDisplayString = (selectedOptions) => {\n            return this.props.displayStringFormatter === undefined\n                ? this.defaultDisplayStringFormatter(selectedOptions, this.props.placeholder)\n                : this.props.displayStringFormatter(selectedOptions, this.props.placeholder);\n        };\n        /**\n         * Determines if a given element is a focusable button\n         */\n        this.isFocusableButton = (element) => {\n            return (element instanceof HTMLButtonElement &&\n                element.getAttribute(\"aria-disabled\") !== \"true\");\n        };\n        /**\n         * focus on the trigger button\n         */\n        this.focusTriggerElement = () => {\n            const triggerButton = this.getTriggerButton();\n            if (triggerButton !== null) {\n                triggerButton.focus();\n            }\n        };\n        /**\n         * get valid options\n         */\n        this.getValidOptions = () => {\n            return Listbox.getValidOptions(React.Children.toArray(this.props.children));\n        };\n        let initialSelection = this.trimSelection(Listbox.getListboxItemDataFromIds(this.props.selectedItems !== undefined\n            ? this.props.selectedItems\n            : this.props.defaultSelection, this.props.children));\n        if (!this.props.multiselectable && initialSelection.length > 1) {\n            initialSelection = initialSelection.slice(0, 1);\n        }\n        const validOptions = this.getValidOptions();\n        this.state = {\n            selectedItems: initialSelection,\n            value: this.getValueFromSelection(initialSelection),\n            displayString: this.getFormattedDisplayString(initialSelection),\n            isMenuOpen: this.validateMenuState(false),\n            selectedItemIndex: this.getSelectedItemPosInSet(validOptions, initialSelection),\n            selectableItemCount: validOptions.length,\n        };\n    }\n    componentDidUpdate(prevProps) {\n        let shouldUpdateSelection = false;\n        let updatedMenuVisibility = this.state.isMenuOpen;\n        if (prevProps.multiselectable !== this.props.multiselectable) {\n            shouldUpdateSelection = true;\n            updatedMenuVisibility = this.checkPropsForMenuState();\n        }\n        if (prevProps.isMenuOpen !== this.props.isMenuOpen) {\n            updatedMenuVisibility = this.checkPropsForMenuState();\n        }\n        if (updatedMenuVisibility !== this.state.isMenuOpen) {\n            this.toggleMenu(updatedMenuVisibility);\n        }\n        if (prevProps.selectedItems !== this.props.selectedItems) {\n            this.updateSelectionFromProps();\n            return;\n        }\n        if (shouldUpdateSelection) {\n            this.updateSelection(this.state.selectedItems.map((thisItem) => {\n                return thisItem;\n            }));\n        }\n    }\n    componentDidMount() {\n        this.toggleMenu(this.checkPropsForMenuState());\n        if (this.props.autoFocus &&\n            !this.state.isMenuOpen &&\n            !this.props.multiselectable) {\n            this.focusTriggerElement();\n        }\n    }\n    /**\n     * Renders the component\n     */\n    render() {\n        return (React.createElement(\"div\", Object.assign({}, this.unhandledProps(), { ref: this.rootElement, className: this.generateClassNames(), onKeyDown: this.handleKeydown, onClick: this.handleClick, tabIndex: -1 }),\n            this.renderTrigger(),\n            this.renderHiddenSelectElement(),\n            this.renderMenu()));\n    }\n    /**\n     * Create class names\n     */\n    generateClassNames() {\n        const { select, select__disabled, select_menu__open, select__multiSelectable, } = this.props.managedClasses;\n        return super.generateClassNames(classNames(select, [select__disabled, this.props.disabled], [select_menu__open, this.state.isMenuOpen], [select__multiSelectable, this.props.multiselectable]));\n    }\n    /**\n     * Renders a hidden select element which can interact with a\n     * form hosting this component\n     */\n    renderHiddenSelectElement() {\n        return (React.createElement(\"select\", { required: this.props.required || null, name: this.props.name || null, form: this.props.form || null, value: this.state.value, multiple: this.props.multiselectable || null, disabled: this.props.disabled || null, onChange: this.onSelectValueChange, style: {\n                display: \"none\",\n            } }));\n    }\n    /**\n     * Determine which function to use to render the trigger (ie. the part of the control that shows when the menu isn't open)\n     * and invokes it\n     */\n    renderTrigger() {\n        if (this.props.trigger !== undefined) {\n            return this.props.trigger(this.props, this.state, this.triggerId);\n        }\n        else {\n            return this.defaultTriggerRenderFunction(this.props, this.state, this.triggerId);\n        }\n    }\n    /**\n     * Determine which function to use to render the menu and invokes it\n     */\n    renderMenu() {\n        if (!this.state.isMenuOpen) {\n            return;\n        }\n        // in single select mode we always focus on an item when menu is opened,\n        // multi-select lists only auto focus on an item if explicitly set to do so via props\n        let shouldFocusOnMount = !this.props.multiselectable;\n        if (this.props.multiselectable && this.props.autoFocus) {\n            shouldFocusOnMount = this.props.multiselectable;\n        }\n        const defaultMenu = (React.createElement(Listbox, { labelledBy: this.props.labelledBy, disabled: this.props.disabled, focusItemOnMount: shouldFocusOnMount, multiselectable: this.props.multiselectable, defaultSelection: this.state.selectedItems, selectedItems: this.props.selectedItems, onSelectedItemsChanged: this.menuSelectionChange, onBlur: this.handleMenuBlur, selectOnFocus: false, managedClasses: {\n                listbox: get(this.props.managedClasses, \"select_menu\", \"\"),\n                listbox__disabled: get(this.props.managedClasses, \"select_menuDisabled\", \"\"),\n            } }, this.props.children));\n        const customMenu = typeof this.props.menu === \"function\"\n            ? this.props.menu(this.props, this.state, defaultMenu)\n            : defaultMenu;\n        if (isNil(this.props.menuFlyoutConfig)) {\n            return customMenu;\n        }\n        else {\n            return (React.createElement(ViewportPositioner, Object.assign({ anchor: this.rootElement }, this.props.menuFlyoutConfig, { managedClasses: this.generateViewportPositionerClassNames() }), customMenu));\n        }\n    }\n    /**\n     * Returns viewport positioner managedclasses for select\n     */\n    generateViewportPositionerClassNames() {\n        const { select__menuPositioningRegion, select__menuPositionLeft, select__menuPositionRight, select__menuPositionTop, select__menuPositionBottom, select__menuPositionHorizontalInset, select__menuPositionVerticalInset, } = this.props.managedClasses;\n        return {\n            viewportPositioner: select__menuPositioningRegion,\n            viewportPositioner__left: select__menuPositionLeft,\n            viewportPositioner__right: select__menuPositionRight,\n            viewportPositioner__top: select__menuPositionTop,\n            viewportPositioner__bottom: select__menuPositionBottom,\n            viewportPositioner__horizontalInset: select__menuPositionHorizontalInset,\n            viewportPositioner__verticalInset: select__menuPositionVerticalInset,\n        };\n    }\n    /**\n     * Return the first child of the select that is a non-disabled button\n     */\n    getTriggerButton() {\n        const children = canUseDOM() && this.rootElement.current instanceof HTMLElement\n            ? Array.from(this.rootElement.current.children)\n            : [];\n        const focusChildIndex = children.findIndex(this.isFocusableButton);\n        return focusChildIndex !== -1\n            ? children[focusChildIndex]\n            : null;\n    }\n}\nSelect.displayName = `${DisplayNamePrefix}Select`;\nSelect.defaultProps = {\n    multiselectable: false,\n    disabled: false,\n    defaultSelection: [],\n    placeholder: \"\",\n    managedClasses: {},\n};\nSelect.idPropertyKey = \"id\";\nSelect.triggerUniqueIdPrefix = \"selecttrigger-\";\nexport default Select;\n"]},"metadata":{},"sourceType":"module"}