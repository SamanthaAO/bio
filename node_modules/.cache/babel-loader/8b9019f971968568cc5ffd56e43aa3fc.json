{"ast":null,"code":"// tslint:disable:member-ordering\n// tslint:disable:no-bitwise\n// tslint:disable:prefer-for-of\nimport { Histogram } from \"./histogram\";\nimport { insertIntoSortedList, PixelBox } from \"./pixel-box\";\nexport const defaultQuantizeConfig = {\n  significantBits: 5,\n  pixelSkipping: 5,\n  targetPaletteSize: 64,\n  fractionByPopulation: 0.85,\n  isBoxValid: box => {\n    if (box.pixelCount < 5) {\n      // Screen out outlier results that aren't present in the original image\n      return false;\n    }\n\n    return true;\n  },\n  isHistogramPixelValid: pixel => {\n    if (pixel[3] < 128) {\n      // Ignore pixels that are too transparent\n      return false;\n    }\n\n    return true;\n  },\n  maxIterations: 1000\n};\n/**\n * The image stored in the source PixelBlob is reduced down to a small set of colors.\n * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c\n */\n\nexport function quantize(source, config = defaultQuantizeConfig) {\n  const histogram = new Histogram(source, config.significantBits, config.pixelSkipping, config.isHistogramPixelValid);\n  const initialBox = new PixelBox(histogram, histogram.minRed, histogram.maxRed, histogram.minGreen, histogram.maxGreen, histogram.minBlue, histogram.maxBlue);\n  const queue = [initialBox];\n  let count = countValidBoxes(queue, config.isBoxValid); // For a final palette of size targetPaletteSize, we determine the first fractionByPopulation*targetPaletteSize\n  // using population as the only factor when determening sort order. For the rest of the colors the\n  // sort order is population * colorVolume. This helps highly contrasting colors in a small area to show\n  // up in some of the final output.\n\n  const colorsByPopulation = Math.floor(config.targetPaletteSize * config.fractionByPopulation);\n\n  const popSort = box => {\n    return box.pixelCount;\n  };\n\n  let iterationCount = 0;\n\n  while (iterationCount <= config.maxIterations) {\n    if (queue.length > 0) {\n      const currentBox = queue.shift();\n      const cutBoxes = currentBox.modifiedMedianCut();\n\n      if (cutBoxes[0] !== null) {\n        insertIntoSortedList(queue, cutBoxes[0], popSort);\n      }\n\n      if (cutBoxes[1] !== null) {\n        insertIntoSortedList(queue, cutBoxes[1], popSort);\n      }\n    }\n\n    count = countValidBoxes(queue, config.isBoxValid);\n\n    if (count >= colorsByPopulation || queue.length <= 1) {\n      break;\n    }\n\n    iterationCount++;\n  }\n\n  if (count < config.targetPaletteSize) {\n    const popAndVolumeSort = box => {\n      return box.pixelCount * box.colorVolume;\n    };\n\n    queue.sort((a, b) => {\n      const aSort = popAndVolumeSort(a);\n      const bSort = popAndVolumeSort(b);\n\n      if (aSort === bSort) {\n        return 0;\n      } else if (aSort > bSort) {\n        return -1;\n      }\n\n      return 1;\n    });\n    iterationCount = 0;\n\n    while (iterationCount <= config.maxIterations) {\n      if (queue.length > 0) {\n        const currentBox = queue.shift();\n        const cutBoxes = currentBox.modifiedMedianCut();\n\n        if (cutBoxes[0] !== null) {\n          insertIntoSortedList(queue, cutBoxes[0], popAndVolumeSort);\n        }\n\n        if (cutBoxes[1] !== null) {\n          insertIntoSortedList(queue, cutBoxes[1], popAndVolumeSort);\n        }\n      }\n\n      count = countValidBoxes(queue, config.isBoxValid);\n\n      if (count >= config.targetPaletteSize || queue.length <= 1) {\n        break;\n      }\n\n      iterationCount++;\n    }\n  }\n\n  const retVal = new Array(count);\n  let index = 0;\n\n  for (let i = 0; i < queue.length; i++) {\n    if (!config.isBoxValid || config.isBoxValid(queue[i])) {\n      retVal[index] = {\n        color: queue[i].averageColor,\n        pixelCount: queue[i].pixelCount,\n        colorVolume: queue[i].colorVolume\n      };\n      index++;\n    }\n  }\n\n  return retVal;\n}\n\nfunction countValidBoxes(queue, isBoxValid) {\n  if (isBoxValid === null) {\n    return queue.length;\n  }\n\n  let retVal = 0;\n\n  for (let i = 0; i < queue.length; i++) {\n    if (isBoxValid(queue[i])) {\n      retVal++;\n    }\n  }\n\n  return retVal;\n}","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-colors/dist/color-quantization.js"],"names":["Histogram","insertIntoSortedList","PixelBox","defaultQuantizeConfig","significantBits","pixelSkipping","targetPaletteSize","fractionByPopulation","isBoxValid","box","pixelCount","isHistogramPixelValid","pixel","maxIterations","quantize","source","config","histogram","initialBox","minRed","maxRed","minGreen","maxGreen","minBlue","maxBlue","queue","count","countValidBoxes","colorsByPopulation","Math","floor","popSort","iterationCount","length","currentBox","shift","cutBoxes","modifiedMedianCut","popAndVolumeSort","colorVolume","sort","a","b","aSort","bSort","retVal","Array","index","i","color","averageColor"],"mappings":"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","sourcesContent":["// tslint:disable:member-ordering\n// tslint:disable:no-bitwise\n// tslint:disable:prefer-for-of\nimport { Histogram } from \"./histogram\";\nimport { insertIntoSortedList, PixelBox } from \"./pixel-box\";\nexport const defaultQuantizeConfig = {\n    significantBits: 5,\n    pixelSkipping: 5,\n    targetPaletteSize: 64,\n    fractionByPopulation: 0.85,\n    isBoxValid: (box) => {\n        if (box.pixelCount < 5) {\n            // Screen out outlier results that aren't present in the original image\n            return false;\n        }\n        return true;\n    },\n    isHistogramPixelValid: (pixel) => {\n        if (pixel[3] < 128) {\n            // Ignore pixels that are too transparent\n            return false;\n        }\n        return true;\n    },\n    maxIterations: 1000,\n};\n/**\n * The image stored in the source PixelBlob is reduced down to a small set of colors.\n * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c\n */\nexport function quantize(source, config = defaultQuantizeConfig) {\n    const histogram = new Histogram(source, config.significantBits, config.pixelSkipping, config.isHistogramPixelValid);\n    const initialBox = new PixelBox(histogram, histogram.minRed, histogram.maxRed, histogram.minGreen, histogram.maxGreen, histogram.minBlue, histogram.maxBlue);\n    const queue = [initialBox];\n    let count = countValidBoxes(queue, config.isBoxValid);\n    // For a final palette of size targetPaletteSize, we determine the first fractionByPopulation*targetPaletteSize\n    // using population as the only factor when determening sort order. For the rest of the colors the\n    // sort order is population * colorVolume. This helps highly contrasting colors in a small area to show\n    // up in some of the final output.\n    const colorsByPopulation = Math.floor(config.targetPaletteSize * config.fractionByPopulation);\n    const popSort = (box) => {\n        return box.pixelCount;\n    };\n    let iterationCount = 0;\n    while (iterationCount <= config.maxIterations) {\n        if (queue.length > 0) {\n            const currentBox = queue.shift();\n            const cutBoxes = currentBox.modifiedMedianCut();\n            if (cutBoxes[0] !== null) {\n                insertIntoSortedList(queue, cutBoxes[0], popSort);\n            }\n            if (cutBoxes[1] !== null) {\n                insertIntoSortedList(queue, cutBoxes[1], popSort);\n            }\n        }\n        count = countValidBoxes(queue, config.isBoxValid);\n        if (count >= colorsByPopulation || queue.length <= 1) {\n            break;\n        }\n        iterationCount++;\n    }\n    if (count < config.targetPaletteSize) {\n        const popAndVolumeSort = (box) => {\n            return box.pixelCount * box.colorVolume;\n        };\n        queue.sort((a, b) => {\n            const aSort = popAndVolumeSort(a);\n            const bSort = popAndVolumeSort(b);\n            if (aSort === bSort) {\n                return 0;\n            }\n            else if (aSort > bSort) {\n                return -1;\n            }\n            return 1;\n        });\n        iterationCount = 0;\n        while (iterationCount <= config.maxIterations) {\n            if (queue.length > 0) {\n                const currentBox = queue.shift();\n                const cutBoxes = currentBox.modifiedMedianCut();\n                if (cutBoxes[0] !== null) {\n                    insertIntoSortedList(queue, cutBoxes[0], popAndVolumeSort);\n                }\n                if (cutBoxes[1] !== null) {\n                    insertIntoSortedList(queue, cutBoxes[1], popAndVolumeSort);\n                }\n            }\n            count = countValidBoxes(queue, config.isBoxValid);\n            if (count >= config.targetPaletteSize || queue.length <= 1) {\n                break;\n            }\n            iterationCount++;\n        }\n    }\n    const retVal = new Array(count);\n    let index = 0;\n    for (let i = 0; i < queue.length; i++) {\n        if (!config.isBoxValid || config.isBoxValid(queue[i])) {\n            retVal[index] = {\n                color: queue[i].averageColor,\n                pixelCount: queue[i].pixelCount,\n                colorVolume: queue[i].colorVolume,\n            };\n            index++;\n        }\n    }\n    return retVal;\n}\nfunction countValidBoxes(queue, isBoxValid) {\n    if (isBoxValid === null) {\n        return queue.length;\n    }\n    let retVal = 0;\n    for (let i = 0; i < queue.length; i++) {\n        if (isBoxValid(queue[i])) {\n            retVal++;\n        }\n    }\n    return retVal;\n}\n"]},"metadata":{},"sourceType":"module"}