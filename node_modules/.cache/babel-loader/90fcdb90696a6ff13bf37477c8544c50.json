{"ast":null,"code":"import { ColorRGBA64 } from \"./color-rgba-64\";\nimport { ColorPalette } from \"./color-palette\";\nimport { hslToRGB, rgbToHSL, rgbToLinearLuminance } from \"./color-converters\";\nimport { ColorScale } from \"./color-scale\";\nimport { ColorHSL } from \"./color-hsl\";\nimport { ColorInterpolationSpace } from \"./color-interpolation\";\nimport { parseColorHexRGB } from \"./parse-color\";\nexport class ComponentStateColorPalette {\n  constructor(config) {\n    this.palette = [];\n    this.config = Object.assign({}, ComponentStateColorPalette.defaultPaletteConfig, config);\n    this.regenPalettes();\n  }\n\n  regenPalettes() {\n    let steps = this.config.steps;\n\n    if (isNaN(steps) || steps < 3) {\n      steps = 3;\n    } // This palette is tuned to go as dark as differences between the levels can be perceived according to tests\n    // on numerous monitors in different conditions. Stay linear from white until this first cutoff.\n\n\n    const darkLum = 0.14; // In the dark compression, this is the last luminance value before full black.\n\n    const darkestLum = 0.06; // The Color for the luminance value above, placed on the ramp at it's normal position, so darker colors after\n    // it can be compressed.\n\n    const darkLumColor = new ColorRGBA64(darkLum, darkLum, darkLum, 1); // The number of steps in the ramp that has been tuned for default use. This coincides with the size of the\n    // default ramp, but the palette could be generated with fewer steps to increase final contrast. This number\n    // should however stay the same.\n\n    const stepsForLuminanceRamp = 94; // Create the reference, dark-compressed, grey palette, like:\n    // F------------------------------------------------------------------------------------[dark]------[darkest]0\n    //                                                                                      |--compressed area--|\n\n    const r = new ColorPalette(Object.assign({}, ColorPalette.greyscalePaletteConfig, {\n      baseColor: darkLumColor,\n      baseScalePosition: (1 - darkLum) * 100 / stepsForLuminanceRamp,\n      steps\n    }));\n    const referencePalette = r.palette; // Find the requested base color on the adjusted luminance reference ramp.\n    // There is no _right_ way to desaturate a color, and both methods we've tested have value, so average them out.\n\n    const baseColorLum1 = rgbToLinearLuminance(this.config.baseColor);\n    const baseColorLum2 = rgbToHSL(this.config.baseColor).l;\n    const baseColorLum = (baseColorLum1 + baseColorLum2) / 2;\n    const baseColorRefIndex = this.matchRelativeLuminanceIndex(baseColorLum, referencePalette);\n    const baseColorPercent = baseColorRefIndex / (steps - 1); // Find the luminance location for the dark cutoff.\n\n    const darkRefIndex = this.matchRelativeLuminanceIndex(darkLum, referencePalette);\n    const darkPercent = darkRefIndex / (steps - 1); // Issue https://github.com/microsoft/fast-dna/issues/1904\n    // Creating a color from H, S, and a known L value is not the inverse of getting the relative\n    // luminace as above. Need to derive a relative luminance version of the color to better match on the dark end.\n    // Find the dark cutoff and darkest variations of the requested base color.\n\n    const baseColorHSL = rgbToHSL(this.config.baseColor);\n    const darkBaseColor = hslToRGB(ColorHSL.fromObject({\n      h: baseColorHSL.h,\n      s: baseColorHSL.s,\n      l: darkLum\n    }));\n    const darkestBaseColor = hslToRGB(ColorHSL.fromObject({\n      h: baseColorHSL.h,\n      s: baseColorHSL.s,\n      l: darkestLum\n    })); // Create the gradient stops, including the base color and anchor colors for the dark end compression.\n\n    const fullColorScaleStops = new Array(5);\n    fullColorScaleStops[0] = {\n      position: 0,\n      color: new ColorRGBA64(1, 1, 1, 1)\n    };\n    fullColorScaleStops[1] = {\n      position: baseColorPercent,\n      color: this.config.baseColor\n    };\n    fullColorScaleStops[2] = {\n      position: darkPercent,\n      color: darkBaseColor\n    };\n    fullColorScaleStops[3] = {\n      position: 0.99,\n      color: darkestBaseColor\n    };\n    fullColorScaleStops[4] = {\n      position: 1,\n      color: new ColorRGBA64(0, 0, 0, 1)\n    };\n    const scale = new ColorScale(fullColorScaleStops); // Create the palette.\n\n    this.palette = new Array(steps);\n\n    for (let i = 0; i < steps; i++) {\n      const c = scale.getColor(i / (steps - 1), ColorInterpolationSpace.RGB);\n      this.palette[i] = c;\n    }\n  }\n\n  matchRelativeLuminanceIndex(input, reference) {\n    let bestFitValue = Number.MAX_VALUE;\n    let bestFitIndex = 0;\n    let i = 0;\n    const referenceLength = reference.length;\n\n    for (; i < referenceLength; i++) {\n      const fitValue = Math.abs(rgbToLinearLuminance(reference[i]) - input);\n\n      if (fitValue < bestFitValue) {\n        bestFitValue = fitValue;\n        bestFitIndex = i;\n      }\n    }\n\n    return bestFitIndex;\n  }\n\n}\nComponentStateColorPalette.defaultPaletteConfig = {\n  baseColor: parseColorHexRGB(\"#808080\"),\n  steps: 94\n};","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-colors/dist/component-state-color-palette.js"],"names":["ColorRGBA64","ColorPalette","hslToRGB","rgbToHSL","rgbToLinearLuminance","ColorScale","ColorHSL","ColorInterpolationSpace","parseColorHexRGB","ComponentStateColorPalette","constructor","config","palette","Object","assign","defaultPaletteConfig","regenPalettes","steps","isNaN","darkLum","darkestLum","darkLumColor","stepsForLuminanceRamp","r","greyscalePaletteConfig","baseColor","baseScalePosition","referencePalette","baseColorLum1","baseColorLum2","l","baseColorLum","baseColorRefIndex","matchRelativeLuminanceIndex","baseColorPercent","darkRefIndex","darkPercent","baseColorHSL","darkBaseColor","fromObject","h","s","darkestBaseColor","fullColorScaleStops","Array","position","color","scale","i","c","getColor","RGB","input","reference","bestFitValue","Number","MAX_VALUE","bestFitIndex","referenceLength","length","fitValue","Math","abs"],"mappings":"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","sourcesContent":["import { ColorRGBA64 } from \"./color-rgba-64\";\nimport { ColorPalette } from \"./color-palette\";\nimport { hslToRGB, rgbToHSL, rgbToLinearLuminance } from \"./color-converters\";\nimport { ColorScale } from \"./color-scale\";\nimport { ColorHSL } from \"./color-hsl\";\nimport { ColorInterpolationSpace } from \"./color-interpolation\";\nimport { parseColorHexRGB } from \"./parse-color\";\nexport class ComponentStateColorPalette {\n    constructor(config) {\n        this.palette = [];\n        this.config = Object.assign({}, ComponentStateColorPalette.defaultPaletteConfig, config);\n        this.regenPalettes();\n    }\n    regenPalettes() {\n        let steps = this.config.steps;\n        if (isNaN(steps) || steps < 3) {\n            steps = 3;\n        }\n        // This palette is tuned to go as dark as differences between the levels can be perceived according to tests\n        // on numerous monitors in different conditions. Stay linear from white until this first cutoff.\n        const darkLum = 0.14;\n        // In the dark compression, this is the last luminance value before full black.\n        const darkestLum = 0.06;\n        // The Color for the luminance value above, placed on the ramp at it's normal position, so darker colors after\n        // it can be compressed.\n        const darkLumColor = new ColorRGBA64(darkLum, darkLum, darkLum, 1);\n        // The number of steps in the ramp that has been tuned for default use. This coincides with the size of the\n        // default ramp, but the palette could be generated with fewer steps to increase final contrast. This number\n        // should however stay the same.\n        const stepsForLuminanceRamp = 94;\n        // Create the reference, dark-compressed, grey palette, like:\n        // F------------------------------------------------------------------------------------[dark]------[darkest]0\n        //                                                                                      |--compressed area--|\n        const r = new ColorPalette(Object.assign({}, ColorPalette.greyscalePaletteConfig, { baseColor: darkLumColor, baseScalePosition: ((1 - darkLum) * 100) / stepsForLuminanceRamp, steps }));\n        const referencePalette = r.palette;\n        // Find the requested base color on the adjusted luminance reference ramp.\n        // There is no _right_ way to desaturate a color, and both methods we've tested have value, so average them out.\n        const baseColorLum1 = rgbToLinearLuminance(this.config.baseColor);\n        const baseColorLum2 = rgbToHSL(this.config.baseColor).l;\n        const baseColorLum = (baseColorLum1 + baseColorLum2) / 2;\n        const baseColorRefIndex = this.matchRelativeLuminanceIndex(baseColorLum, referencePalette);\n        const baseColorPercent = baseColorRefIndex / (steps - 1);\n        // Find the luminance location for the dark cutoff.\n        const darkRefIndex = this.matchRelativeLuminanceIndex(darkLum, referencePalette);\n        const darkPercent = darkRefIndex / (steps - 1);\n        // Issue https://github.com/microsoft/fast-dna/issues/1904\n        // Creating a color from H, S, and a known L value is not the inverse of getting the relative\n        // luminace as above. Need to derive a relative luminance version of the color to better match on the dark end.\n        // Find the dark cutoff and darkest variations of the requested base color.\n        const baseColorHSL = rgbToHSL(this.config.baseColor);\n        const darkBaseColor = hslToRGB(ColorHSL.fromObject({\n            h: baseColorHSL.h,\n            s: baseColorHSL.s,\n            l: darkLum,\n        }));\n        const darkestBaseColor = hslToRGB(ColorHSL.fromObject({\n            h: baseColorHSL.h,\n            s: baseColorHSL.s,\n            l: darkestLum,\n        }));\n        // Create the gradient stops, including the base color and anchor colors for the dark end compression.\n        const fullColorScaleStops = new Array(5);\n        fullColorScaleStops[0] = {\n            position: 0,\n            color: new ColorRGBA64(1, 1, 1, 1),\n        };\n        fullColorScaleStops[1] = {\n            position: baseColorPercent,\n            color: this.config.baseColor,\n        };\n        fullColorScaleStops[2] = {\n            position: darkPercent,\n            color: darkBaseColor,\n        };\n        fullColorScaleStops[3] = {\n            position: 0.99,\n            color: darkestBaseColor,\n        };\n        fullColorScaleStops[4] = {\n            position: 1,\n            color: new ColorRGBA64(0, 0, 0, 1),\n        };\n        const scale = new ColorScale(fullColorScaleStops);\n        // Create the palette.\n        this.palette = new Array(steps);\n        for (let i = 0; i < steps; i++) {\n            const c = scale.getColor(i / (steps - 1), ColorInterpolationSpace.RGB);\n            this.palette[i] = c;\n        }\n    }\n    matchRelativeLuminanceIndex(input, reference) {\n        let bestFitValue = Number.MAX_VALUE;\n        let bestFitIndex = 0;\n        let i = 0;\n        const referenceLength = reference.length;\n        for (; i < referenceLength; i++) {\n            const fitValue = Math.abs(rgbToLinearLuminance(reference[i]) - input);\n            if (fitValue < bestFitValue) {\n                bestFitValue = fitValue;\n                bestFitIndex = i;\n            }\n        }\n        return bestFitIndex;\n    }\n}\nComponentStateColorPalette.defaultPaletteConfig = {\n    baseColor: parseColorHexRGB(\"#808080\"),\n    steps: 94,\n};\n"]},"metadata":{},"sourceType":"module"}