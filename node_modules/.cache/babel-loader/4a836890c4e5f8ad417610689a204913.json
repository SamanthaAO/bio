{"ast":null,"code":"// tslint:disable:member-ordering\n// tslint:disable:no-bitwise\n// tslint:disable:prefer-for-of\nimport { ColorRGBA64 } from \"./color-rgba-64\";\n/**\n * Adds a newItem to an already sorted list without needing to do a full re-sort.\n * Higher sort priority puts the newItem closer to the start (index 0) of the list.\n */\n\nexport function insertIntoSortedList(list, newItem, sortPriority) {\n  if (list.length === 0) {\n    list.push(newItem);\n    return;\n  }\n\n  const newItemPriority = sortPriority(newItem); // The new item being either first or last happens often enough that it is worth special casing\n  // In cases of a tie the new item should be inserted after existing items of the same priority\n\n  if (newItemPriority > sortPriority(list[0])) {\n    list.unshift(newItem);\n    return;\n  }\n\n  if (newItemPriority <= sortPriority(list[list.length - 1])) {\n    list.push(newItem);\n    return;\n  }\n\n  let newIndex = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    if (newItemPriority > sortPriority(list[i])) {\n      newIndex = i;\n      break;\n    }\n  }\n\n  list.splice(newIndex, 0, newItem);\n}\n/**\n * Represents a range of colors in RGB color space.\n */\n\nexport class PixelBox {\n  constructor(globalHistogram, minRed, maxRed, minGreen, maxGreen, minBlue, maxBlue) {\n    /**\n     * Attempts to divide the range of colors represented by this PixelBox into two smaller PixelBox objects.\n     * This does not actually cut directly at the median, rather it finds the median then cuts halfway through the larger box on either side of that median. The result is that small areas of color are better represented in the final output.\n     * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c\n     */\n    this.modifiedMedianCut = () => {\n      if (this.rangeRed === 1 && this.rangeGreen === 1 && this.rangeBlue === 1) {\n        // This box is already sliced as finely as possible\n        return [this, null];\n      }\n\n      let CutAxis;\n\n      (function (CutAxis) {\n        CutAxis[CutAxis[\"Red\"] = 0] = \"Red\";\n        CutAxis[CutAxis[\"Green\"] = 1] = \"Green\";\n        CutAxis[CutAxis[\"Blue\"] = 2] = \"Blue\";\n      })(CutAxis || (CutAxis = {}));\n\n      let axis;\n      let axisRange;\n\n      if (this.rangeRed >= this.rangeGreen && this.rangeRed >= this.rangeBlue) {\n        axis = CutAxis.Red;\n        axisRange = this.rangeRed;\n      } else if (this.rangeGreen >= this.rangeRed && this.rangeGreen >= this.rangeBlue) {\n        axis = CutAxis.Green;\n        axisRange = this.rangeGreen;\n      } else {\n        axis = CutAxis.Blue;\n        axisRange = this.rangeBlue;\n      }\n\n      const partialSum = new Array(axisRange);\n      const lookAheadSum = new Array(axisRange);\n      let retLeft = null;\n      let retRight = null;\n      let axisTotal = 0; // This does not actually cut directly at the median, rather it finds the median then\n      // cuts halfway through the larger box on either side of that median\n      // The result is that small areas of color are better represented in the final output\n\n      if (axis === CutAxis.Red) {\n        // Calculate partial sums\n        for (let r = this.minRed; r <= this.maxRed; r++) {\n          let sum = 0;\n\n          for (let g = this.minGreen; g <= this.maxGreen; g++) {\n            for (let b = this.minBlue; b <= this.maxBlue; b++) {\n              sum += this.globalHistogram.getHistogramValue(r, g, b);\n            }\n          }\n\n          axisTotal += sum;\n          partialSum[r - this.minRed] = axisTotal;\n        }\n\n        for (let i = 0; i < partialSum.length; i++) {\n          lookAheadSum[i] = axisTotal - partialSum[i];\n        } // Find the cut point based on partial sums vs total\n\n\n        for (let r = this.minRed; r <= this.maxRed; r++) {\n          if (partialSum[r - this.minRed] >= axisTotal / 2) {\n            const left = r - this.minRed;\n            const right = this.maxRed - r;\n            let cut;\n\n            if (left <= right) {\n              cut = Math.min(this.maxRed - 1, Math.floor(r + right / 2));\n            } else {\n              cut = Math.max(this.minRed, Math.floor(r - 1 - left / 2));\n            } // Adjust the cut point if either side has 0 pixelCount\n\n\n            while (partialSum[cut - this.minRed] <= 0 && cut < this.maxRed - 1) {\n              cut++;\n            }\n\n            let lookAhead = lookAheadSum[cut - this.minRed];\n\n            while (lookAhead === 0 && cut > this.minRed && partialSum[cut - this.minRed - 1] !== 0) {\n              cut--;\n              lookAhead = lookAheadSum[cut - this.minRed];\n            }\n\n            retLeft = new PixelBox(this.globalHistogram, this.minRed, cut, this.minGreen, this.maxGreen, this.minBlue, this.maxBlue);\n            retRight = new PixelBox(this.globalHistogram, cut + 1, this.maxRed, this.minGreen, this.maxGreen, this.minBlue, this.maxBlue);\n            break;\n          }\n        }\n      } else if (axis === CutAxis.Green) {\n        // Calculate partial sums\n        for (let g = this.minGreen; g <= this.maxGreen; g++) {\n          let sum = 0;\n\n          for (let r = this.minRed; r <= this.maxRed; r++) {\n            for (let b = this.minBlue; b <= this.maxBlue; b++) {\n              sum += this.globalHistogram.getHistogramValue(r, g, b);\n            }\n          }\n\n          axisTotal += sum;\n          partialSum[g - this.minGreen] = axisTotal;\n        }\n\n        for (let i = 0; i < partialSum.length; i++) {\n          lookAheadSum[i] = axisTotal - partialSum[i];\n        } // Find the cut point based on partial sums vs total\n\n\n        for (let g = this.minGreen; g <= this.maxGreen; g++) {\n          if (partialSum[g - this.minGreen] >= axisTotal / 2) {\n            const left = g - this.minGreen;\n            const right = this.maxGreen - g;\n            let cut;\n\n            if (left <= right) {\n              cut = Math.min(this.maxGreen - 1, Math.floor(g + right / 2));\n            } else {\n              cut = Math.max(this.minGreen, Math.floor(g - 1 - left / 2));\n            } // Adjust the cut point if either side has 0 pixelCount\n\n\n            while (partialSum[cut - this.minGreen] <= 0 && cut < this.maxGreen - 1) {\n              cut++;\n            }\n\n            let lookAhead = lookAheadSum[cut - this.minGreen];\n\n            while (lookAhead === 0 && cut > this.minGreen && partialSum[cut - this.minGreen - 1] !== 0) {\n              cut--;\n              lookAhead = lookAheadSum[cut - this.minGreen];\n            }\n\n            retLeft = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, this.minGreen, cut, this.minBlue, this.maxBlue);\n            retRight = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, cut + 1, this.maxGreen, this.minBlue, this.maxBlue);\n            break;\n          }\n        }\n      } else {\n        // Calculate partial sums\n        for (let b = this.minBlue; b <= this.maxBlue; b++) {\n          let sum = 0;\n\n          for (let r = this.minRed; r <= this.maxRed; r++) {\n            for (let g = this.minGreen; g <= this.maxGreen; g++) {\n              sum += this.globalHistogram.getHistogramValue(r, g, b);\n            }\n          }\n\n          axisTotal += sum;\n          partialSum[b - this.minBlue] = axisTotal;\n        }\n\n        for (let i = 0; i < partialSum.length; i++) {\n          lookAheadSum[i] = axisTotal - partialSum[i];\n        } // Find the cut point based on partial sums vs total\n\n\n        for (let b = this.minBlue; b <= this.maxBlue; b++) {\n          if (partialSum[b - this.minBlue] >= axisTotal / 2) {\n            const left = b - this.minBlue;\n            const right = this.maxBlue - b;\n            let cut;\n\n            if (left <= right) {\n              cut = Math.min(this.maxBlue - 1, Math.floor(b + right / 2));\n            } else {\n              cut = Math.max(this.minBlue, Math.floor(b - 1 - left / 2));\n            } // Adjust the cut point if either side has 0 pixelCount\n\n\n            while (partialSum[cut - this.minBlue] <= 0 && cut < this.maxBlue - 1) {\n              cut++;\n            }\n\n            let lookAhead = lookAheadSum[cut - this.minBlue];\n\n            while (lookAhead === 0 && cut > this.minBlue && partialSum[cut - this.minBlue - 1] !== 0) {\n              cut--;\n              lookAhead = lookAheadSum[cut - this.minBlue];\n            }\n\n            retLeft = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, this.minGreen, this.maxGreen, this.minBlue, cut);\n            retRight = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, this.minGreen, this.maxGreen, cut + 1, this.maxBlue);\n            break;\n          }\n        }\n      }\n\n      return [retLeft, retRight];\n    };\n\n    this.pixelCount = 0;\n    this.globalHistogram = globalHistogram;\n    this.minRed = minRed;\n    this.maxRed = maxRed;\n    this.minGreen = minGreen;\n    this.maxGreen = maxGreen;\n    this.minBlue = minBlue;\n    this.maxBlue = maxBlue;\n    this.rangeRed = this.maxRed - this.minRed + 1;\n    this.rangeGreen = this.maxGreen - this.minGreen + 1;\n    this.rangeBlue = this.maxBlue - this.minBlue + 1;\n    this.colorVolume = this.rangeRed * this.rangeGreen * this.rangeBlue;\n    let redSum = 0;\n    let greenSum = 0;\n    let blueSum = 0;\n    const factor = 1 << 8 - this.globalHistogram.significantBits;\n\n    for (let r = minRed; r <= maxRed; r++) {\n      for (let g = minGreen; g <= maxGreen; g++) {\n        for (let b = minBlue; b <= maxBlue; b++) {\n          const histoValue = this.globalHistogram.getHistogramValue(r, g, b);\n          this.pixelCount += histoValue;\n          redSum += histoValue * (r + 0.5) * factor;\n          greenSum += histoValue * (g + 0.5) * factor;\n          blueSum += histoValue * (b + 0.5) * factor;\n        }\n      }\n    }\n\n    if (this.pixelCount === 0) {\n      this.averageColor = new ColorRGBA64(factor * ((minRed + maxRed + 1) / 2) / 255, factor * ((minGreen + maxGreen + 1) / 2) / 255, factor * ((minBlue + maxBlue + 1) / 2) / 255, 1);\n    } else {\n      this.averageColor = new ColorRGBA64(redSum / this.pixelCount / 255, greenSum / this.pixelCount / 255, blueSum / this.pixelCount / 255, 1);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-colors/dist/pixel-box.js"],"names":["ColorRGBA64","insertIntoSortedList","list","newItem","sortPriority","length","push","newItemPriority","unshift","newIndex","i","splice","PixelBox","constructor","globalHistogram","minRed","maxRed","minGreen","maxGreen","minBlue","maxBlue","modifiedMedianCut","rangeRed","rangeGreen","rangeBlue","CutAxis","axis","axisRange","Red","Green","Blue","partialSum","Array","lookAheadSum","retLeft","retRight","axisTotal","r","sum","g","b","getHistogramValue","left","right","cut","Math","min","floor","max","lookAhead","pixelCount","colorVolume","redSum","greenSum","blueSum","factor","significantBits","histoValue","averageColor"],"mappings":"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","sourcesContent":["// tslint:disable:member-ordering\n// tslint:disable:no-bitwise\n// tslint:disable:prefer-for-of\nimport { ColorRGBA64 } from \"./color-rgba-64\";\n/**\n * Adds a newItem to an already sorted list without needing to do a full re-sort.\n * Higher sort priority puts the newItem closer to the start (index 0) of the list.\n */\nexport function insertIntoSortedList(list, newItem, sortPriority) {\n    if (list.length === 0) {\n        list.push(newItem);\n        return;\n    }\n    const newItemPriority = sortPriority(newItem);\n    // The new item being either first or last happens often enough that it is worth special casing\n    // In cases of a tie the new item should be inserted after existing items of the same priority\n    if (newItemPriority > sortPriority(list[0])) {\n        list.unshift(newItem);\n        return;\n    }\n    if (newItemPriority <= sortPriority(list[list.length - 1])) {\n        list.push(newItem);\n        return;\n    }\n    let newIndex = 0;\n    for (let i = 0; i < list.length; i++) {\n        if (newItemPriority > sortPriority(list[i])) {\n            newIndex = i;\n            break;\n        }\n    }\n    list.splice(newIndex, 0, newItem);\n}\n/**\n * Represents a range of colors in RGB color space.\n */\nexport class PixelBox {\n    constructor(globalHistogram, minRed, maxRed, minGreen, maxGreen, minBlue, maxBlue) {\n        /**\n         * Attempts to divide the range of colors represented by this PixelBox into two smaller PixelBox objects.\n         * This does not actually cut directly at the median, rather it finds the median then cuts halfway through the larger box on either side of that median. The result is that small areas of color are better represented in the final output.\n         * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c\n         */\n        this.modifiedMedianCut = () => {\n            if (this.rangeRed === 1 && this.rangeGreen === 1 && this.rangeBlue === 1) {\n                // This box is already sliced as finely as possible\n                return [this, null];\n            }\n            let CutAxis;\n            (function (CutAxis) {\n                CutAxis[CutAxis[\"Red\"] = 0] = \"Red\";\n                CutAxis[CutAxis[\"Green\"] = 1] = \"Green\";\n                CutAxis[CutAxis[\"Blue\"] = 2] = \"Blue\";\n            })(CutAxis || (CutAxis = {}));\n            let axis;\n            let axisRange;\n            if (this.rangeRed >= this.rangeGreen && this.rangeRed >= this.rangeBlue) {\n                axis = CutAxis.Red;\n                axisRange = this.rangeRed;\n            }\n            else if (this.rangeGreen >= this.rangeRed &&\n                this.rangeGreen >= this.rangeBlue) {\n                axis = CutAxis.Green;\n                axisRange = this.rangeGreen;\n            }\n            else {\n                axis = CutAxis.Blue;\n                axisRange = this.rangeBlue;\n            }\n            const partialSum = new Array(axisRange);\n            const lookAheadSum = new Array(axisRange);\n            let retLeft = null;\n            let retRight = null;\n            let axisTotal = 0;\n            // This does not actually cut directly at the median, rather it finds the median then\n            // cuts halfway through the larger box on either side of that median\n            // The result is that small areas of color are better represented in the final output\n            if (axis === CutAxis.Red) {\n                // Calculate partial sums\n                for (let r = this.minRed; r <= this.maxRed; r++) {\n                    let sum = 0;\n                    for (let g = this.minGreen; g <= this.maxGreen; g++) {\n                        for (let b = this.minBlue; b <= this.maxBlue; b++) {\n                            sum += this.globalHistogram.getHistogramValue(r, g, b);\n                        }\n                    }\n                    axisTotal += sum;\n                    partialSum[r - this.minRed] = axisTotal;\n                }\n                for (let i = 0; i < partialSum.length; i++) {\n                    lookAheadSum[i] = axisTotal - partialSum[i];\n                }\n                // Find the cut point based on partial sums vs total\n                for (let r = this.minRed; r <= this.maxRed; r++) {\n                    if (partialSum[r - this.minRed] >= axisTotal / 2) {\n                        const left = r - this.minRed;\n                        const right = this.maxRed - r;\n                        let cut;\n                        if (left <= right) {\n                            cut = Math.min(this.maxRed - 1, Math.floor(r + right / 2));\n                        }\n                        else {\n                            cut = Math.max(this.minRed, Math.floor(r - 1 - left / 2));\n                        }\n                        // Adjust the cut point if either side has 0 pixelCount\n                        while (partialSum[cut - this.minRed] <= 0 && cut < this.maxRed - 1) {\n                            cut++;\n                        }\n                        let lookAhead = lookAheadSum[cut - this.minRed];\n                        while (lookAhead === 0 &&\n                            cut > this.minRed &&\n                            partialSum[cut - this.minRed - 1] !== 0) {\n                            cut--;\n                            lookAhead = lookAheadSum[cut - this.minRed];\n                        }\n                        retLeft = new PixelBox(this.globalHistogram, this.minRed, cut, this.minGreen, this.maxGreen, this.minBlue, this.maxBlue);\n                        retRight = new PixelBox(this.globalHistogram, cut + 1, this.maxRed, this.minGreen, this.maxGreen, this.minBlue, this.maxBlue);\n                        break;\n                    }\n                }\n            }\n            else if (axis === CutAxis.Green) {\n                // Calculate partial sums\n                for (let g = this.minGreen; g <= this.maxGreen; g++) {\n                    let sum = 0;\n                    for (let r = this.minRed; r <= this.maxRed; r++) {\n                        for (let b = this.minBlue; b <= this.maxBlue; b++) {\n                            sum += this.globalHistogram.getHistogramValue(r, g, b);\n                        }\n                    }\n                    axisTotal += sum;\n                    partialSum[g - this.minGreen] = axisTotal;\n                }\n                for (let i = 0; i < partialSum.length; i++) {\n                    lookAheadSum[i] = axisTotal - partialSum[i];\n                }\n                // Find the cut point based on partial sums vs total\n                for (let g = this.minGreen; g <= this.maxGreen; g++) {\n                    if (partialSum[g - this.minGreen] >= axisTotal / 2) {\n                        const left = g - this.minGreen;\n                        const right = this.maxGreen - g;\n                        let cut;\n                        if (left <= right) {\n                            cut = Math.min(this.maxGreen - 1, Math.floor(g + right / 2));\n                        }\n                        else {\n                            cut = Math.max(this.minGreen, Math.floor(g - 1 - left / 2));\n                        }\n                        // Adjust the cut point if either side has 0 pixelCount\n                        while (partialSum[cut - this.minGreen] <= 0 &&\n                            cut < this.maxGreen - 1) {\n                            cut++;\n                        }\n                        let lookAhead = lookAheadSum[cut - this.minGreen];\n                        while (lookAhead === 0 &&\n                            cut > this.minGreen &&\n                            partialSum[cut - this.minGreen - 1] !== 0) {\n                            cut--;\n                            lookAhead = lookAheadSum[cut - this.minGreen];\n                        }\n                        retLeft = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, this.minGreen, cut, this.minBlue, this.maxBlue);\n                        retRight = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, cut + 1, this.maxGreen, this.minBlue, this.maxBlue);\n                        break;\n                    }\n                }\n            }\n            else {\n                // Calculate partial sums\n                for (let b = this.minBlue; b <= this.maxBlue; b++) {\n                    let sum = 0;\n                    for (let r = this.minRed; r <= this.maxRed; r++) {\n                        for (let g = this.minGreen; g <= this.maxGreen; g++) {\n                            sum += this.globalHistogram.getHistogramValue(r, g, b);\n                        }\n                    }\n                    axisTotal += sum;\n                    partialSum[b - this.minBlue] = axisTotal;\n                }\n                for (let i = 0; i < partialSum.length; i++) {\n                    lookAheadSum[i] = axisTotal - partialSum[i];\n                }\n                // Find the cut point based on partial sums vs total\n                for (let b = this.minBlue; b <= this.maxBlue; b++) {\n                    if (partialSum[b - this.minBlue] >= axisTotal / 2) {\n                        const left = b - this.minBlue;\n                        const right = this.maxBlue - b;\n                        let cut;\n                        if (left <= right) {\n                            cut = Math.min(this.maxBlue - 1, Math.floor(b + right / 2));\n                        }\n                        else {\n                            cut = Math.max(this.minBlue, Math.floor(b - 1 - left / 2));\n                        }\n                        // Adjust the cut point if either side has 0 pixelCount\n                        while (partialSum[cut - this.minBlue] <= 0 &&\n                            cut < this.maxBlue - 1) {\n                            cut++;\n                        }\n                        let lookAhead = lookAheadSum[cut - this.minBlue];\n                        while (lookAhead === 0 &&\n                            cut > this.minBlue &&\n                            partialSum[cut - this.minBlue - 1] !== 0) {\n                            cut--;\n                            lookAhead = lookAheadSum[cut - this.minBlue];\n                        }\n                        retLeft = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, this.minGreen, this.maxGreen, this.minBlue, cut);\n                        retRight = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, this.minGreen, this.maxGreen, cut + 1, this.maxBlue);\n                        break;\n                    }\n                }\n            }\n            return [retLeft, retRight];\n        };\n        this.pixelCount = 0;\n        this.globalHistogram = globalHistogram;\n        this.minRed = minRed;\n        this.maxRed = maxRed;\n        this.minGreen = minGreen;\n        this.maxGreen = maxGreen;\n        this.minBlue = minBlue;\n        this.maxBlue = maxBlue;\n        this.rangeRed = this.maxRed - this.minRed + 1;\n        this.rangeGreen = this.maxGreen - this.minGreen + 1;\n        this.rangeBlue = this.maxBlue - this.minBlue + 1;\n        this.colorVolume = this.rangeRed * this.rangeGreen * this.rangeBlue;\n        let redSum = 0;\n        let greenSum = 0;\n        let blueSum = 0;\n        const factor = 1 << (8 - this.globalHistogram.significantBits);\n        for (let r = minRed; r <= maxRed; r++) {\n            for (let g = minGreen; g <= maxGreen; g++) {\n                for (let b = minBlue; b <= maxBlue; b++) {\n                    const histoValue = this.globalHistogram.getHistogramValue(r, g, b);\n                    this.pixelCount += histoValue;\n                    redSum += histoValue * (r + 0.5) * factor;\n                    greenSum += histoValue * (g + 0.5) * factor;\n                    blueSum += histoValue * (b + 0.5) * factor;\n                }\n            }\n        }\n        if (this.pixelCount === 0) {\n            this.averageColor = new ColorRGBA64((factor * ((minRed + maxRed + 1) / 2)) / 255, (factor * ((minGreen + maxGreen + 1) / 2)) / 255, (factor * ((minBlue + maxBlue + 1) / 2)) / 255, 1);\n        }\n        else {\n            this.averageColor = new ColorRGBA64(redSum / this.pixelCount / 255, greenSum / this.pixelCount / 255, blueSum / this.pixelCount / 255, 1);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}