{"ast":null,"code":"export function clamp(i, min, max) {\n  if (isNaN(i) || i <= min) {\n    return min;\n  } else if (i >= max) {\n    return max;\n  }\n\n  return i;\n}\nexport function normalize(i, min, max) {\n  if (isNaN(i) || i <= min) {\n    return 0.0;\n  } else if (i >= max) {\n    return 1.0;\n  }\n\n  return i / (max - min);\n}\nexport function denormalize(i, min, max) {\n  if (isNaN(i)) {\n    return min;\n  }\n\n  return min + i * (max - min);\n}\nexport function degreesToRadians(i) {\n  return i * (Math.PI / 180.0);\n}\nexport function radiansToDegrees(i) {\n  return i * (180.0 / Math.PI);\n}\nexport function getHexStringForByte(i) {\n  const s = Math.round(clamp(i, 0.0, 255.0)).toString(16);\n\n  if (s.length === 1) {\n    return \"0\" + s;\n  }\n\n  return s;\n}\nexport function lerp(i, min, max) {\n  if (isNaN(i) || i <= 0.0) {\n    return min;\n  } else if (i >= 1.0) {\n    return max;\n  }\n\n  return min + i * (max - min);\n}\nexport function lerpAnglesInDegrees(i, min, max) {\n  if (i <= 0.0) {\n    return min % 360.0;\n  } else if (i >= 1.0) {\n    return max % 360.0;\n  }\n\n  const a = (min - max + 360.0) % 360.0;\n  const b = (max - min + 360.0) % 360.0;\n\n  if (a <= b) {\n    return (min - a * i + 360.0) % 360.0;\n  }\n\n  return (min + a * i + 360.0) % 360.0;\n}\nconst TwoPI = Math.PI * 2;\nexport function lerpAnglesInRadians(i, min, max) {\n  if (isNaN(i) || i <= 0.0) {\n    return min % TwoPI;\n  } else if (i >= 1.0) {\n    return max % TwoPI;\n  }\n\n  const a = (min - max + TwoPI) % TwoPI;\n  const b = (max - min + TwoPI) % TwoPI;\n\n  if (a <= b) {\n    return (min - a * i + TwoPI) % TwoPI;\n  }\n\n  return (min + a * i + TwoPI) % TwoPI;\n} // Will return infinity if i*10^(precision) overflows number\n// note that floating point rounding rules come into play here so values that end up rouding on a .5 round to the nearest even not always up\n// so 2.5 rounds to 2\n\nexport function roundToPrecisionSmall(i, precision) {\n  const factor = Math.pow(10, precision);\n  return Math.round(i * factor) / factor;\n}","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-colors/dist/math-utilities.js"],"names":["clamp","i","min","max","isNaN","normalize","denormalize","degreesToRadians","Math","PI","radiansToDegrees","getHexStringForByte","s","round","toString","length","lerp","lerpAnglesInDegrees","a","b","TwoPI","lerpAnglesInRadians","roundToPrecisionSmall","precision","factor","pow"],"mappings":"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","sourcesContent":["export function clamp(i, min, max) {\n    if (isNaN(i) || i <= min) {\n        return min;\n    }\n    else if (i >= max) {\n        return max;\n    }\n    return i;\n}\nexport function normalize(i, min, max) {\n    if (isNaN(i) || i <= min) {\n        return 0.0;\n    }\n    else if (i >= max) {\n        return 1.0;\n    }\n    return i / (max - min);\n}\nexport function denormalize(i, min, max) {\n    if (isNaN(i)) {\n        return min;\n    }\n    return min + i * (max - min);\n}\nexport function degreesToRadians(i) {\n    return i * (Math.PI / 180.0);\n}\nexport function radiansToDegrees(i) {\n    return i * (180.0 / Math.PI);\n}\nexport function getHexStringForByte(i) {\n    const s = Math.round(clamp(i, 0.0, 255.0)).toString(16);\n    if (s.length === 1) {\n        return \"0\" + s;\n    }\n    return s;\n}\nexport function lerp(i, min, max) {\n    if (isNaN(i) || i <= 0.0) {\n        return min;\n    }\n    else if (i >= 1.0) {\n        return max;\n    }\n    return min + i * (max - min);\n}\nexport function lerpAnglesInDegrees(i, min, max) {\n    if (i <= 0.0) {\n        return min % 360.0;\n    }\n    else if (i >= 1.0) {\n        return max % 360.0;\n    }\n    const a = (min - max + 360.0) % 360.0;\n    const b = (max - min + 360.0) % 360.0;\n    if (a <= b) {\n        return (min - a * i + 360.0) % 360.0;\n    }\n    return (min + a * i + 360.0) % 360.0;\n}\nconst TwoPI = Math.PI * 2;\nexport function lerpAnglesInRadians(i, min, max) {\n    if (isNaN(i) || i <= 0.0) {\n        return min % TwoPI;\n    }\n    else if (i >= 1.0) {\n        return max % TwoPI;\n    }\n    const a = (min - max + TwoPI) % TwoPI;\n    const b = (max - min + TwoPI) % TwoPI;\n    if (a <= b) {\n        return (min - a * i + TwoPI) % TwoPI;\n    }\n    return (min + a * i + TwoPI) % TwoPI;\n}\n// Will return infinity if i*10^(precision) overflows number\n// note that floating point rounding rules come into play here so values that end up rouding on a .5 round to the nearest even not always up\n// so 2.5 rounds to 2\nexport function roundToPrecisionSmall(i, precision) {\n    const factor = Math.pow(10, precision);\n    return Math.round(i * factor) / factor;\n}\n"]},"metadata":{},"sourceType":"module"}