{"ast":null,"code":"import Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { Tabs } from \"@microsoft/fast-components-react-base\";\nimport { classNames } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isNil } from \"lodash-es\";\nimport React from \"react\";\nimport { Flipper, FlipperDirection } from \"../flipper\";\nimport { DisplayNamePrefix } from \"../utilities\";\nimport { CarouselSlideTheme } from \"./carousel.props\";\n\nclass Carousel extends Foundation {\n  /**\n   * Define constructor\n   */\n  constructor(props) {\n    super(props);\n    /**\n     * Handled props\n     */\n\n    this.handledProps = {\n      autoplay: void 0,\n      autoplayInterval: void 0,\n      managedClasses: void 0,\n      nextFlipper: void 0,\n      previousFlipper: void 0,\n      label: void 0,\n      loop: void 0,\n      activeId: void 0,\n      onActiveIdUpdate: void 0,\n      items: void 0\n    };\n    /**\n     * Initial slide transition direction is none (on carousel load)\n     */\n\n    this.slideTransitionDirection = null;\n    /**\n     * Return transition direction class name\n     */\n\n    this.assignTransitionDirectionClassName = () => {\n      const _this$props$managedCl = this.props.managedClasses,\n            carousel__slideAnimateNext = _this$props$managedCl.carousel__slideAnimateNext,\n            carousel__slideAnimatePrevious = _this$props$managedCl.carousel__slideAnimatePrevious;\n      const transitionDirection = this.slideTransitionDirection === FlipperDirection.next ? carousel__slideAnimateNext : carousel__slideAnimatePrevious;\n      return ` ${transitionDirection}`;\n    };\n    /**\n     * Return slide theme class name\n     */\n\n\n    this.assignSlideThemeClassName = () => {\n      const _this$props$managedCl2 = this.props.managedClasses,\n            carousel__themeLight = _this$props$managedCl2.carousel__themeLight,\n            carousel__themeDark = _this$props$managedCl2.carousel__themeDark;\n      const theme = this.getSlideTheme() === CarouselSlideTheme.light ? carousel__themeLight : carousel__themeDark;\n      return ` ${theme}`;\n    };\n    /**\n     * Change active tab\n     */\n\n\n    this.handleUpdate = activeTab => {\n      if (typeof this.props.onActiveIdUpdate === \"function\") {\n        this.props.onActiveIdUpdate(activeTab, false);\n      }\n\n      this.setState({\n        activeId: activeTab\n      });\n      const activeTabIndex = this.slides.map(slide => slide.id).indexOf(activeTab);\n      this.setTransitionDirection(activeTabIndex);\n    };\n    /**\n     * Handles automation of slide movement\n     */\n\n\n    this.autoplayNextSlide = () => {\n      let nextPosition = this.getActiveIndex() + 1;\n\n      if (nextPosition > this.slides.length - 1) {\n        nextPosition = 0;\n      }\n\n      const activeId = this.slides[nextPosition].id;\n      this.setTransitionDirection(nextPosition);\n\n      if (typeof this.props.onActiveIdUpdate === \"function\") {\n        this.props.onActiveIdUpdate(activeId, true);\n      }\n\n      this.setState({\n        activeId\n      });\n    };\n    /**\n     * Move to next slide if applicable\n     */\n\n\n    this.nextSlide = () => {\n      let newPosition = this.getActiveIndex() + 1;\n\n      if (newPosition > this.slides.length - 1) {\n        newPosition = 0;\n      }\n\n      this.setTransitionDirection(newPosition);\n      this.setNewSlidePosition(newPosition);\n    };\n    /**\n     * Move to previous slide if applicable\n     */\n\n\n    this.previousSlide = () => {\n      let newPosition = this.getActiveIndex() - 1;\n\n      if (newPosition < 0) {\n        newPosition = this.slides.length - 1;\n      }\n\n      this.setTransitionDirection(newPosition);\n      this.setNewSlidePosition(newPosition);\n    };\n\n    this.rootEl = React.createRef();\n\n    if (Array.isArray(this.props.items)) {\n      this.state = {\n        activeId: typeof this.props.activeId === \"string\" ? this.props.activeId : get(this.props.items[0], \"id\", \" \")\n      };\n    }\n  }\n  /**\n   * React life-cycle method\n   */\n\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (nextProps.activeId && nextProps.activeId !== prevState.activeId) {\n      return {\n        activeId: nextProps.activeId\n      };\n    }\n\n    return null;\n  }\n  /**\n   * Renders the component\n   */\n\n\n  render() {\n    return React.createElement(\"div\", Object.assign({}, this.unhandledProps(), {\n      className: this.generateClassNames(),\n      ref: this.rootEl\n    }), this.generatePreviousFlipper(), React.createElement(Tabs, {\n      label: this.props.label,\n      activeId: this.state.activeId,\n      onUpdate: this.handleUpdate,\n      items: this.slides,\n      managedClasses: this.generateTabsClassNames(),\n      disableTabFocus: this.props.autoplay\n    }), this.generateNextFlipper());\n  }\n  /**\n   * React lifecycle hook\n   */\n\n\n  componentDidMount() {\n    if (canUseDOM() && this.props.autoplay) {\n      // Set initial interval for autoplay\n      this.autoplayTimer = window.setInterval(this.autoplayNextSlide, this.props.autoplayInterval);\n    }\n  }\n  /**\n   * React lifecycle hook\n   */\n\n\n  componentDidUpdate(prevProps, prevState) {\n    if (this.props.autoplay && isNil(this.autoplayTimer)) {\n      // Set the window interval if we are in autplay and don't have a timer\n      this.autoplayTimer = window.setInterval(this.autoplayNextSlide, this.props.autoplayInterval);\n    } else if (!this.props.autoplay && !isNil(this.autoplayTimer)) {\n      // Clear the interval if we should not be autoplaying\n      this.autoplayTimer = window.clearInterval(this.autoplayTimer);\n    }\n  }\n  /**\n   * React lifecycle hook\n   */\n\n\n  componentWillUnmount() {\n    if (!isNil(this.autoplayTimer)) {\n      this.autoplayTimer = window.clearInterval(this.autoplayTimer);\n    }\n  }\n  /**\n   * Generate class names\n   */\n\n\n  generateClassNames() {\n    return super.generateClassNames(classNames(this.props.managedClasses.carousel, [this.assignSlideThemeClassName, !!this.getSlideTheme()], [this.assignTransitionDirectionClassName(), !!this.slideTransitionDirection]));\n  }\n  /**\n   * Returns tabs managedclasses with new carousel-specific JSS\n   */\n\n\n  generateTabsClassNames() {\n    const _this$props$managedCl3 = this.props.managedClasses,\n          carousel_slides = _this$props$managedCl3.carousel_slides,\n          carousel_tabPanels = _this$props$managedCl3.carousel_tabPanels,\n          carousel_sequenceIndicators = _this$props$managedCl3.carousel_sequenceIndicators,\n          carousel_tabPanelContent = _this$props$managedCl3.carousel_tabPanelContent,\n          carousel_sequenceIndicator = _this$props$managedCl3.carousel_sequenceIndicator,\n          carousel_sequenceIndicator__active = _this$props$managedCl3.carousel_sequenceIndicator__active,\n          carousel_tabPanel = _this$props$managedCl3.carousel_tabPanel,\n          carousel_tabPanel__hidden = _this$props$managedCl3.carousel_tabPanel__hidden;\n    return {\n      tabs: carousel_slides,\n      tabs_tabPanels: carousel_tabPanels,\n      tabs_tabList: carousel_sequenceIndicators,\n      tabs_tabPanelContent: carousel_tabPanelContent,\n      tab: carousel_sequenceIndicator,\n      tab__active: carousel_sequenceIndicator__active,\n      tabPanel: carousel_tabPanel,\n      tabPanel__hidden: carousel_tabPanel__hidden\n    };\n  }\n  /**\n   * Get an array of slides\n   * Coerce tab shape\n   */\n\n\n  get slides() {\n    if (Array.isArray(this.props.items)) {\n      return this.props.items.map(slide => Object.assign({}, slide, {\n        tab: () => React.createElement(React.Fragment, null)\n      }));\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Single slide carousels do not require certain interface elements\n   */\n\n\n  get isMultipleSlides() {\n    return this.slides.length !== 1;\n  }\n  /**\n   * Check if it is the FIRST slide for looping\n   */\n\n\n  get isFirstSlide() {\n    if (this.slides.length) {\n      const firstSlideId = this.slides[0].id;\n      return firstSlideId === this.state.activeId;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Check if it is the LAST slide for looping\n   */\n\n\n  get isLastSlide() {\n    const lastItemKey = this.slides.length - 1;\n\n    if (lastItemKey >= 0) {\n      const lastSlideId = this.slides[lastItemKey].id;\n      return lastSlideId === this.state.activeId;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Get the active slide index\n   */\n\n\n  getActiveIndex() {\n    return this.slides.map(slide => slide.id).indexOf(this.state.activeId);\n  }\n  /**\n   * Get the current slide theme (needed for UI overlay contrast)\n   */\n\n\n  getSlideTheme() {\n    if (this.slides.length <= 0) {\n      return;\n    }\n\n    return this.slides[this.getActiveIndex()].theme ? this.slides[this.getActiveIndex()].theme : CarouselSlideTheme.dark;\n  }\n  /**\n   * Set the transition direction based on incoming index\n   */\n\n\n  setTransitionDirection(incomingIndex) {\n    if (this.getActiveIndex() < incomingIndex) {\n      this.slideTransitionDirection = FlipperDirection.next;\n    } else {\n      this.slideTransitionDirection = FlipperDirection.previous;\n    }\n  }\n  /**\n   * Generates previous flipper if more than one slide\n   */\n\n\n  generatePreviousFlipper() {\n    if (!this.isMultipleSlides || this.isFirstSlide && !this.props.loop) {\n      return;\n    }\n\n    const previousFlipperClassName = this.props.managedClasses.carousel_flipperPrevious;\n\n    if (typeof this.props.previousFlipper === \"function\") {\n      return this.props.previousFlipper(this.previousSlide, previousFlipperClassName);\n    } else {\n      return React.createElement(Flipper, {\n        direction: FlipperDirection.previous,\n        onClick: this.previousSlide,\n        className: previousFlipperClassName\n      });\n    }\n  }\n  /**\n   * Generates next flipper if more than one slide\n   */\n\n\n  generateNextFlipper() {\n    if (!this.isMultipleSlides || this.isLastSlide && !this.props.loop) {\n      return;\n    }\n\n    const nextFlipperClassName = this.props.managedClasses.carousel_flipperNext;\n\n    if (typeof this.props.nextFlipper === \"function\") {\n      return this.props.nextFlipper(this.nextSlide, nextFlipperClassName);\n    } else {\n      return React.createElement(Flipper, {\n        direction: FlipperDirection.next,\n        onClick: this.nextSlide,\n        className: nextFlipperClassName\n      });\n    }\n  }\n  /**\n   * Sets new slide based on position\n   */\n\n\n  setNewSlidePosition(position) {\n    const newActiveId = this.slides[position].id;\n\n    if (typeof this.props.onActiveIdUpdate === \"function\") {\n      this.props.onActiveIdUpdate(newActiveId, false);\n    }\n\n    this.setState({\n      activeId: newActiveId\n    });\n  }\n\n}\n\nCarousel.displayName = `${DisplayNamePrefix}Carousel`;\nCarousel.defaultProps = {\n  autoplay: false,\n  autoplayInterval: 6000,\n  loop: true,\n  managedClasses: {}\n};\nexport default Carousel;\nexport * from \"./carousel.props\";","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-react-msft/dist/carousel/carousel.js"],"names":["Foundation","Tabs","classNames","canUseDOM","get","isNil","React","Flipper","FlipperDirection","DisplayNamePrefix","CarouselSlideTheme","Carousel","constructor","props","handledProps","autoplay","autoplayInterval","managedClasses","nextFlipper","previousFlipper","label","loop","activeId","onActiveIdUpdate","items","slideTransitionDirection","assignTransitionDirectionClassName","carousel__slideAnimateNext","carousel__slideAnimatePrevious","transitionDirection","next","assignSlideThemeClassName","carousel__themeLight","carousel__themeDark","theme","getSlideTheme","light","handleUpdate","activeTab","setState","activeTabIndex","slides","map","slide","id","indexOf","setTransitionDirection","autoplayNextSlide","nextPosition","getActiveIndex","length","nextSlide","newPosition","setNewSlidePosition","previousSlide","rootEl","createRef","Array","isArray","state","getDerivedStateFromProps","nextProps","prevState","render","createElement","Object","assign","unhandledProps","className","generateClassNames","ref","generatePreviousFlipper","onUpdate","generateTabsClassNames","disableTabFocus","generateNextFlipper","componentDidMount","autoplayTimer","window","setInterval","componentDidUpdate","prevProps","clearInterval","componentWillUnmount","carousel","carousel_slides","carousel_tabPanels","carousel_sequenceIndicators","carousel_tabPanelContent","carousel_sequenceIndicator","carousel_sequenceIndicator__active","carousel_tabPanel","carousel_tabPanel__hidden","tabs","tabs_tabPanels","tabs_tabList","tabs_tabPanelContent","tab","tab__active","tabPanel","tabPanel__hidden","Fragment","isMultipleSlides","isFirstSlide","firstSlideId","isLastSlide","lastItemKey","lastSlideId","dark","incomingIndex","previous","previousFlipperClassName","carousel_flipperPrevious","direction","onClick","nextFlipperClassName","carousel_flipperNext","position","newActiveId","displayName","defaultProps"],"mappings":"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","sourcesContent":["import Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { Tabs } from \"@microsoft/fast-components-react-base\";\nimport { classNames } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isNil } from \"lodash-es\";\nimport React from \"react\";\nimport { Flipper, FlipperDirection } from \"../flipper\";\nimport { DisplayNamePrefix } from \"../utilities\";\nimport { CarouselSlideTheme, } from \"./carousel.props\";\nclass Carousel extends Foundation {\n    /**\n     * Define constructor\n     */\n    constructor(props) {\n        super(props);\n        /**\n         * Handled props\n         */\n        this.handledProps = {\n            autoplay: void 0,\n            autoplayInterval: void 0,\n            managedClasses: void 0,\n            nextFlipper: void 0,\n            previousFlipper: void 0,\n            label: void 0,\n            loop: void 0,\n            activeId: void 0,\n            onActiveIdUpdate: void 0,\n            items: void 0,\n        };\n        /**\n         * Initial slide transition direction is none (on carousel load)\n         */\n        this.slideTransitionDirection = null;\n        /**\n         * Return transition direction class name\n         */\n        this.assignTransitionDirectionClassName = () => {\n            const { carousel__slideAnimateNext, carousel__slideAnimatePrevious, } = this.props.managedClasses;\n            const transitionDirection = this.slideTransitionDirection === FlipperDirection.next\n                ? carousel__slideAnimateNext\n                : carousel__slideAnimatePrevious;\n            return ` ${transitionDirection}`;\n        };\n        /**\n         * Return slide theme class name\n         */\n        this.assignSlideThemeClassName = () => {\n            const { carousel__themeLight, carousel__themeDark, } = this.props.managedClasses;\n            const theme = this.getSlideTheme() === CarouselSlideTheme.light\n                ? carousel__themeLight\n                : carousel__themeDark;\n            return ` ${theme}`;\n        };\n        /**\n         * Change active tab\n         */\n        this.handleUpdate = (activeTab) => {\n            if (typeof this.props.onActiveIdUpdate === \"function\") {\n                this.props.onActiveIdUpdate(activeTab, false);\n            }\n            this.setState({\n                activeId: activeTab,\n            });\n            const activeTabIndex = this.slides\n                .map((slide) => slide.id)\n                .indexOf(activeTab);\n            this.setTransitionDirection(activeTabIndex);\n        };\n        /**\n         * Handles automation of slide movement\n         */\n        this.autoplayNextSlide = () => {\n            let nextPosition = this.getActiveIndex() + 1;\n            if (nextPosition > this.slides.length - 1) {\n                nextPosition = 0;\n            }\n            const activeId = this.slides[nextPosition].id;\n            this.setTransitionDirection(nextPosition);\n            if (typeof this.props.onActiveIdUpdate === \"function\") {\n                this.props.onActiveIdUpdate(activeId, true);\n            }\n            this.setState({\n                activeId,\n            });\n        };\n        /**\n         * Move to next slide if applicable\n         */\n        this.nextSlide = () => {\n            let newPosition = this.getActiveIndex() + 1;\n            if (newPosition > this.slides.length - 1) {\n                newPosition = 0;\n            }\n            this.setTransitionDirection(newPosition);\n            this.setNewSlidePosition(newPosition);\n        };\n        /**\n         * Move to previous slide if applicable\n         */\n        this.previousSlide = () => {\n            let newPosition = this.getActiveIndex() - 1;\n            if (newPosition < 0) {\n                newPosition = this.slides.length - 1;\n            }\n            this.setTransitionDirection(newPosition);\n            this.setNewSlidePosition(newPosition);\n        };\n        this.rootEl = React.createRef();\n        if (Array.isArray(this.props.items)) {\n            this.state = {\n                activeId: typeof this.props.activeId === \"string\"\n                    ? this.props.activeId\n                    : get(this.props.items[0], \"id\", \" \"),\n            };\n        }\n    }\n    /**\n     * React life-cycle method\n     */\n    static getDerivedStateFromProps(nextProps, prevState) {\n        if (nextProps.activeId && nextProps.activeId !== prevState.activeId) {\n            return {\n                activeId: nextProps.activeId,\n            };\n        }\n        return null;\n    }\n    /**\n     * Renders the component\n     */\n    render() {\n        return (React.createElement(\"div\", Object.assign({}, this.unhandledProps(), { className: this.generateClassNames(), ref: this.rootEl }),\n            this.generatePreviousFlipper(),\n            React.createElement(Tabs, { label: this.props.label, activeId: this.state.activeId, onUpdate: this.handleUpdate, items: this.slides, managedClasses: this.generateTabsClassNames(), disableTabFocus: this.props.autoplay }),\n            this.generateNextFlipper()));\n    }\n    /**\n     * React lifecycle hook\n     */\n    componentDidMount() {\n        if (canUseDOM() && this.props.autoplay) {\n            // Set initial interval for autoplay\n            this.autoplayTimer = window.setInterval(this.autoplayNextSlide, this.props.autoplayInterval);\n        }\n    }\n    /**\n     * React lifecycle hook\n     */\n    componentDidUpdate(prevProps, prevState) {\n        if (this.props.autoplay && isNil(this.autoplayTimer)) {\n            // Set the window interval if we are in autplay and don't have a timer\n            this.autoplayTimer = window.setInterval(this.autoplayNextSlide, this.props.autoplayInterval);\n        }\n        else if (!this.props.autoplay && !isNil(this.autoplayTimer)) {\n            // Clear the interval if we should not be autoplaying\n            this.autoplayTimer = window.clearInterval(this.autoplayTimer);\n        }\n    }\n    /**\n     * React lifecycle hook\n     */\n    componentWillUnmount() {\n        if (!isNil(this.autoplayTimer)) {\n            this.autoplayTimer = window.clearInterval(this.autoplayTimer);\n        }\n    }\n    /**\n     * Generate class names\n     */\n    generateClassNames() {\n        return super.generateClassNames(classNames(this.props.managedClasses.carousel, [this.assignSlideThemeClassName, !!this.getSlideTheme()], [\n            this.assignTransitionDirectionClassName(),\n            !!this.slideTransitionDirection,\n        ]));\n    }\n    /**\n     * Returns tabs managedclasses with new carousel-specific JSS\n     */\n    generateTabsClassNames() {\n        const { carousel_slides, carousel_tabPanels, carousel_sequenceIndicators, carousel_tabPanelContent, carousel_sequenceIndicator, carousel_sequenceIndicator__active, carousel_tabPanel, carousel_tabPanel__hidden, } = this.props.managedClasses;\n        return {\n            tabs: carousel_slides,\n            tabs_tabPanels: carousel_tabPanels,\n            tabs_tabList: carousel_sequenceIndicators,\n            tabs_tabPanelContent: carousel_tabPanelContent,\n            tab: carousel_sequenceIndicator,\n            tab__active: carousel_sequenceIndicator__active,\n            tabPanel: carousel_tabPanel,\n            tabPanel__hidden: carousel_tabPanel__hidden,\n        };\n    }\n    /**\n     * Get an array of slides\n     * Coerce tab shape\n     */\n    get slides() {\n        if (Array.isArray(this.props.items)) {\n            return this.props.items.map((slide) => Object.assign({}, slide, {\n                tab: () => React.createElement(React.Fragment, null),\n            }));\n        }\n        else {\n            return [];\n        }\n    }\n    /**\n     * Single slide carousels do not require certain interface elements\n     */\n    get isMultipleSlides() {\n        return this.slides.length !== 1;\n    }\n    /**\n     * Check if it is the FIRST slide for looping\n     */\n    get isFirstSlide() {\n        if (this.slides.length) {\n            const firstSlideId = this.slides[0].id;\n            return firstSlideId === this.state.activeId;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Check if it is the LAST slide for looping\n     */\n    get isLastSlide() {\n        const lastItemKey = this.slides.length - 1;\n        if (lastItemKey >= 0) {\n            const lastSlideId = this.slides[lastItemKey].id;\n            return lastSlideId === this.state.activeId;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Get the active slide index\n     */\n    getActiveIndex() {\n        return this.slides\n            .map((slide) => slide.id)\n            .indexOf(this.state.activeId);\n    }\n    /**\n     * Get the current slide theme (needed for UI overlay contrast)\n     */\n    getSlideTheme() {\n        if (this.slides.length <= 0) {\n            return;\n        }\n        return this.slides[this.getActiveIndex()].theme\n            ? this.slides[this.getActiveIndex()].theme\n            : CarouselSlideTheme.dark;\n    }\n    /**\n     * Set the transition direction based on incoming index\n     */\n    setTransitionDirection(incomingIndex) {\n        if (this.getActiveIndex() < incomingIndex) {\n            this.slideTransitionDirection = FlipperDirection.next;\n        }\n        else {\n            this.slideTransitionDirection = FlipperDirection.previous;\n        }\n    }\n    /**\n     * Generates previous flipper if more than one slide\n     */\n    generatePreviousFlipper() {\n        if (!this.isMultipleSlides || (this.isFirstSlide && !this.props.loop)) {\n            return;\n        }\n        const previousFlipperClassName = this.props.managedClasses\n            .carousel_flipperPrevious;\n        if (typeof this.props.previousFlipper === \"function\") {\n            return this.props.previousFlipper(this.previousSlide, previousFlipperClassName);\n        }\n        else {\n            return (React.createElement(Flipper, { direction: FlipperDirection.previous, onClick: this.previousSlide, className: previousFlipperClassName }));\n        }\n    }\n    /**\n     * Generates next flipper if more than one slide\n     */\n    generateNextFlipper() {\n        if (!this.isMultipleSlides || (this.isLastSlide && !this.props.loop)) {\n            return;\n        }\n        const nextFlipperClassName = this.props.managedClasses\n            .carousel_flipperNext;\n        if (typeof this.props.nextFlipper === \"function\") {\n            return this.props.nextFlipper(this.nextSlide, nextFlipperClassName);\n        }\n        else {\n            return (React.createElement(Flipper, { direction: FlipperDirection.next, onClick: this.nextSlide, className: nextFlipperClassName }));\n        }\n    }\n    /**\n     * Sets new slide based on position\n     */\n    setNewSlidePosition(position) {\n        const newActiveId = this.slides[position].id;\n        if (typeof this.props.onActiveIdUpdate === \"function\") {\n            this.props.onActiveIdUpdate(newActiveId, false);\n        }\n        this.setState({\n            activeId: newActiveId,\n        });\n    }\n}\nCarousel.displayName = `${DisplayNamePrefix}Carousel`;\nCarousel.defaultProps = {\n    autoplay: false,\n    autoplayInterval: 6000,\n    loop: true,\n    managedClasses: {},\n};\nexport default Carousel;\nexport * from \"./carousel.props\";\n"]},"metadata":{},"sourceType":"module"}