{"ast":null,"code":"import _classCallCheck from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { Tabs } from \"@microsoft/fast-components-react-base\";\nimport { classNames } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isNil } from \"lodash-es\";\nimport React from \"react\";\nimport { Flipper, FlipperDirection } from \"../flipper\";\nimport { DisplayNamePrefix } from \"../utilities\";\nimport { CarouselSlideTheme } from \"./carousel.props\";\n\nvar Carousel =\n/*#__PURE__*/\nfunction (_Foundation) {\n  _inherits(Carousel, _Foundation);\n\n  /**\n   * Define constructor\n   */\n  function Carousel(props) {\n    var _this;\n\n    _classCallCheck(this, Carousel);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Carousel).call(this, props));\n    /**\n     * Handled props\n     */\n\n    _this.handledProps = {\n      autoplay: void 0,\n      autoplayInterval: void 0,\n      managedClasses: void 0,\n      nextFlipper: void 0,\n      previousFlipper: void 0,\n      label: void 0,\n      loop: void 0,\n      activeId: void 0,\n      onActiveIdUpdate: void 0,\n      items: void 0\n    };\n    /**\n     * Initial slide transition direction is none (on carousel load)\n     */\n\n    _this.slideTransitionDirection = null;\n    /**\n     * Return transition direction class name\n     */\n\n    _this.assignTransitionDirectionClassName = function () {\n      var _this$props$managedCl = _this.props.managedClasses,\n          carousel__slideAnimateNext = _this$props$managedCl.carousel__slideAnimateNext,\n          carousel__slideAnimatePrevious = _this$props$managedCl.carousel__slideAnimatePrevious;\n      var transitionDirection = _this.slideTransitionDirection === FlipperDirection.next ? carousel__slideAnimateNext : carousel__slideAnimatePrevious;\n      return \" \".concat(transitionDirection);\n    };\n    /**\n     * Return slide theme class name\n     */\n\n\n    _this.assignSlideThemeClassName = function () {\n      var _this$props$managedCl2 = _this.props.managedClasses,\n          carousel__themeLight = _this$props$managedCl2.carousel__themeLight,\n          carousel__themeDark = _this$props$managedCl2.carousel__themeDark;\n      var theme = _this.getSlideTheme() === CarouselSlideTheme.light ? carousel__themeLight : carousel__themeDark;\n      return \" \".concat(theme);\n    };\n    /**\n     * Change active tab\n     */\n\n\n    _this.handleUpdate = function (activeTab) {\n      if (typeof _this.props.onActiveIdUpdate === \"function\") {\n        _this.props.onActiveIdUpdate(activeTab, false);\n      }\n\n      _this.setState({\n        activeId: activeTab\n      });\n\n      var activeTabIndex = _this.slides.map(function (slide) {\n        return slide.id;\n      }).indexOf(activeTab);\n\n      _this.setTransitionDirection(activeTabIndex);\n    };\n    /**\n     * Handles automation of slide movement\n     */\n\n\n    _this.autoplayNextSlide = function () {\n      var nextPosition = _this.getActiveIndex() + 1;\n\n      if (nextPosition > _this.slides.length - 1) {\n        nextPosition = 0;\n      }\n\n      var activeId = _this.slides[nextPosition].id;\n\n      _this.setTransitionDirection(nextPosition);\n\n      if (typeof _this.props.onActiveIdUpdate === \"function\") {\n        _this.props.onActiveIdUpdate(activeId, true);\n      }\n\n      _this.setState({\n        activeId: activeId\n      });\n    };\n    /**\n     * Move to next slide if applicable\n     */\n\n\n    _this.nextSlide = function () {\n      var newPosition = _this.getActiveIndex() + 1;\n\n      if (newPosition > _this.slides.length - 1) {\n        newPosition = 0;\n      }\n\n      _this.setTransitionDirection(newPosition);\n\n      _this.setNewSlidePosition(newPosition);\n    };\n    /**\n     * Move to previous slide if applicable\n     */\n\n\n    _this.previousSlide = function () {\n      var newPosition = _this.getActiveIndex() - 1;\n\n      if (newPosition < 0) {\n        newPosition = _this.slides.length - 1;\n      }\n\n      _this.setTransitionDirection(newPosition);\n\n      _this.setNewSlidePosition(newPosition);\n    };\n\n    _this.rootEl = React.createRef();\n\n    if (Array.isArray(_this.props.items)) {\n      _this.state = {\n        activeId: typeof _this.props.activeId === \"string\" ? _this.props.activeId : get(_this.props.items[0], \"id\", \" \")\n      };\n    }\n\n    return _this;\n  }\n  /**\n   * React life-cycle method\n   */\n\n\n  _createClass(Carousel, [{\n    key: \"render\",\n\n    /**\n     * Renders the component\n     */\n    value: function render() {\n      return React.createElement(\"div\", Object.assign({}, this.unhandledProps(), {\n        className: this.generateClassNames(),\n        ref: this.rootEl\n      }), this.generatePreviousFlipper(), React.createElement(Tabs, {\n        label: this.props.label,\n        activeId: this.state.activeId,\n        onUpdate: this.handleUpdate,\n        items: this.slides,\n        managedClasses: this.generateTabsClassNames(),\n        disableTabFocus: this.props.autoplay\n      }), this.generateNextFlipper());\n    }\n    /**\n     * React lifecycle hook\n     */\n\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (canUseDOM() && this.props.autoplay) {\n        // Set initial interval for autoplay\n        this.autoplayTimer = window.setInterval(this.autoplayNextSlide, this.props.autoplayInterval);\n      }\n    }\n    /**\n     * React lifecycle hook\n     */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (this.props.autoplay && isNil(this.autoplayTimer)) {\n        // Set the window interval if we are in autplay and don't have a timer\n        this.autoplayTimer = window.setInterval(this.autoplayNextSlide, this.props.autoplayInterval);\n      } else if (!this.props.autoplay && !isNil(this.autoplayTimer)) {\n        // Clear the interval if we should not be autoplaying\n        this.autoplayTimer = window.clearInterval(this.autoplayTimer);\n      }\n    }\n    /**\n     * React lifecycle hook\n     */\n\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (!isNil(this.autoplayTimer)) {\n        this.autoplayTimer = window.clearInterval(this.autoplayTimer);\n      }\n    }\n    /**\n     * Generate class names\n     */\n\n  }, {\n    key: \"generateClassNames\",\n    value: function generateClassNames() {\n      return _get(_getPrototypeOf(Carousel.prototype), \"generateClassNames\", this).call(this, classNames(this.props.managedClasses.carousel, [this.assignSlideThemeClassName, !!this.getSlideTheme()], [this.assignTransitionDirectionClassName(), !!this.slideTransitionDirection]));\n    }\n    /**\n     * Returns tabs managedclasses with new carousel-specific JSS\n     */\n\n  }, {\n    key: \"generateTabsClassNames\",\n    value: function generateTabsClassNames() {\n      var _this$props$managedCl3 = this.props.managedClasses,\n          carousel_slides = _this$props$managedCl3.carousel_slides,\n          carousel_tabPanels = _this$props$managedCl3.carousel_tabPanels,\n          carousel_sequenceIndicators = _this$props$managedCl3.carousel_sequenceIndicators,\n          carousel_tabPanelContent = _this$props$managedCl3.carousel_tabPanelContent,\n          carousel_sequenceIndicator = _this$props$managedCl3.carousel_sequenceIndicator,\n          carousel_sequenceIndicator__active = _this$props$managedCl3.carousel_sequenceIndicator__active,\n          carousel_tabPanel = _this$props$managedCl3.carousel_tabPanel,\n          carousel_tabPanel__hidden = _this$props$managedCl3.carousel_tabPanel__hidden;\n      return {\n        tabs: carousel_slides,\n        tabs_tabPanels: carousel_tabPanels,\n        tabs_tabList: carousel_sequenceIndicators,\n        tabs_tabPanelContent: carousel_tabPanelContent,\n        tab: carousel_sequenceIndicator,\n        tab__active: carousel_sequenceIndicator__active,\n        tabPanel: carousel_tabPanel,\n        tabPanel__hidden: carousel_tabPanel__hidden\n      };\n    }\n    /**\n     * Get an array of slides\n     * Coerce tab shape\n     */\n\n  }, {\n    key: \"getActiveIndex\",\n\n    /**\n     * Get the active slide index\n     */\n    value: function getActiveIndex() {\n      return this.slides.map(function (slide) {\n        return slide.id;\n      }).indexOf(this.state.activeId);\n    }\n    /**\n     * Get the current slide theme (needed for UI overlay contrast)\n     */\n\n  }, {\n    key: \"getSlideTheme\",\n    value: function getSlideTheme() {\n      if (this.slides.length <= 0) {\n        return;\n      }\n\n      return this.slides[this.getActiveIndex()].theme ? this.slides[this.getActiveIndex()].theme : CarouselSlideTheme.dark;\n    }\n    /**\n     * Set the transition direction based on incoming index\n     */\n\n  }, {\n    key: \"setTransitionDirection\",\n    value: function setTransitionDirection(incomingIndex) {\n      if (this.getActiveIndex() < incomingIndex) {\n        this.slideTransitionDirection = FlipperDirection.next;\n      } else {\n        this.slideTransitionDirection = FlipperDirection.previous;\n      }\n    }\n    /**\n     * Generates previous flipper if more than one slide\n     */\n\n  }, {\n    key: \"generatePreviousFlipper\",\n    value: function generatePreviousFlipper() {\n      if (!this.isMultipleSlides || this.isFirstSlide && !this.props.loop) {\n        return;\n      }\n\n      var previousFlipperClassName = this.props.managedClasses.carousel_flipperPrevious;\n\n      if (typeof this.props.previousFlipper === \"function\") {\n        return this.props.previousFlipper(this.previousSlide, previousFlipperClassName);\n      } else {\n        return React.createElement(Flipper, {\n          direction: FlipperDirection.previous,\n          onClick: this.previousSlide,\n          className: previousFlipperClassName\n        });\n      }\n    }\n    /**\n     * Generates next flipper if more than one slide\n     */\n\n  }, {\n    key: \"generateNextFlipper\",\n    value: function generateNextFlipper() {\n      if (!this.isMultipleSlides || this.isLastSlide && !this.props.loop) {\n        return;\n      }\n\n      var nextFlipperClassName = this.props.managedClasses.carousel_flipperNext;\n\n      if (typeof this.props.nextFlipper === \"function\") {\n        return this.props.nextFlipper(this.nextSlide, nextFlipperClassName);\n      } else {\n        return React.createElement(Flipper, {\n          direction: FlipperDirection.next,\n          onClick: this.nextSlide,\n          className: nextFlipperClassName\n        });\n      }\n    }\n    /**\n     * Sets new slide based on position\n     */\n\n  }, {\n    key: \"setNewSlidePosition\",\n    value: function setNewSlidePosition(position) {\n      var newActiveId = this.slides[position].id;\n\n      if (typeof this.props.onActiveIdUpdate === \"function\") {\n        this.props.onActiveIdUpdate(newActiveId, false);\n      }\n\n      this.setState({\n        activeId: newActiveId\n      });\n    }\n  }, {\n    key: \"slides\",\n    get: function get() {\n      if (Array.isArray(this.props.items)) {\n        return this.props.items.map(function (slide) {\n          return Object.assign({}, slide, {\n            tab: function tab() {\n              return React.createElement(React.Fragment, null);\n            }\n          });\n        });\n      } else {\n        return [];\n      }\n    }\n    /**\n     * Single slide carousels do not require certain interface elements\n     */\n\n  }, {\n    key: \"isMultipleSlides\",\n    get: function get() {\n      return this.slides.length !== 1;\n    }\n    /**\n     * Check if it is the FIRST slide for looping\n     */\n\n  }, {\n    key: \"isFirstSlide\",\n    get: function get() {\n      if (this.slides.length) {\n        var firstSlideId = this.slides[0].id;\n        return firstSlideId === this.state.activeId;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Check if it is the LAST slide for looping\n     */\n\n  }, {\n    key: \"isLastSlide\",\n    get: function get() {\n      var lastItemKey = this.slides.length - 1;\n\n      if (lastItemKey >= 0) {\n        var lastSlideId = this.slides[lastItemKey].id;\n        return lastSlideId === this.state.activeId;\n      } else {\n        return false;\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.activeId && nextProps.activeId !== prevState.activeId) {\n        return {\n          activeId: nextProps.activeId\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return Carousel;\n}(Foundation);\n\nCarousel.displayName = \"\".concat(DisplayNamePrefix, \"Carousel\");\nCarousel.defaultProps = {\n  autoplay: false,\n  autoplayInterval: 6000,\n  loop: true,\n  managedClasses: {}\n};\nexport default Carousel;\nexport * from \"./carousel.props\";","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-react-msft/dist/carousel/carousel.js"],"names":["Foundation","Tabs","classNames","canUseDOM","get","isNil","React","Flipper","FlipperDirection","DisplayNamePrefix","CarouselSlideTheme","Carousel","props","handledProps","autoplay","autoplayInterval","managedClasses","nextFlipper","previousFlipper","label","loop","activeId","onActiveIdUpdate","items","slideTransitionDirection","assignTransitionDirectionClassName","carousel__slideAnimateNext","carousel__slideAnimatePrevious","transitionDirection","next","assignSlideThemeClassName","carousel__themeLight","carousel__themeDark","theme","getSlideTheme","light","handleUpdate","activeTab","setState","activeTabIndex","slides","map","slide","id","indexOf","setTransitionDirection","autoplayNextSlide","nextPosition","getActiveIndex","length","nextSlide","newPosition","setNewSlidePosition","previousSlide","rootEl","createRef","Array","isArray","state","createElement","Object","assign","unhandledProps","className","generateClassNames","ref","generatePreviousFlipper","onUpdate","generateTabsClassNames","disableTabFocus","generateNextFlipper","autoplayTimer","window","setInterval","prevProps","prevState","clearInterval","carousel","carousel_slides","carousel_tabPanels","carousel_sequenceIndicators","carousel_tabPanelContent","carousel_sequenceIndicator","carousel_sequenceIndicator__active","carousel_tabPanel","carousel_tabPanel__hidden","tabs","tabs_tabPanels","tabs_tabList","tabs_tabPanelContent","tab","tab__active","tabPanel","tabPanel__hidden","dark","incomingIndex","previous","isMultipleSlides","isFirstSlide","previousFlipperClassName","carousel_flipperPrevious","direction","onClick","isLastSlide","nextFlipperClassName","carousel_flipperNext","position","newActiveId","Fragment","firstSlideId","lastItemKey","lastSlideId","nextProps","displayName","defaultProps"],"mappings":"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","sourcesContent":["import Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { Tabs } from \"@microsoft/fast-components-react-base\";\nimport { classNames } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isNil } from \"lodash-es\";\nimport React from \"react\";\nimport { Flipper, FlipperDirection } from \"../flipper\";\nimport { DisplayNamePrefix } from \"../utilities\";\nimport { CarouselSlideTheme, } from \"./carousel.props\";\nclass Carousel extends Foundation {\n    /**\n     * Define constructor\n     */\n    constructor(props) {\n        super(props);\n        /**\n         * Handled props\n         */\n        this.handledProps = {\n            autoplay: void 0,\n            autoplayInterval: void 0,\n            managedClasses: void 0,\n            nextFlipper: void 0,\n            previousFlipper: void 0,\n            label: void 0,\n            loop: void 0,\n            activeId: void 0,\n            onActiveIdUpdate: void 0,\n            items: void 0,\n        };\n        /**\n         * Initial slide transition direction is none (on carousel load)\n         */\n        this.slideTransitionDirection = null;\n        /**\n         * Return transition direction class name\n         */\n        this.assignTransitionDirectionClassName = () => {\n            const { carousel__slideAnimateNext, carousel__slideAnimatePrevious, } = this.props.managedClasses;\n            const transitionDirection = this.slideTransitionDirection === FlipperDirection.next\n                ? carousel__slideAnimateNext\n                : carousel__slideAnimatePrevious;\n            return ` ${transitionDirection}`;\n        };\n        /**\n         * Return slide theme class name\n         */\n        this.assignSlideThemeClassName = () => {\n            const { carousel__themeLight, carousel__themeDark, } = this.props.managedClasses;\n            const theme = this.getSlideTheme() === CarouselSlideTheme.light\n                ? carousel__themeLight\n                : carousel__themeDark;\n            return ` ${theme}`;\n        };\n        /**\n         * Change active tab\n         */\n        this.handleUpdate = (activeTab) => {\n            if (typeof this.props.onActiveIdUpdate === \"function\") {\n                this.props.onActiveIdUpdate(activeTab, false);\n            }\n            this.setState({\n                activeId: activeTab,\n            });\n            const activeTabIndex = this.slides\n                .map((slide) => slide.id)\n                .indexOf(activeTab);\n            this.setTransitionDirection(activeTabIndex);\n        };\n        /**\n         * Handles automation of slide movement\n         */\n        this.autoplayNextSlide = () => {\n            let nextPosition = this.getActiveIndex() + 1;\n            if (nextPosition > this.slides.length - 1) {\n                nextPosition = 0;\n            }\n            const activeId = this.slides[nextPosition].id;\n            this.setTransitionDirection(nextPosition);\n            if (typeof this.props.onActiveIdUpdate === \"function\") {\n                this.props.onActiveIdUpdate(activeId, true);\n            }\n            this.setState({\n                activeId,\n            });\n        };\n        /**\n         * Move to next slide if applicable\n         */\n        this.nextSlide = () => {\n            let newPosition = this.getActiveIndex() + 1;\n            if (newPosition > this.slides.length - 1) {\n                newPosition = 0;\n            }\n            this.setTransitionDirection(newPosition);\n            this.setNewSlidePosition(newPosition);\n        };\n        /**\n         * Move to previous slide if applicable\n         */\n        this.previousSlide = () => {\n            let newPosition = this.getActiveIndex() - 1;\n            if (newPosition < 0) {\n                newPosition = this.slides.length - 1;\n            }\n            this.setTransitionDirection(newPosition);\n            this.setNewSlidePosition(newPosition);\n        };\n        this.rootEl = React.createRef();\n        if (Array.isArray(this.props.items)) {\n            this.state = {\n                activeId: typeof this.props.activeId === \"string\"\n                    ? this.props.activeId\n                    : get(this.props.items[0], \"id\", \" \"),\n            };\n        }\n    }\n    /**\n     * React life-cycle method\n     */\n    static getDerivedStateFromProps(nextProps, prevState) {\n        if (nextProps.activeId && nextProps.activeId !== prevState.activeId) {\n            return {\n                activeId: nextProps.activeId,\n            };\n        }\n        return null;\n    }\n    /**\n     * Renders the component\n     */\n    render() {\n        return (React.createElement(\"div\", Object.assign({}, this.unhandledProps(), { className: this.generateClassNames(), ref: this.rootEl }),\n            this.generatePreviousFlipper(),\n            React.createElement(Tabs, { label: this.props.label, activeId: this.state.activeId, onUpdate: this.handleUpdate, items: this.slides, managedClasses: this.generateTabsClassNames(), disableTabFocus: this.props.autoplay }),\n            this.generateNextFlipper()));\n    }\n    /**\n     * React lifecycle hook\n     */\n    componentDidMount() {\n        if (canUseDOM() && this.props.autoplay) {\n            // Set initial interval for autoplay\n            this.autoplayTimer = window.setInterval(this.autoplayNextSlide, this.props.autoplayInterval);\n        }\n    }\n    /**\n     * React lifecycle hook\n     */\n    componentDidUpdate(prevProps, prevState) {\n        if (this.props.autoplay && isNil(this.autoplayTimer)) {\n            // Set the window interval if we are in autplay and don't have a timer\n            this.autoplayTimer = window.setInterval(this.autoplayNextSlide, this.props.autoplayInterval);\n        }\n        else if (!this.props.autoplay && !isNil(this.autoplayTimer)) {\n            // Clear the interval if we should not be autoplaying\n            this.autoplayTimer = window.clearInterval(this.autoplayTimer);\n        }\n    }\n    /**\n     * React lifecycle hook\n     */\n    componentWillUnmount() {\n        if (!isNil(this.autoplayTimer)) {\n            this.autoplayTimer = window.clearInterval(this.autoplayTimer);\n        }\n    }\n    /**\n     * Generate class names\n     */\n    generateClassNames() {\n        return super.generateClassNames(classNames(this.props.managedClasses.carousel, [this.assignSlideThemeClassName, !!this.getSlideTheme()], [\n            this.assignTransitionDirectionClassName(),\n            !!this.slideTransitionDirection,\n        ]));\n    }\n    /**\n     * Returns tabs managedclasses with new carousel-specific JSS\n     */\n    generateTabsClassNames() {\n        const { carousel_slides, carousel_tabPanels, carousel_sequenceIndicators, carousel_tabPanelContent, carousel_sequenceIndicator, carousel_sequenceIndicator__active, carousel_tabPanel, carousel_tabPanel__hidden, } = this.props.managedClasses;\n        return {\n            tabs: carousel_slides,\n            tabs_tabPanels: carousel_tabPanels,\n            tabs_tabList: carousel_sequenceIndicators,\n            tabs_tabPanelContent: carousel_tabPanelContent,\n            tab: carousel_sequenceIndicator,\n            tab__active: carousel_sequenceIndicator__active,\n            tabPanel: carousel_tabPanel,\n            tabPanel__hidden: carousel_tabPanel__hidden,\n        };\n    }\n    /**\n     * Get an array of slides\n     * Coerce tab shape\n     */\n    get slides() {\n        if (Array.isArray(this.props.items)) {\n            return this.props.items.map((slide) => Object.assign({}, slide, {\n                tab: () => React.createElement(React.Fragment, null),\n            }));\n        }\n        else {\n            return [];\n        }\n    }\n    /**\n     * Single slide carousels do not require certain interface elements\n     */\n    get isMultipleSlides() {\n        return this.slides.length !== 1;\n    }\n    /**\n     * Check if it is the FIRST slide for looping\n     */\n    get isFirstSlide() {\n        if (this.slides.length) {\n            const firstSlideId = this.slides[0].id;\n            return firstSlideId === this.state.activeId;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Check if it is the LAST slide for looping\n     */\n    get isLastSlide() {\n        const lastItemKey = this.slides.length - 1;\n        if (lastItemKey >= 0) {\n            const lastSlideId = this.slides[lastItemKey].id;\n            return lastSlideId === this.state.activeId;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Get the active slide index\n     */\n    getActiveIndex() {\n        return this.slides\n            .map((slide) => slide.id)\n            .indexOf(this.state.activeId);\n    }\n    /**\n     * Get the current slide theme (needed for UI overlay contrast)\n     */\n    getSlideTheme() {\n        if (this.slides.length <= 0) {\n            return;\n        }\n        return this.slides[this.getActiveIndex()].theme\n            ? this.slides[this.getActiveIndex()].theme\n            : CarouselSlideTheme.dark;\n    }\n    /**\n     * Set the transition direction based on incoming index\n     */\n    setTransitionDirection(incomingIndex) {\n        if (this.getActiveIndex() < incomingIndex) {\n            this.slideTransitionDirection = FlipperDirection.next;\n        }\n        else {\n            this.slideTransitionDirection = FlipperDirection.previous;\n        }\n    }\n    /**\n     * Generates previous flipper if more than one slide\n     */\n    generatePreviousFlipper() {\n        if (!this.isMultipleSlides || (this.isFirstSlide && !this.props.loop)) {\n            return;\n        }\n        const previousFlipperClassName = this.props.managedClasses\n            .carousel_flipperPrevious;\n        if (typeof this.props.previousFlipper === \"function\") {\n            return this.props.previousFlipper(this.previousSlide, previousFlipperClassName);\n        }\n        else {\n            return (React.createElement(Flipper, { direction: FlipperDirection.previous, onClick: this.previousSlide, className: previousFlipperClassName }));\n        }\n    }\n    /**\n     * Generates next flipper if more than one slide\n     */\n    generateNextFlipper() {\n        if (!this.isMultipleSlides || (this.isLastSlide && !this.props.loop)) {\n            return;\n        }\n        const nextFlipperClassName = this.props.managedClasses\n            .carousel_flipperNext;\n        if (typeof this.props.nextFlipper === \"function\") {\n            return this.props.nextFlipper(this.nextSlide, nextFlipperClassName);\n        }\n        else {\n            return (React.createElement(Flipper, { direction: FlipperDirection.next, onClick: this.nextSlide, className: nextFlipperClassName }));\n        }\n    }\n    /**\n     * Sets new slide based on position\n     */\n    setNewSlidePosition(position) {\n        const newActiveId = this.slides[position].id;\n        if (typeof this.props.onActiveIdUpdate === \"function\") {\n            this.props.onActiveIdUpdate(newActiveId, false);\n        }\n        this.setState({\n            activeId: newActiveId,\n        });\n    }\n}\nCarousel.displayName = `${DisplayNamePrefix}Carousel`;\nCarousel.defaultProps = {\n    autoplay: false,\n    autoplayInterval: 6000,\n    loop: true,\n    managedClasses: {},\n};\nexport default Carousel;\nexport * from \"./carousel.props\";\n"]},"metadata":{},"sourceType":"module"}