{"ast":null,"code":"import React from \"react\";\nimport Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames, getDisplayedNodes, isHTMLElement, keyCodeEnd, keyCodeHome } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { DisplayNamePrefix } from \"../utilities\";\nexport const TreeViewContext = React.createContext({\n  setLastFocused: null,\n  adjustNestedTreeItemCount: null,\n  nested: false\n});\n/**\n * Simple state machine to track how many nodes have nested nodes\n */\n\nclass ChildNodeCountTracker {\n  constructor() {\n    this._count = 0;\n  }\n\n  get count() {\n    return this._count;\n  }\n\n  adjust(delta) {\n    this._count += delta;\n  }\n\n}\n/* tslint:disable-next-line */\n\n\nclass TreeView extends Foundation {\n  constructor(props) {\n    super(props);\n    this.handledProps = {\n      managedClasses: void 0,\n      children: void 0\n    };\n    this.rootElement = React.createRef();\n    /**\n     * Track how many tree-items have children\n     */\n\n    this.nestedTreeItemTracker = new ChildNodeCountTracker();\n\n    this.setLastFocused = ref => {\n      this.setState({\n        lastFocused: ref\n      });\n    };\n\n    this.adjustNestedTreeItemCount = delta => {\n      this.nestedTreeItemTracker.adjust(delta);\n\n      if (this.nestedTreeItemTracker.count > 0 && !this.state.nested) {\n        this.setState({\n          nested: true\n        });\n      } else if (this.nestedTreeItemTracker.count === 0 && this.state.nested) {\n        this.setState({\n          nested: false\n        });\n      }\n    };\n\n    this.handleBlur = e => {\n      const root = this.rootElement.current;\n      /**\n       * If we focus outside of the tree\n       */\n\n      if (isHTMLElement(root) && !root.contains(e.relatedTarget)) {\n        this.setState({\n          focusable: true\n        });\n      }\n    };\n\n    this.handleFocus = e => {\n      if (!canUseDOM() || !isHTMLElement(this.rootElement.current)) {\n        return;\n      }\n\n      const root = this.rootElement.current;\n      const lastFocused = this.state.lastFocused;\n      /**\n       * If the tree view is receiving focus\n       */\n\n      if (isHTMLElement(root) && root === e.target) {\n        // If we have a last focused item, focus it - otherwise check for an initially selected item or focus the first \"[role='treeitem']\"\n        // If there is no \"[role='treeitem']\" to be focused AND no last-focused, then there are likely no children\n        // or children are malformed so keep the tree in the tab-order in the hopes that the author cleans up\n        // the children\n        const selectedChild = root.querySelector(\"[aria-selected='true']\");\n        const toBeFocused = !!lastFocused ? lastFocused.current : !!selectedChild ? selectedChild : root.querySelector(\"[role='treeitem']\");\n\n        if (isHTMLElement(toBeFocused)) {\n          toBeFocused.focus();\n\n          if (this.state.focusable) {\n            this.setState({\n              focusable: false\n            });\n          }\n        }\n      } else {\n        // A child is receiving focus. While focus is within the tree, we simply need to ensure\n        // that the tree is not focusable.\n        if (this.state.focusable) {\n          this.setState({\n            focusable: false\n          });\n        }\n      }\n    };\n\n    this.handleKeyDown = e => {\n      let nodes;\n\n      if (canUseDOM()) {\n        switch (e.keyCode) {\n          case keyCodeHome:\n            nodes = this.getVisibleNodes();\n\n            if (nodes && nodes.length) {\n              nodes[0].focus();\n            }\n\n            break;\n\n          case keyCodeEnd:\n            nodes = this.getVisibleNodes();\n\n            if (nodes && nodes.length) {\n              nodes[nodes.length - 1].focus();\n            }\n\n            break;\n        }\n      }\n    };\n\n    this.state = {\n      focusable: true,\n      lastFocused: null,\n      nested: false\n    };\n  }\n\n  render() {\n    return React.createElement(\"div\", Object.assign({}, this.unhandledProps(), {\n      role: \"tree\",\n      tabIndex: this.state.focusable ? 0 : -1,\n      className: this.generateClassNames(),\n      ref: this.rootElement,\n      onFocus: this.handleFocus,\n      onBlur: this.handleBlur,\n      onKeyDown: this.handleKeyDown\n    }), React.createElement(TreeViewContext.Provider, {\n      value: {\n        setLastFocused: this.setLastFocused,\n        adjustNestedTreeItemCount: this.adjustNestedTreeItemCount,\n        nested: this.state.nested\n      }\n    }, this.props.children));\n  }\n\n  componentDidUpdate() {\n    this.ensureFocusability();\n  }\n\n  generateClassNames() {\n    return super.generateClassNames(classNames(this.props.managedClasses.treeView));\n  }\n  /**\n   * Verifies that the tree has a focusable child.\n   * If it does not, the tree will begin to accept focus\n   */\n\n\n  ensureFocusability() {\n    if (canUseDOM() && !this.state.focusable && isHTMLElement(this.rootElement.current)) {\n      const focusableChild = this.rootElement.current.querySelector(\"[role='treeitem'][tabindex='0']\");\n\n      if (!isHTMLElement(focusableChild)) {\n        this.setState({\n          focusable: true\n        });\n      }\n    }\n  }\n\n  getVisibleNodes() {\n    return canUseDOM() ? getDisplayedNodes(this.rootElement.current, \"[role='treeitem']\") : [];\n  }\n\n}\n\nTreeView.displayName = `${DisplayNamePrefix}TreeView`;\nTreeView.defaultProps = {\n  managedClasses: {}\n};\nexport default TreeView;","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-react-base/dist/tree-view/tree-view.js"],"names":["React","Foundation","classNames","getDisplayedNodes","isHTMLElement","keyCodeEnd","keyCodeHome","canUseDOM","DisplayNamePrefix","TreeViewContext","createContext","setLastFocused","adjustNestedTreeItemCount","nested","ChildNodeCountTracker","constructor","_count","count","adjust","delta","TreeView","props","handledProps","managedClasses","children","rootElement","createRef","nestedTreeItemTracker","ref","setState","lastFocused","state","handleBlur","e","root","current","contains","relatedTarget","focusable","handleFocus","target","selectedChild","querySelector","toBeFocused","focus","handleKeyDown","nodes","keyCode","getVisibleNodes","length","render","createElement","Object","assign","unhandledProps","role","tabIndex","className","generateClassNames","onFocus","onBlur","onKeyDown","Provider","value","componentDidUpdate","ensureFocusability","treeView","focusableChild","displayName","defaultProps"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames, getDisplayedNodes, isHTMLElement, keyCodeEnd, keyCodeHome, } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { DisplayNamePrefix } from \"../utilities\";\nexport const TreeViewContext = React.createContext({\n    setLastFocused: null,\n    adjustNestedTreeItemCount: null,\n    nested: false,\n});\n/**\n * Simple state machine to track how many nodes have nested nodes\n */\nclass ChildNodeCountTracker {\n    constructor() {\n        this._count = 0;\n    }\n    get count() {\n        return this._count;\n    }\n    adjust(delta) {\n        this._count += delta;\n    }\n}\n/* tslint:disable-next-line */\nclass TreeView extends Foundation {\n    constructor(props) {\n        super(props);\n        this.handledProps = {\n            managedClasses: void 0,\n            children: void 0,\n        };\n        this.rootElement = React.createRef();\n        /**\n         * Track how many tree-items have children\n         */\n        this.nestedTreeItemTracker = new ChildNodeCountTracker();\n        this.setLastFocused = (ref) => {\n            this.setState({\n                lastFocused: ref,\n            });\n        };\n        this.adjustNestedTreeItemCount = (delta) => {\n            this.nestedTreeItemTracker.adjust(delta);\n            if (this.nestedTreeItemTracker.count > 0 && !this.state.nested) {\n                this.setState({ nested: true });\n            }\n            else if (this.nestedTreeItemTracker.count === 0 && this.state.nested) {\n                this.setState({ nested: false });\n            }\n        };\n        this.handleBlur = (e) => {\n            const root = this.rootElement.current;\n            /**\n             * If we focus outside of the tree\n             */\n            if (isHTMLElement(root) && !root.contains(e.relatedTarget)) {\n                this.setState({\n                    focusable: true,\n                });\n            }\n        };\n        this.handleFocus = (e) => {\n            if (!canUseDOM() || !isHTMLElement(this.rootElement.current)) {\n                return;\n            }\n            const root = this.rootElement.current;\n            const lastFocused = this.state\n                .lastFocused;\n            /**\n             * If the tree view is receiving focus\n             */\n            if (isHTMLElement(root) && root === e.target) {\n                // If we have a last focused item, focus it - otherwise check for an initially selected item or focus the first \"[role='treeitem']\"\n                // If there is no \"[role='treeitem']\" to be focused AND no last-focused, then there are likely no children\n                // or children are malformed so keep the tree in the tab-order in the hopes that the author cleans up\n                // the children\n                const selectedChild = root.querySelector(\"[aria-selected='true']\");\n                const toBeFocused = !!lastFocused\n                    ? lastFocused.current\n                    : !!selectedChild\n                        ? selectedChild\n                        : root.querySelector(\"[role='treeitem']\");\n                if (isHTMLElement(toBeFocused)) {\n                    toBeFocused.focus();\n                    if (this.state.focusable) {\n                        this.setState({ focusable: false });\n                    }\n                }\n            }\n            else {\n                // A child is receiving focus. While focus is within the tree, we simply need to ensure\n                // that the tree is not focusable.\n                if (this.state.focusable) {\n                    this.setState({\n                        focusable: false,\n                    });\n                }\n            }\n        };\n        this.handleKeyDown = (e) => {\n            let nodes;\n            if (canUseDOM()) {\n                switch (e.keyCode) {\n                    case keyCodeHome:\n                        nodes = this.getVisibleNodes();\n                        if (nodes && nodes.length) {\n                            nodes[0].focus();\n                        }\n                        break;\n                    case keyCodeEnd:\n                        nodes = this.getVisibleNodes();\n                        if (nodes && nodes.length) {\n                            nodes[nodes.length - 1].focus();\n                        }\n                        break;\n                }\n            }\n        };\n        this.state = {\n            focusable: true,\n            lastFocused: null,\n            nested: false,\n        };\n    }\n    render() {\n        return (React.createElement(\"div\", Object.assign({}, this.unhandledProps(), { role: \"tree\", tabIndex: this.state.focusable ? 0 : -1, className: this.generateClassNames(), ref: this.rootElement, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown }),\n            React.createElement(TreeViewContext.Provider, { value: {\n                    setLastFocused: this.setLastFocused,\n                    adjustNestedTreeItemCount: this.adjustNestedTreeItemCount,\n                    nested: this.state.nested,\n                } }, this.props.children)));\n    }\n    componentDidUpdate() {\n        this.ensureFocusability();\n    }\n    generateClassNames() {\n        return super.generateClassNames(classNames(this.props.managedClasses.treeView));\n    }\n    /**\n     * Verifies that the tree has a focusable child.\n     * If it does not, the tree will begin to accept focus\n     */\n    ensureFocusability() {\n        if (canUseDOM() &&\n            !this.state.focusable &&\n            isHTMLElement(this.rootElement.current)) {\n            const focusableChild = this.rootElement.current.querySelector(\"[role='treeitem'][tabindex='0']\");\n            if (!isHTMLElement(focusableChild)) {\n                this.setState({\n                    focusable: true,\n                });\n            }\n        }\n    }\n    getVisibleNodes() {\n        return canUseDOM()\n            ? getDisplayedNodes(this.rootElement.current, \"[role='treeitem']\")\n            : [];\n    }\n}\nTreeView.displayName = `${DisplayNamePrefix}TreeView`;\nTreeView.defaultProps = {\n    managedClasses: {},\n};\nexport default TreeView;\n"]},"metadata":{},"sourceType":"module"}