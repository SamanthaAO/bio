{"ast":null,"code":"import _classCallCheck from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n// tslint:disable:member-ordering\n// tslint:disable:no-bitwise\n// tslint:disable:prefer-for-of\nimport { ColorRGBA64 } from \"./color-rgba-64\";\n/**\n * Adds a newItem to an already sorted list without needing to do a full re-sort.\n * Higher sort priority puts the newItem closer to the start (index 0) of the list.\n */\n\nexport function insertIntoSortedList(list, newItem, sortPriority) {\n  if (list.length === 0) {\n    list.push(newItem);\n    return;\n  }\n\n  var newItemPriority = sortPriority(newItem); // The new item being either first or last happens often enough that it is worth special casing\n  // In cases of a tie the new item should be inserted after existing items of the same priority\n\n  if (newItemPriority > sortPriority(list[0])) {\n    list.unshift(newItem);\n    return;\n  }\n\n  if (newItemPriority <= sortPriority(list[list.length - 1])) {\n    list.push(newItem);\n    return;\n  }\n\n  var newIndex = 0;\n\n  for (var i = 0; i < list.length; i++) {\n    if (newItemPriority > sortPriority(list[i])) {\n      newIndex = i;\n      break;\n    }\n  }\n\n  list.splice(newIndex, 0, newItem);\n}\n/**\n * Represents a range of colors in RGB color space.\n */\n\nexport var PixelBox = function PixelBox(globalHistogram, minRed, maxRed, minGreen, maxGreen, minBlue, maxBlue) {\n  var _this = this;\n\n  _classCallCheck(this, PixelBox);\n\n  /**\n   * Attempts to divide the range of colors represented by this PixelBox into two smaller PixelBox objects.\n   * This does not actually cut directly at the median, rather it finds the median then cuts halfway through the larger box on either side of that median. The result is that small areas of color are better represented in the final output.\n   * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c\n   */\n  this.modifiedMedianCut = function () {\n    if (_this.rangeRed === 1 && _this.rangeGreen === 1 && _this.rangeBlue === 1) {\n      // This box is already sliced as finely as possible\n      return [_this, null];\n    }\n\n    var CutAxis;\n\n    (function (CutAxis) {\n      CutAxis[CutAxis[\"Red\"] = 0] = \"Red\";\n      CutAxis[CutAxis[\"Green\"] = 1] = \"Green\";\n      CutAxis[CutAxis[\"Blue\"] = 2] = \"Blue\";\n    })(CutAxis || (CutAxis = {}));\n\n    var axis;\n    var axisRange;\n\n    if (_this.rangeRed >= _this.rangeGreen && _this.rangeRed >= _this.rangeBlue) {\n      axis = CutAxis.Red;\n      axisRange = _this.rangeRed;\n    } else if (_this.rangeGreen >= _this.rangeRed && _this.rangeGreen >= _this.rangeBlue) {\n      axis = CutAxis.Green;\n      axisRange = _this.rangeGreen;\n    } else {\n      axis = CutAxis.Blue;\n      axisRange = _this.rangeBlue;\n    }\n\n    var partialSum = new Array(axisRange);\n    var lookAheadSum = new Array(axisRange);\n    var retLeft = null;\n    var retRight = null;\n    var axisTotal = 0; // This does not actually cut directly at the median, rather it finds the median then\n    // cuts halfway through the larger box on either side of that median\n    // The result is that small areas of color are better represented in the final output\n\n    if (axis === CutAxis.Red) {\n      // Calculate partial sums\n      for (var r = _this.minRed; r <= _this.maxRed; r++) {\n        var sum = 0;\n\n        for (var g = _this.minGreen; g <= _this.maxGreen; g++) {\n          for (var b = _this.minBlue; b <= _this.maxBlue; b++) {\n            sum += _this.globalHistogram.getHistogramValue(r, g, b);\n          }\n        }\n\n        axisTotal += sum;\n        partialSum[r - _this.minRed] = axisTotal;\n      }\n\n      for (var i = 0; i < partialSum.length; i++) {\n        lookAheadSum[i] = axisTotal - partialSum[i];\n      } // Find the cut point based on partial sums vs total\n\n\n      for (var _r = _this.minRed; _r <= _this.maxRed; _r++) {\n        if (partialSum[_r - _this.minRed] >= axisTotal / 2) {\n          var left = _r - _this.minRed;\n          var right = _this.maxRed - _r;\n          var cut = void 0;\n\n          if (left <= right) {\n            cut = Math.min(_this.maxRed - 1, Math.floor(_r + right / 2));\n          } else {\n            cut = Math.max(_this.minRed, Math.floor(_r - 1 - left / 2));\n          } // Adjust the cut point if either side has 0 pixelCount\n\n\n          while (partialSum[cut - _this.minRed] <= 0 && cut < _this.maxRed - 1) {\n            cut++;\n          }\n\n          var lookAhead = lookAheadSum[cut - _this.minRed];\n\n          while (lookAhead === 0 && cut > _this.minRed && partialSum[cut - _this.minRed - 1] !== 0) {\n            cut--;\n            lookAhead = lookAheadSum[cut - _this.minRed];\n          }\n\n          retLeft = new PixelBox(_this.globalHistogram, _this.minRed, cut, _this.minGreen, _this.maxGreen, _this.minBlue, _this.maxBlue);\n          retRight = new PixelBox(_this.globalHistogram, cut + 1, _this.maxRed, _this.minGreen, _this.maxGreen, _this.minBlue, _this.maxBlue);\n          break;\n        }\n      }\n    } else if (axis === CutAxis.Green) {\n      // Calculate partial sums\n      for (var _g = _this.minGreen; _g <= _this.maxGreen; _g++) {\n        var _sum = 0;\n\n        for (var _r2 = _this.minRed; _r2 <= _this.maxRed; _r2++) {\n          for (var _b = _this.minBlue; _b <= _this.maxBlue; _b++) {\n            _sum += _this.globalHistogram.getHistogramValue(_r2, _g, _b);\n          }\n        }\n\n        axisTotal += _sum;\n        partialSum[_g - _this.minGreen] = axisTotal;\n      }\n\n      for (var _i = 0; _i < partialSum.length; _i++) {\n        lookAheadSum[_i] = axisTotal - partialSum[_i];\n      } // Find the cut point based on partial sums vs total\n\n\n      for (var _g2 = _this.minGreen; _g2 <= _this.maxGreen; _g2++) {\n        if (partialSum[_g2 - _this.minGreen] >= axisTotal / 2) {\n          var _left = _g2 - _this.minGreen;\n\n          var _right = _this.maxGreen - _g2;\n\n          var _cut = void 0;\n\n          if (_left <= _right) {\n            _cut = Math.min(_this.maxGreen - 1, Math.floor(_g2 + _right / 2));\n          } else {\n            _cut = Math.max(_this.minGreen, Math.floor(_g2 - 1 - _left / 2));\n          } // Adjust the cut point if either side has 0 pixelCount\n\n\n          while (partialSum[_cut - _this.minGreen] <= 0 && _cut < _this.maxGreen - 1) {\n            _cut++;\n          }\n\n          var _lookAhead = lookAheadSum[_cut - _this.minGreen];\n\n          while (_lookAhead === 0 && _cut > _this.minGreen && partialSum[_cut - _this.minGreen - 1] !== 0) {\n            _cut--;\n            _lookAhead = lookAheadSum[_cut - _this.minGreen];\n          }\n\n          retLeft = new PixelBox(_this.globalHistogram, _this.minRed, _this.maxRed, _this.minGreen, _cut, _this.minBlue, _this.maxBlue);\n          retRight = new PixelBox(_this.globalHistogram, _this.minRed, _this.maxRed, _cut + 1, _this.maxGreen, _this.minBlue, _this.maxBlue);\n          break;\n        }\n      }\n    } else {\n      // Calculate partial sums\n      for (var _b2 = _this.minBlue; _b2 <= _this.maxBlue; _b2++) {\n        var _sum2 = 0;\n\n        for (var _r3 = _this.minRed; _r3 <= _this.maxRed; _r3++) {\n          for (var _g3 = _this.minGreen; _g3 <= _this.maxGreen; _g3++) {\n            _sum2 += _this.globalHistogram.getHistogramValue(_r3, _g3, _b2);\n          }\n        }\n\n        axisTotal += _sum2;\n        partialSum[_b2 - _this.minBlue] = axisTotal;\n      }\n\n      for (var _i2 = 0; _i2 < partialSum.length; _i2++) {\n        lookAheadSum[_i2] = axisTotal - partialSum[_i2];\n      } // Find the cut point based on partial sums vs total\n\n\n      for (var _b3 = _this.minBlue; _b3 <= _this.maxBlue; _b3++) {\n        if (partialSum[_b3 - _this.minBlue] >= axisTotal / 2) {\n          var _left2 = _b3 - _this.minBlue;\n\n          var _right2 = _this.maxBlue - _b3;\n\n          var _cut2 = void 0;\n\n          if (_left2 <= _right2) {\n            _cut2 = Math.min(_this.maxBlue - 1, Math.floor(_b3 + _right2 / 2));\n          } else {\n            _cut2 = Math.max(_this.minBlue, Math.floor(_b3 - 1 - _left2 / 2));\n          } // Adjust the cut point if either side has 0 pixelCount\n\n\n          while (partialSum[_cut2 - _this.minBlue] <= 0 && _cut2 < _this.maxBlue - 1) {\n            _cut2++;\n          }\n\n          var _lookAhead2 = lookAheadSum[_cut2 - _this.minBlue];\n\n          while (_lookAhead2 === 0 && _cut2 > _this.minBlue && partialSum[_cut2 - _this.minBlue - 1] !== 0) {\n            _cut2--;\n            _lookAhead2 = lookAheadSum[_cut2 - _this.minBlue];\n          }\n\n          retLeft = new PixelBox(_this.globalHistogram, _this.minRed, _this.maxRed, _this.minGreen, _this.maxGreen, _this.minBlue, _cut2);\n          retRight = new PixelBox(_this.globalHistogram, _this.minRed, _this.maxRed, _this.minGreen, _this.maxGreen, _cut2 + 1, _this.maxBlue);\n          break;\n        }\n      }\n    }\n\n    return [retLeft, retRight];\n  };\n\n  this.pixelCount = 0;\n  this.globalHistogram = globalHistogram;\n  this.minRed = minRed;\n  this.maxRed = maxRed;\n  this.minGreen = minGreen;\n  this.maxGreen = maxGreen;\n  this.minBlue = minBlue;\n  this.maxBlue = maxBlue;\n  this.rangeRed = this.maxRed - this.minRed + 1;\n  this.rangeGreen = this.maxGreen - this.minGreen + 1;\n  this.rangeBlue = this.maxBlue - this.minBlue + 1;\n  this.colorVolume = this.rangeRed * this.rangeGreen * this.rangeBlue;\n  var redSum = 0;\n  var greenSum = 0;\n  var blueSum = 0;\n  var factor = 1 << 8 - this.globalHistogram.significantBits;\n\n  for (var r = minRed; r <= maxRed; r++) {\n    for (var g = minGreen; g <= maxGreen; g++) {\n      for (var b = minBlue; b <= maxBlue; b++) {\n        var histoValue = this.globalHistogram.getHistogramValue(r, g, b);\n        this.pixelCount += histoValue;\n        redSum += histoValue * (r + 0.5) * factor;\n        greenSum += histoValue * (g + 0.5) * factor;\n        blueSum += histoValue * (b + 0.5) * factor;\n      }\n    }\n  }\n\n  if (this.pixelCount === 0) {\n    this.averageColor = new ColorRGBA64(factor * ((minRed + maxRed + 1) / 2) / 255, factor * ((minGreen + maxGreen + 1) / 2) / 255, factor * ((minBlue + maxBlue + 1) / 2) / 255, 1);\n  } else {\n    this.averageColor = new ColorRGBA64(redSum / this.pixelCount / 255, greenSum / this.pixelCount / 255, blueSum / this.pixelCount / 255, 1);\n  }\n};","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-colors/dist/pixel-box.js"],"names":["ColorRGBA64","insertIntoSortedList","list","newItem","sortPriority","length","push","newItemPriority","unshift","newIndex","i","splice","PixelBox","globalHistogram","minRed","maxRed","minGreen","maxGreen","minBlue","maxBlue","modifiedMedianCut","rangeRed","rangeGreen","rangeBlue","CutAxis","axis","axisRange","Red","Green","Blue","partialSum","Array","lookAheadSum","retLeft","retRight","axisTotal","r","sum","g","b","getHistogramValue","left","right","cut","Math","min","floor","max","lookAhead","pixelCount","colorVolume","redSum","greenSum","blueSum","factor","significantBits","histoValue","averageColor"],"mappings":";AAAA;AACA;AACA;AACA,SAASA,WAAT,QAA4B,iBAA5B;AACA;;;;;AAIA,OAAO,SAASC,oBAAT,CAA8BC,IAA9B,EAAoCC,OAApC,EAA6CC,YAA7C,EAA2D;AAC9D,MAAIF,IAAI,CAACG,MAAL,KAAgB,CAApB,EAAuB;AACnBH,IAAAA,IAAI,CAACI,IAAL,CAAUH,OAAV;AACA;AACH;;AACD,MAAMI,eAAe,GAAGH,YAAY,CAACD,OAAD,CAApC,CAL8D,CAM9D;AACA;;AACA,MAAII,eAAe,GAAGH,YAAY,CAACF,IAAI,CAAC,CAAD,CAAL,CAAlC,EAA6C;AACzCA,IAAAA,IAAI,CAACM,OAAL,CAAaL,OAAb;AACA;AACH;;AACD,MAAII,eAAe,IAAIH,YAAY,CAACF,IAAI,CAACA,IAAI,CAACG,MAAL,GAAc,CAAf,CAAL,CAAnC,EAA4D;AACxDH,IAAAA,IAAI,CAACI,IAAL,CAAUH,OAAV;AACA;AACH;;AACD,MAAIM,QAAQ,GAAG,CAAf;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,IAAI,CAACG,MAAzB,EAAiCK,CAAC,EAAlC,EAAsC;AAClC,QAAIH,eAAe,GAAGH,YAAY,CAACF,IAAI,CAACQ,CAAD,CAAL,CAAlC,EAA6C;AACzCD,MAAAA,QAAQ,GAAGC,CAAX;AACA;AACH;AACJ;;AACDR,EAAAA,IAAI,CAACS,MAAL,CAAYF,QAAZ,EAAsB,CAAtB,EAAyBN,OAAzB;AACH;AACD;;;;AAGA,WAAaS,QAAb,GACI,kBAAYC,eAAZ,EAA6BC,MAA7B,EAAqCC,MAArC,EAA6CC,QAA7C,EAAuDC,QAAvD,EAAiEC,OAAjE,EAA0EC,OAA1E,EAAmF;AAAA;;AAAA;;AAC/E;;;;;AAKA,OAAKC,iBAAL,GAAyB,YAAM;AAC3B,QAAI,KAAI,CAACC,QAAL,KAAkB,CAAlB,IAAuB,KAAI,CAACC,UAAL,KAAoB,CAA3C,IAAgD,KAAI,CAACC,SAAL,KAAmB,CAAvE,EAA0E;AACtE;AACA,aAAO,CAAC,KAAD,EAAO,IAAP,CAAP;AACH;;AACD,QAAIC,OAAJ;;AACA,KAAC,UAAUA,OAAV,EAAmB;AAChBA,MAAAA,OAAO,CAACA,OAAO,CAAC,KAAD,CAAP,GAAiB,CAAlB,CAAP,GAA8B,KAA9B;AACAA,MAAAA,OAAO,CAACA,OAAO,CAAC,OAAD,CAAP,GAAmB,CAApB,CAAP,GAAgC,OAAhC;AACAA,MAAAA,OAAO,CAACA,OAAO,CAAC,MAAD,CAAP,GAAkB,CAAnB,CAAP,GAA+B,MAA/B;AACH,KAJD,EAIGA,OAAO,KAAKA,OAAO,GAAG,EAAf,CAJV;;AAKA,QAAIC,IAAJ;AACA,QAAIC,SAAJ;;AACA,QAAI,KAAI,CAACL,QAAL,IAAiB,KAAI,CAACC,UAAtB,IAAoC,KAAI,CAACD,QAAL,IAAiB,KAAI,CAACE,SAA9D,EAAyE;AACrEE,MAAAA,IAAI,GAAGD,OAAO,CAACG,GAAf;AACAD,MAAAA,SAAS,GAAG,KAAI,CAACL,QAAjB;AACH,KAHD,MAIK,IAAI,KAAI,CAACC,UAAL,IAAmB,KAAI,CAACD,QAAxB,IACL,KAAI,CAACC,UAAL,IAAmB,KAAI,CAACC,SADvB,EACkC;AACnCE,MAAAA,IAAI,GAAGD,OAAO,CAACI,KAAf;AACAF,MAAAA,SAAS,GAAG,KAAI,CAACJ,UAAjB;AACH,KAJI,MAKA;AACDG,MAAAA,IAAI,GAAGD,OAAO,CAACK,IAAf;AACAH,MAAAA,SAAS,GAAG,KAAI,CAACH,SAAjB;AACH;;AACD,QAAMO,UAAU,GAAG,IAAIC,KAAJ,CAAUL,SAAV,CAAnB;AACA,QAAMM,YAAY,GAAG,IAAID,KAAJ,CAAUL,SAAV,CAArB;AACA,QAAIO,OAAO,GAAG,IAAd;AACA,QAAIC,QAAQ,GAAG,IAAf;AACA,QAAIC,SAAS,GAAG,CAAhB,CA9B2B,CA+B3B;AACA;AACA;;AACA,QAAIV,IAAI,KAAKD,OAAO,CAACG,GAArB,EAA0B;AACtB;AACA,WAAK,IAAIS,CAAC,GAAG,KAAI,CAACtB,MAAlB,EAA0BsB,CAAC,IAAI,KAAI,CAACrB,MAApC,EAA4CqB,CAAC,EAA7C,EAAiD;AAC7C,YAAIC,GAAG,GAAG,CAAV;;AACA,aAAK,IAAIC,CAAC,GAAG,KAAI,CAACtB,QAAlB,EAA4BsB,CAAC,IAAI,KAAI,CAACrB,QAAtC,EAAgDqB,CAAC,EAAjD,EAAqD;AACjD,eAAK,IAAIC,CAAC,GAAG,KAAI,CAACrB,OAAlB,EAA2BqB,CAAC,IAAI,KAAI,CAACpB,OAArC,EAA8CoB,CAAC,EAA/C,EAAmD;AAC/CF,YAAAA,GAAG,IAAI,KAAI,CAACxB,eAAL,CAAqB2B,iBAArB,CAAuCJ,CAAvC,EAA0CE,CAA1C,EAA6CC,CAA7C,CAAP;AACH;AACJ;;AACDJ,QAAAA,SAAS,IAAIE,GAAb;AACAP,QAAAA,UAAU,CAACM,CAAC,GAAG,KAAI,CAACtB,MAAV,CAAV,GAA8BqB,SAA9B;AACH;;AACD,WAAK,IAAIzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoB,UAAU,CAACzB,MAA/B,EAAuCK,CAAC,EAAxC,EAA4C;AACxCsB,QAAAA,YAAY,CAACtB,CAAD,CAAZ,GAAkByB,SAAS,GAAGL,UAAU,CAACpB,CAAD,CAAxC;AACH,OAdqB,CAetB;;;AACA,WAAK,IAAI0B,EAAC,GAAG,KAAI,CAACtB,MAAlB,EAA0BsB,EAAC,IAAI,KAAI,CAACrB,MAApC,EAA4CqB,EAAC,EAA7C,EAAiD;AAC7C,YAAIN,UAAU,CAACM,EAAC,GAAG,KAAI,CAACtB,MAAV,CAAV,IAA+BqB,SAAS,GAAG,CAA/C,EAAkD;AAC9C,cAAMM,IAAI,GAAGL,EAAC,GAAG,KAAI,CAACtB,MAAtB;AACA,cAAM4B,KAAK,GAAG,KAAI,CAAC3B,MAAL,GAAcqB,EAA5B;AACA,cAAIO,GAAG,SAAP;;AACA,cAAIF,IAAI,IAAIC,KAAZ,EAAmB;AACfC,YAAAA,GAAG,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAI,CAAC9B,MAAL,GAAc,CAAvB,EAA0B6B,IAAI,CAACE,KAAL,CAAWV,EAAC,GAAGM,KAAK,GAAG,CAAvB,CAA1B,CAAN;AACH,WAFD,MAGK;AACDC,YAAAA,GAAG,GAAGC,IAAI,CAACG,GAAL,CAAS,KAAI,CAACjC,MAAd,EAAsB8B,IAAI,CAACE,KAAL,CAAWV,EAAC,GAAG,CAAJ,GAAQK,IAAI,GAAG,CAA1B,CAAtB,CAAN;AACH,WAT6C,CAU9C;;;AACA,iBAAOX,UAAU,CAACa,GAAG,GAAG,KAAI,CAAC7B,MAAZ,CAAV,IAAiC,CAAjC,IAAsC6B,GAAG,GAAG,KAAI,CAAC5B,MAAL,GAAc,CAAjE,EAAoE;AAChE4B,YAAAA,GAAG;AACN;;AACD,cAAIK,SAAS,GAAGhB,YAAY,CAACW,GAAG,GAAG,KAAI,CAAC7B,MAAZ,CAA5B;;AACA,iBAAOkC,SAAS,KAAK,CAAd,IACHL,GAAG,GAAG,KAAI,CAAC7B,MADR,IAEHgB,UAAU,CAACa,GAAG,GAAG,KAAI,CAAC7B,MAAX,GAAoB,CAArB,CAAV,KAAsC,CAF1C,EAE6C;AACzC6B,YAAAA,GAAG;AACHK,YAAAA,SAAS,GAAGhB,YAAY,CAACW,GAAG,GAAG,KAAI,CAAC7B,MAAZ,CAAxB;AACH;;AACDmB,UAAAA,OAAO,GAAG,IAAIrB,QAAJ,CAAa,KAAI,CAACC,eAAlB,EAAmC,KAAI,CAACC,MAAxC,EAAgD6B,GAAhD,EAAqD,KAAI,CAAC3B,QAA1D,EAAoE,KAAI,CAACC,QAAzE,EAAmF,KAAI,CAACC,OAAxF,EAAiG,KAAI,CAACC,OAAtG,CAAV;AACAe,UAAAA,QAAQ,GAAG,IAAItB,QAAJ,CAAa,KAAI,CAACC,eAAlB,EAAmC8B,GAAG,GAAG,CAAzC,EAA4C,KAAI,CAAC5B,MAAjD,EAAyD,KAAI,CAACC,QAA9D,EAAwE,KAAI,CAACC,QAA7E,EAAuF,KAAI,CAACC,OAA5F,EAAqG,KAAI,CAACC,OAA1G,CAAX;AACA;AACH;AACJ;AACJ,KA3CD,MA4CK,IAAIM,IAAI,KAAKD,OAAO,CAACI,KAArB,EAA4B;AAC7B;AACA,WAAK,IAAIU,EAAC,GAAG,KAAI,CAACtB,QAAlB,EAA4BsB,EAAC,IAAI,KAAI,CAACrB,QAAtC,EAAgDqB,EAAC,EAAjD,EAAqD;AACjD,YAAID,IAAG,GAAG,CAAV;;AACA,aAAK,IAAID,GAAC,GAAG,KAAI,CAACtB,MAAlB,EAA0BsB,GAAC,IAAI,KAAI,CAACrB,MAApC,EAA4CqB,GAAC,EAA7C,EAAiD;AAC7C,eAAK,IAAIG,EAAC,GAAG,KAAI,CAACrB,OAAlB,EAA2BqB,EAAC,IAAI,KAAI,CAACpB,OAArC,EAA8CoB,EAAC,EAA/C,EAAmD;AAC/CF,YAAAA,IAAG,IAAI,KAAI,CAACxB,eAAL,CAAqB2B,iBAArB,CAAuCJ,GAAvC,EAA0CE,EAA1C,EAA6CC,EAA7C,CAAP;AACH;AACJ;;AACDJ,QAAAA,SAAS,IAAIE,IAAb;AACAP,QAAAA,UAAU,CAACQ,EAAC,GAAG,KAAI,CAACtB,QAAV,CAAV,GAAgCmB,SAAhC;AACH;;AACD,WAAK,IAAIzB,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGoB,UAAU,CAACzB,MAA/B,EAAuCK,EAAC,EAAxC,EAA4C;AACxCsB,QAAAA,YAAY,CAACtB,EAAD,CAAZ,GAAkByB,SAAS,GAAGL,UAAU,CAACpB,EAAD,CAAxC;AACH,OAd4B,CAe7B;;;AACA,WAAK,IAAI4B,GAAC,GAAG,KAAI,CAACtB,QAAlB,EAA4BsB,GAAC,IAAI,KAAI,CAACrB,QAAtC,EAAgDqB,GAAC,EAAjD,EAAqD;AACjD,YAAIR,UAAU,CAACQ,GAAC,GAAG,KAAI,CAACtB,QAAV,CAAV,IAAiCmB,SAAS,GAAG,CAAjD,EAAoD;AAChD,cAAMM,KAAI,GAAGH,GAAC,GAAG,KAAI,CAACtB,QAAtB;;AACA,cAAM0B,MAAK,GAAG,KAAI,CAACzB,QAAL,GAAgBqB,GAA9B;;AACA,cAAIK,IAAG,SAAP;;AACA,cAAIF,KAAI,IAAIC,MAAZ,EAAmB;AACfC,YAAAA,IAAG,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAI,CAAC5B,QAAL,GAAgB,CAAzB,EAA4B2B,IAAI,CAACE,KAAL,CAAWR,GAAC,GAAGI,MAAK,GAAG,CAAvB,CAA5B,CAAN;AACH,WAFD,MAGK;AACDC,YAAAA,IAAG,GAAGC,IAAI,CAACG,GAAL,CAAS,KAAI,CAAC/B,QAAd,EAAwB4B,IAAI,CAACE,KAAL,CAAWR,GAAC,GAAG,CAAJ,GAAQG,KAAI,GAAG,CAA1B,CAAxB,CAAN;AACH,WAT+C,CAUhD;;;AACA,iBAAOX,UAAU,CAACa,IAAG,GAAG,KAAI,CAAC3B,QAAZ,CAAV,IAAmC,CAAnC,IACH2B,IAAG,GAAG,KAAI,CAAC1B,QAAL,GAAgB,CAD1B,EAC6B;AACzB0B,YAAAA,IAAG;AACN;;AACD,cAAIK,UAAS,GAAGhB,YAAY,CAACW,IAAG,GAAG,KAAI,CAAC3B,QAAZ,CAA5B;;AACA,iBAAOgC,UAAS,KAAK,CAAd,IACHL,IAAG,GAAG,KAAI,CAAC3B,QADR,IAEHc,UAAU,CAACa,IAAG,GAAG,KAAI,CAAC3B,QAAX,GAAsB,CAAvB,CAAV,KAAwC,CAF5C,EAE+C;AAC3C2B,YAAAA,IAAG;AACHK,YAAAA,UAAS,GAAGhB,YAAY,CAACW,IAAG,GAAG,KAAI,CAAC3B,QAAZ,CAAxB;AACH;;AACDiB,UAAAA,OAAO,GAAG,IAAIrB,QAAJ,CAAa,KAAI,CAACC,eAAlB,EAAmC,KAAI,CAACC,MAAxC,EAAgD,KAAI,CAACC,MAArD,EAA6D,KAAI,CAACC,QAAlE,EAA4E2B,IAA5E,EAAiF,KAAI,CAACzB,OAAtF,EAA+F,KAAI,CAACC,OAApG,CAAV;AACAe,UAAAA,QAAQ,GAAG,IAAItB,QAAJ,CAAa,KAAI,CAACC,eAAlB,EAAmC,KAAI,CAACC,MAAxC,EAAgD,KAAI,CAACC,MAArD,EAA6D4B,IAAG,GAAG,CAAnE,EAAsE,KAAI,CAAC1B,QAA3E,EAAqF,KAAI,CAACC,OAA1F,EAAmG,KAAI,CAACC,OAAxG,CAAX;AACA;AACH;AACJ;AACJ,KA5CI,MA6CA;AACD;AACA,WAAK,IAAIoB,GAAC,GAAG,KAAI,CAACrB,OAAlB,EAA2BqB,GAAC,IAAI,KAAI,CAACpB,OAArC,EAA8CoB,GAAC,EAA/C,EAAmD;AAC/C,YAAIF,KAAG,GAAG,CAAV;;AACA,aAAK,IAAID,GAAC,GAAG,KAAI,CAACtB,MAAlB,EAA0BsB,GAAC,IAAI,KAAI,CAACrB,MAApC,EAA4CqB,GAAC,EAA7C,EAAiD;AAC7C,eAAK,IAAIE,GAAC,GAAG,KAAI,CAACtB,QAAlB,EAA4BsB,GAAC,IAAI,KAAI,CAACrB,QAAtC,EAAgDqB,GAAC,EAAjD,EAAqD;AACjDD,YAAAA,KAAG,IAAI,KAAI,CAACxB,eAAL,CAAqB2B,iBAArB,CAAuCJ,GAAvC,EAA0CE,GAA1C,EAA6CC,GAA7C,CAAP;AACH;AACJ;;AACDJ,QAAAA,SAAS,IAAIE,KAAb;AACAP,QAAAA,UAAU,CAACS,GAAC,GAAG,KAAI,CAACrB,OAAV,CAAV,GAA+BiB,SAA/B;AACH;;AACD,WAAK,IAAIzB,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGoB,UAAU,CAACzB,MAA/B,EAAuCK,GAAC,EAAxC,EAA4C;AACxCsB,QAAAA,YAAY,CAACtB,GAAD,CAAZ,GAAkByB,SAAS,GAAGL,UAAU,CAACpB,GAAD,CAAxC;AACH,OAdA,CAeD;;;AACA,WAAK,IAAI6B,GAAC,GAAG,KAAI,CAACrB,OAAlB,EAA2BqB,GAAC,IAAI,KAAI,CAACpB,OAArC,EAA8CoB,GAAC,EAA/C,EAAmD;AAC/C,YAAIT,UAAU,CAACS,GAAC,GAAG,KAAI,CAACrB,OAAV,CAAV,IAAgCiB,SAAS,GAAG,CAAhD,EAAmD;AAC/C,cAAMM,MAAI,GAAGF,GAAC,GAAG,KAAI,CAACrB,OAAtB;;AACA,cAAMwB,OAAK,GAAG,KAAI,CAACvB,OAAL,GAAeoB,GAA7B;;AACA,cAAII,KAAG,SAAP;;AACA,cAAIF,MAAI,IAAIC,OAAZ,EAAmB;AACfC,YAAAA,KAAG,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAI,CAAC1B,OAAL,GAAe,CAAxB,EAA2ByB,IAAI,CAACE,KAAL,CAAWP,GAAC,GAAGG,OAAK,GAAG,CAAvB,CAA3B,CAAN;AACH,WAFD,MAGK;AACDC,YAAAA,KAAG,GAAGC,IAAI,CAACG,GAAL,CAAS,KAAI,CAAC7B,OAAd,EAAuB0B,IAAI,CAACE,KAAL,CAAWP,GAAC,GAAG,CAAJ,GAAQE,MAAI,GAAG,CAA1B,CAAvB,CAAN;AACH,WAT8C,CAU/C;;;AACA,iBAAOX,UAAU,CAACa,KAAG,GAAG,KAAI,CAACzB,OAAZ,CAAV,IAAkC,CAAlC,IACHyB,KAAG,GAAG,KAAI,CAACxB,OAAL,GAAe,CADzB,EAC4B;AACxBwB,YAAAA,KAAG;AACN;;AACD,cAAIK,WAAS,GAAGhB,YAAY,CAACW,KAAG,GAAG,KAAI,CAACzB,OAAZ,CAA5B;;AACA,iBAAO8B,WAAS,KAAK,CAAd,IACHL,KAAG,GAAG,KAAI,CAACzB,OADR,IAEHY,UAAU,CAACa,KAAG,GAAG,KAAI,CAACzB,OAAX,GAAqB,CAAtB,CAAV,KAAuC,CAF3C,EAE8C;AAC1CyB,YAAAA,KAAG;AACHK,YAAAA,WAAS,GAAGhB,YAAY,CAACW,KAAG,GAAG,KAAI,CAACzB,OAAZ,CAAxB;AACH;;AACDe,UAAAA,OAAO,GAAG,IAAIrB,QAAJ,CAAa,KAAI,CAACC,eAAlB,EAAmC,KAAI,CAACC,MAAxC,EAAgD,KAAI,CAACC,MAArD,EAA6D,KAAI,CAACC,QAAlE,EAA4E,KAAI,CAACC,QAAjF,EAA2F,KAAI,CAACC,OAAhG,EAAyGyB,KAAzG,CAAV;AACAT,UAAAA,QAAQ,GAAG,IAAItB,QAAJ,CAAa,KAAI,CAACC,eAAlB,EAAmC,KAAI,CAACC,MAAxC,EAAgD,KAAI,CAACC,MAArD,EAA6D,KAAI,CAACC,QAAlE,EAA4E,KAAI,CAACC,QAAjF,EAA2F0B,KAAG,GAAG,CAAjG,EAAoG,KAAI,CAACxB,OAAzG,CAAX;AACA;AACH;AACJ;AACJ;;AACD,WAAO,CAACc,OAAD,EAAUC,QAAV,CAAP;AACH,GAzKD;;AA0KA,OAAKe,UAAL,GAAkB,CAAlB;AACA,OAAKpC,eAAL,GAAuBA,eAAvB;AACA,OAAKC,MAAL,GAAcA,MAAd;AACA,OAAKC,MAAL,GAAcA,MAAd;AACA,OAAKC,QAAL,GAAgBA,QAAhB;AACA,OAAKC,QAAL,GAAgBA,QAAhB;AACA,OAAKC,OAAL,GAAeA,OAAf;AACA,OAAKC,OAAL,GAAeA,OAAf;AACA,OAAKE,QAAL,GAAgB,KAAKN,MAAL,GAAc,KAAKD,MAAnB,GAA4B,CAA5C;AACA,OAAKQ,UAAL,GAAkB,KAAKL,QAAL,GAAgB,KAAKD,QAArB,GAAgC,CAAlD;AACA,OAAKO,SAAL,GAAiB,KAAKJ,OAAL,GAAe,KAAKD,OAApB,GAA8B,CAA/C;AACA,OAAKgC,WAAL,GAAmB,KAAK7B,QAAL,GAAgB,KAAKC,UAArB,GAAkC,KAAKC,SAA1D;AACA,MAAI4B,MAAM,GAAG,CAAb;AACA,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAIC,OAAO,GAAG,CAAd;AACA,MAAMC,MAAM,GAAG,KAAM,IAAI,KAAKzC,eAAL,CAAqB0C,eAA9C;;AACA,OAAK,IAAInB,CAAC,GAAGtB,MAAb,EAAqBsB,CAAC,IAAIrB,MAA1B,EAAkCqB,CAAC,EAAnC,EAAuC;AACnC,SAAK,IAAIE,CAAC,GAAGtB,QAAb,EAAuBsB,CAAC,IAAIrB,QAA5B,EAAsCqB,CAAC,EAAvC,EAA2C;AACvC,WAAK,IAAIC,CAAC,GAAGrB,OAAb,EAAsBqB,CAAC,IAAIpB,OAA3B,EAAoCoB,CAAC,EAArC,EAAyC;AACrC,YAAMiB,UAAU,GAAG,KAAK3C,eAAL,CAAqB2B,iBAArB,CAAuCJ,CAAvC,EAA0CE,CAA1C,EAA6CC,CAA7C,CAAnB;AACA,aAAKU,UAAL,IAAmBO,UAAnB;AACAL,QAAAA,MAAM,IAAIK,UAAU,IAAIpB,CAAC,GAAG,GAAR,CAAV,GAAyBkB,MAAnC;AACAF,QAAAA,QAAQ,IAAII,UAAU,IAAIlB,CAAC,GAAG,GAAR,CAAV,GAAyBgB,MAArC;AACAD,QAAAA,OAAO,IAAIG,UAAU,IAAIjB,CAAC,GAAG,GAAR,CAAV,GAAyBe,MAApC;AACH;AACJ;AACJ;;AACD,MAAI,KAAKL,UAAL,KAAoB,CAAxB,EAA2B;AACvB,SAAKQ,YAAL,GAAoB,IAAIzD,WAAJ,CAAiBsD,MAAM,IAAI,CAACxC,MAAM,GAAGC,MAAT,GAAkB,CAAnB,IAAwB,CAA5B,CAAP,GAAyC,GAAzD,EAA+DuC,MAAM,IAAI,CAACtC,QAAQ,GAAGC,QAAX,GAAsB,CAAvB,IAA4B,CAAhC,CAAP,GAA6C,GAA3G,EAAiHqC,MAAM,IAAI,CAACpC,OAAO,GAAGC,OAAV,GAAoB,CAArB,IAA0B,CAA9B,CAAP,GAA2C,GAA3J,EAAgK,CAAhK,CAApB;AACH,GAFD,MAGK;AACD,SAAKsC,YAAL,GAAoB,IAAIzD,WAAJ,CAAgBmD,MAAM,GAAG,KAAKF,UAAd,GAA2B,GAA3C,EAAgDG,QAAQ,GAAG,KAAKH,UAAhB,GAA6B,GAA7E,EAAkFI,OAAO,GAAG,KAAKJ,UAAf,GAA4B,GAA9G,EAAmH,CAAnH,CAApB;AACH;AACJ,CAlNL","sourcesContent":["// tslint:disable:member-ordering\n// tslint:disable:no-bitwise\n// tslint:disable:prefer-for-of\nimport { ColorRGBA64 } from \"./color-rgba-64\";\n/**\n * Adds a newItem to an already sorted list without needing to do a full re-sort.\n * Higher sort priority puts the newItem closer to the start (index 0) of the list.\n */\nexport function insertIntoSortedList(list, newItem, sortPriority) {\n    if (list.length === 0) {\n        list.push(newItem);\n        return;\n    }\n    const newItemPriority = sortPriority(newItem);\n    // The new item being either first or last happens often enough that it is worth special casing\n    // In cases of a tie the new item should be inserted after existing items of the same priority\n    if (newItemPriority > sortPriority(list[0])) {\n        list.unshift(newItem);\n        return;\n    }\n    if (newItemPriority <= sortPriority(list[list.length - 1])) {\n        list.push(newItem);\n        return;\n    }\n    let newIndex = 0;\n    for (let i = 0; i < list.length; i++) {\n        if (newItemPriority > sortPriority(list[i])) {\n            newIndex = i;\n            break;\n        }\n    }\n    list.splice(newIndex, 0, newItem);\n}\n/**\n * Represents a range of colors in RGB color space.\n */\nexport class PixelBox {\n    constructor(globalHistogram, minRed, maxRed, minGreen, maxGreen, minBlue, maxBlue) {\n        /**\n         * Attempts to divide the range of colors represented by this PixelBox into two smaller PixelBox objects.\n         * This does not actually cut directly at the median, rather it finds the median then cuts halfway through the larger box on either side of that median. The result is that small areas of color are better represented in the final output.\n         * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c\n         */\n        this.modifiedMedianCut = () => {\n            if (this.rangeRed === 1 && this.rangeGreen === 1 && this.rangeBlue === 1) {\n                // This box is already sliced as finely as possible\n                return [this, null];\n            }\n            let CutAxis;\n            (function (CutAxis) {\n                CutAxis[CutAxis[\"Red\"] = 0] = \"Red\";\n                CutAxis[CutAxis[\"Green\"] = 1] = \"Green\";\n                CutAxis[CutAxis[\"Blue\"] = 2] = \"Blue\";\n            })(CutAxis || (CutAxis = {}));\n            let axis;\n            let axisRange;\n            if (this.rangeRed >= this.rangeGreen && this.rangeRed >= this.rangeBlue) {\n                axis = CutAxis.Red;\n                axisRange = this.rangeRed;\n            }\n            else if (this.rangeGreen >= this.rangeRed &&\n                this.rangeGreen >= this.rangeBlue) {\n                axis = CutAxis.Green;\n                axisRange = this.rangeGreen;\n            }\n            else {\n                axis = CutAxis.Blue;\n                axisRange = this.rangeBlue;\n            }\n            const partialSum = new Array(axisRange);\n            const lookAheadSum = new Array(axisRange);\n            let retLeft = null;\n            let retRight = null;\n            let axisTotal = 0;\n            // This does not actually cut directly at the median, rather it finds the median then\n            // cuts halfway through the larger box on either side of that median\n            // The result is that small areas of color are better represented in the final output\n            if (axis === CutAxis.Red) {\n                // Calculate partial sums\n                for (let r = this.minRed; r <= this.maxRed; r++) {\n                    let sum = 0;\n                    for (let g = this.minGreen; g <= this.maxGreen; g++) {\n                        for (let b = this.minBlue; b <= this.maxBlue; b++) {\n                            sum += this.globalHistogram.getHistogramValue(r, g, b);\n                        }\n                    }\n                    axisTotal += sum;\n                    partialSum[r - this.minRed] = axisTotal;\n                }\n                for (let i = 0; i < partialSum.length; i++) {\n                    lookAheadSum[i] = axisTotal - partialSum[i];\n                }\n                // Find the cut point based on partial sums vs total\n                for (let r = this.minRed; r <= this.maxRed; r++) {\n                    if (partialSum[r - this.minRed] >= axisTotal / 2) {\n                        const left = r - this.minRed;\n                        const right = this.maxRed - r;\n                        let cut;\n                        if (left <= right) {\n                            cut = Math.min(this.maxRed - 1, Math.floor(r + right / 2));\n                        }\n                        else {\n                            cut = Math.max(this.minRed, Math.floor(r - 1 - left / 2));\n                        }\n                        // Adjust the cut point if either side has 0 pixelCount\n                        while (partialSum[cut - this.minRed] <= 0 && cut < this.maxRed - 1) {\n                            cut++;\n                        }\n                        let lookAhead = lookAheadSum[cut - this.minRed];\n                        while (lookAhead === 0 &&\n                            cut > this.minRed &&\n                            partialSum[cut - this.minRed - 1] !== 0) {\n                            cut--;\n                            lookAhead = lookAheadSum[cut - this.minRed];\n                        }\n                        retLeft = new PixelBox(this.globalHistogram, this.minRed, cut, this.minGreen, this.maxGreen, this.minBlue, this.maxBlue);\n                        retRight = new PixelBox(this.globalHistogram, cut + 1, this.maxRed, this.minGreen, this.maxGreen, this.minBlue, this.maxBlue);\n                        break;\n                    }\n                }\n            }\n            else if (axis === CutAxis.Green) {\n                // Calculate partial sums\n                for (let g = this.minGreen; g <= this.maxGreen; g++) {\n                    let sum = 0;\n                    for (let r = this.minRed; r <= this.maxRed; r++) {\n                        for (let b = this.minBlue; b <= this.maxBlue; b++) {\n                            sum += this.globalHistogram.getHistogramValue(r, g, b);\n                        }\n                    }\n                    axisTotal += sum;\n                    partialSum[g - this.minGreen] = axisTotal;\n                }\n                for (let i = 0; i < partialSum.length; i++) {\n                    lookAheadSum[i] = axisTotal - partialSum[i];\n                }\n                // Find the cut point based on partial sums vs total\n                for (let g = this.minGreen; g <= this.maxGreen; g++) {\n                    if (partialSum[g - this.minGreen] >= axisTotal / 2) {\n                        const left = g - this.minGreen;\n                        const right = this.maxGreen - g;\n                        let cut;\n                        if (left <= right) {\n                            cut = Math.min(this.maxGreen - 1, Math.floor(g + right / 2));\n                        }\n                        else {\n                            cut = Math.max(this.minGreen, Math.floor(g - 1 - left / 2));\n                        }\n                        // Adjust the cut point if either side has 0 pixelCount\n                        while (partialSum[cut - this.minGreen] <= 0 &&\n                            cut < this.maxGreen - 1) {\n                            cut++;\n                        }\n                        let lookAhead = lookAheadSum[cut - this.minGreen];\n                        while (lookAhead === 0 &&\n                            cut > this.minGreen &&\n                            partialSum[cut - this.minGreen - 1] !== 0) {\n                            cut--;\n                            lookAhead = lookAheadSum[cut - this.minGreen];\n                        }\n                        retLeft = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, this.minGreen, cut, this.minBlue, this.maxBlue);\n                        retRight = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, cut + 1, this.maxGreen, this.minBlue, this.maxBlue);\n                        break;\n                    }\n                }\n            }\n            else {\n                // Calculate partial sums\n                for (let b = this.minBlue; b <= this.maxBlue; b++) {\n                    let sum = 0;\n                    for (let r = this.minRed; r <= this.maxRed; r++) {\n                        for (let g = this.minGreen; g <= this.maxGreen; g++) {\n                            sum += this.globalHistogram.getHistogramValue(r, g, b);\n                        }\n                    }\n                    axisTotal += sum;\n                    partialSum[b - this.minBlue] = axisTotal;\n                }\n                for (let i = 0; i < partialSum.length; i++) {\n                    lookAheadSum[i] = axisTotal - partialSum[i];\n                }\n                // Find the cut point based on partial sums vs total\n                for (let b = this.minBlue; b <= this.maxBlue; b++) {\n                    if (partialSum[b - this.minBlue] >= axisTotal / 2) {\n                        const left = b - this.minBlue;\n                        const right = this.maxBlue - b;\n                        let cut;\n                        if (left <= right) {\n                            cut = Math.min(this.maxBlue - 1, Math.floor(b + right / 2));\n                        }\n                        else {\n                            cut = Math.max(this.minBlue, Math.floor(b - 1 - left / 2));\n                        }\n                        // Adjust the cut point if either side has 0 pixelCount\n                        while (partialSum[cut - this.minBlue] <= 0 &&\n                            cut < this.maxBlue - 1) {\n                            cut++;\n                        }\n                        let lookAhead = lookAheadSum[cut - this.minBlue];\n                        while (lookAhead === 0 &&\n                            cut > this.minBlue &&\n                            partialSum[cut - this.minBlue - 1] !== 0) {\n                            cut--;\n                            lookAhead = lookAheadSum[cut - this.minBlue];\n                        }\n                        retLeft = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, this.minGreen, this.maxGreen, this.minBlue, cut);\n                        retRight = new PixelBox(this.globalHistogram, this.minRed, this.maxRed, this.minGreen, this.maxGreen, cut + 1, this.maxBlue);\n                        break;\n                    }\n                }\n            }\n            return [retLeft, retRight];\n        };\n        this.pixelCount = 0;\n        this.globalHistogram = globalHistogram;\n        this.minRed = minRed;\n        this.maxRed = maxRed;\n        this.minGreen = minGreen;\n        this.maxGreen = maxGreen;\n        this.minBlue = minBlue;\n        this.maxBlue = maxBlue;\n        this.rangeRed = this.maxRed - this.minRed + 1;\n        this.rangeGreen = this.maxGreen - this.minGreen + 1;\n        this.rangeBlue = this.maxBlue - this.minBlue + 1;\n        this.colorVolume = this.rangeRed * this.rangeGreen * this.rangeBlue;\n        let redSum = 0;\n        let greenSum = 0;\n        let blueSum = 0;\n        const factor = 1 << (8 - this.globalHistogram.significantBits);\n        for (let r = minRed; r <= maxRed; r++) {\n            for (let g = minGreen; g <= maxGreen; g++) {\n                for (let b = minBlue; b <= maxBlue; b++) {\n                    const histoValue = this.globalHistogram.getHistogramValue(r, g, b);\n                    this.pixelCount += histoValue;\n                    redSum += histoValue * (r + 0.5) * factor;\n                    greenSum += histoValue * (g + 0.5) * factor;\n                    blueSum += histoValue * (b + 0.5) * factor;\n                }\n            }\n        }\n        if (this.pixelCount === 0) {\n            this.averageColor = new ColorRGBA64((factor * ((minRed + maxRed + 1) / 2)) / 255, (factor * ((minGreen + maxGreen + 1) / 2)) / 255, (factor * ((minBlue + maxBlue + 1) / 2)) / 255, 1);\n        }\n        else {\n            this.averageColor = new ColorRGBA64(redSum / this.pixelCount / 255, greenSum / this.pixelCount / 255, blueSum / this.pixelCount / 255, 1);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}