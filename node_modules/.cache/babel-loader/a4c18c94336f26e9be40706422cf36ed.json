{"ast":null,"code":"import Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isNil } from \"lodash-es\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { DisplayNamePrefix } from \"../utilities\";\nimport { AxisPositioningMode, ViewportPositionerHorizontalPosition, ViewportPositionerVerticalPosition } from \"./viewport-positioner.props\";\nimport { ViewportContext } from \"./viewport-context\";\nexport var ViewportPositionerHorizontalPositionLabel;\n\n(function (ViewportPositionerHorizontalPositionLabel) {\n  ViewportPositionerHorizontalPositionLabel[\"left\"] = \"left\";\n  ViewportPositionerHorizontalPositionLabel[\"insetLeft\"] = \"insetLeft\";\n  ViewportPositionerHorizontalPositionLabel[\"insetRight\"] = \"insetRight\";\n  ViewportPositionerHorizontalPositionLabel[\"right\"] = \"right\";\n  ViewportPositionerHorizontalPositionLabel[\"undefined\"] = \"undefined\";\n})(ViewportPositionerHorizontalPositionLabel || (ViewportPositionerHorizontalPositionLabel = {}));\n\nexport var ViewportPositionerVerticalPositionLabel;\n\n(function (ViewportPositionerVerticalPositionLabel) {\n  ViewportPositionerVerticalPositionLabel[\"top\"] = \"top\";\n  ViewportPositionerVerticalPositionLabel[\"insetTop\"] = \"insetTop\";\n  ViewportPositionerVerticalPositionLabel[\"insetBottom\"] = \"insetBottom\";\n  ViewportPositionerVerticalPositionLabel[\"bottom\"] = \"bottom\";\n  ViewportPositionerVerticalPositionLabel[\"undefined\"] = \"undefined\";\n})(ViewportPositionerVerticalPositionLabel || (ViewportPositionerVerticalPositionLabel = {}));\n\nclass ViewportPositioner extends Foundation {\n  /**\n   * constructor\n   */\n  constructor(props) {\n    super(props);\n    this.handledProps = {\n      managedClasses: void 0,\n      anchor: void 0,\n      viewport: void 0,\n      horizontalPositioningMode: void 0,\n      defaultHorizontalPosition: void 0,\n      horizontalThreshold: void 0,\n      horizontalAlwaysInView: void 0,\n      horizontalLockToDefault: void 0,\n      verticalPositioningMode: void 0,\n      defaultVerticalPosition: void 0,\n      verticalThreshold: void 0,\n      verticalAlwaysInView: void 0,\n      verticalLockToDefault: void 0,\n      fixedAfterInitialPlacement: void 0,\n      scaleToFit: void 0,\n      disabled: void 0\n    };\n    this.rootElement = React.createRef();\n    this.openRequestAnimationFrame = null;\n    this.anchorTop = 0;\n    this.anchorRight = 0;\n    this.anchorBottom = 0;\n    this.anchorLeft = 0;\n    this.anchorHeight = 0;\n    this.anchorWidth = 0;\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n    /**\n     * base offsets between the positioner's base position and the anchor's\n     */\n\n    this.baseHorizontalOffset = 0;\n    this.baseVerticalOffset = 0;\n    /**\n     *  gets the CSS classes to be programmatically applied to the component\n     */\n\n    this.getPositioningStyles = () => {\n      // Check if there is already a style object being passed as props\n      const styleProps = get(this.props, \"style\");\n      return Object.assign({}, this.props.scaleToFit ? {\n        height: `${this.state.verticalSelectedPositionHeight}px`,\n        width: `${this.state.horizontalSelectedPositionWidth}px`\n      } : {}, {\n        // hide the component until afer initial layout attempst (to avoid a flicker)\n        opacity: !this.props.disabled && !this.state.initialLayoutComplete ? 0 : undefined,\n        position: \"relative\",\n        transformOrigin: `${this.state.xTransformOrigin} ${this.state.yTransformOrigin}`,\n        transform: `translate(\n                ${Math.floor(this.state.xTranslate)}px, \n                ${Math.floor(this.state.yTranslate)}px\n            )`,\n        top: this.state.top === null ? null : `${this.state.top}px`,\n        right: this.state.right === null ? null : `${this.state.right}px`,\n        bottom: this.state.bottom === null ? null : `${this.state.bottom}px`,\n        left: this.state.left === null ? null : `${this.state.left}px`\n      }, styleProps);\n    };\n    /**\n     *  Checks whether component should be disabled or not\n     */\n\n\n    this.updateDisabledState = () => {\n      if (!canUseDOM() || this.props.disabled === true) {\n        this.disable();\n        return;\n      }\n\n      if (this.getAnchorElement() === null || this.getViewportElement(this.props.viewport) === null) {\n        if (this.state.validRefChecksRemaining > 0) {\n          this.setState({\n            validRefChecksRemaining: this.state.validRefChecksRemaining - 1,\n            initialLayoutComplete: this.state.validRefChecksRemaining <= 1\n          });\n          return;\n        }\n      }\n\n      this.enableComponent();\n    };\n    /**\n     *  Enable the component\n     */\n\n\n    this.enableComponent = () => {\n      const viewportElement = this.getViewportElement(this.props.viewport);\n      const anchorElement = this.getAnchorElement();\n\n      if (!this.state.disabled || this.props.disabled || isNil(anchorElement) || isNil(viewportElement) || isNil(this.rootElement.current)) {\n        return;\n      }\n\n      if (!window.IntersectionObserver || !window.ResizeObserver) {\n        this.setNoObserverMode();\n        return;\n      }\n\n      this.setState({\n        disabled: false,\n        noObserverMode: false,\n        validRefChecksRemaining: 0\n      });\n      this.collisionDetector = new window.IntersectionObserver(this.handleCollision, {\n        root: viewportElement,\n        rootMargin: \"0px\",\n        threshold: [0, 1]\n      });\n      this.collisionDetector.observe(this.rootElement.current);\n      this.collisionDetector.observe(anchorElement);\n      this.resizeDetector = new window.ResizeObserver(this.handleAnchorResize);\n      this.resizeDetector.observe(anchorElement);\n      viewportElement.addEventListener(\"scroll\", this.handleScroll);\n    };\n    /**\n     *  If observers are not supported we do expensive getBoundingClientRect calls\n     *  once to get correct initial placement\n     */\n\n\n    this.setNoObserverMode = () => {\n      const viewportElement = this.getViewportElement(this.props.viewport);\n      const anchorElement = this.getAnchorElement();\n\n      if (isNil(viewportElement) || isNil(anchorElement)) {\n        return;\n      }\n\n      this.positionerRect = this.rootElement.current.getBoundingClientRect();\n      this.viewportRect = viewportElement.getBoundingClientRect();\n      const anchorRect = anchorElement.getBoundingClientRect();\n      this.anchorTop = anchorRect.top;\n      this.anchorRight = anchorRect.right;\n      this.anchorBottom = anchorRect.bottom;\n      this.anchorLeft = anchorRect.left;\n      this.anchorWidth = anchorRect.width;\n      this.anchorHeight = anchorRect.height;\n      this.updatePositionerOffset();\n      this.setState({\n        validRefChecksRemaining: 0,\n        disabled: false,\n        noObserverMode: true\n      });\n      this.requestFrame();\n    };\n    /**\n     *  Disable the component\n     */\n\n\n    this.disable = () => {\n      if (this.state.disabled) {\n        return;\n      }\n\n      this.detachListeners(this.props.viewport);\n      this.setState({\n        disabled: true,\n        validRefChecksRemaining: 0\n      });\n    };\n    /**\n     *  removes event listeners and observers when component is being unmounted or reset\n     */\n\n\n    this.detachListeners = viewportRef => {\n      const viewPortElement = this.getViewportElement(viewportRef);\n\n      if (!isNil(viewPortElement)) {\n        viewPortElement.removeEventListener(\"scroll\", this.handleScroll);\n      }\n\n      if (this.collisionDetector && typeof this.collisionDetector.disconnect === \"function\") {\n        this.collisionDetector.disconnect();\n        this.collisionDetector = null;\n      } // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142\n      // Full browser support imminent\n      // Revisit usage once Safari and Firefox adapt\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409\n      // https://bugs.webkit.org/show_bug.cgi?id=157743\n\n\n      if (this.resizeDetector && typeof this.resizeDetector.disconnect === \"function\") {\n        this.resizeDetector.disconnect();\n        this.resizeDetector = null;\n      }\n    };\n    /**\n     *  Get available Horizontal positions based on positioning mode\n     */\n\n\n    this.getHorizontalPositioningOptions = () => {\n      switch (this.props.horizontalPositioningMode) {\n        case AxisPositioningMode.inset:\n          return [ViewportPositionerHorizontalPositionLabel.insetLeft, ViewportPositionerHorizontalPositionLabel.insetRight];\n\n        case AxisPositioningMode.adjacent:\n          return [ViewportPositionerHorizontalPositionLabel.left, ViewportPositionerHorizontalPositionLabel.right];\n      }\n    };\n    /**\n     * Get available Vertical positions based on positioning mode\n     */\n\n\n    this.getVerticalPositioningOptions = () => {\n      switch (this.props.verticalPositioningMode) {\n        case AxisPositioningMode.inset:\n          return [ViewportPositionerVerticalPositionLabel.insetTop, ViewportPositionerVerticalPositionLabel.insetBottom];\n\n        case AxisPositioningMode.adjacent:\n          return [ViewportPositionerVerticalPositionLabel.top, ViewportPositionerVerticalPositionLabel.bottom];\n      }\n    };\n    /**\n     *  Get the width available for a particular horizontal position\n     */\n\n\n    this.getAvailableWidth = positionOption => {\n      const spaceLeft = this.anchorLeft - this.viewportRect.left;\n      const spaceRight = this.viewportRect.right - (this.anchorLeft + this.anchorWidth);\n\n      switch (positionOption) {\n        case ViewportPositionerHorizontalPositionLabel.left:\n          return spaceLeft;\n\n        case ViewportPositionerHorizontalPositionLabel.insetLeft:\n          return spaceLeft + this.anchorWidth;\n\n        case ViewportPositionerHorizontalPositionLabel.insetRight:\n          return spaceRight + this.anchorWidth;\n\n        case ViewportPositionerHorizontalPositionLabel.right:\n          return spaceRight;\n      }\n    };\n    /**\n     *  Get the height available for a particular vertical position\n     */\n\n\n    this.getAvailableHeight = positionOption => {\n      const spaceAbove = this.anchorTop - this.viewportRect.top;\n      const spaceBelow = this.viewportRect.bottom - (this.anchorTop + this.anchorHeight);\n\n      switch (positionOption) {\n        case ViewportPositionerVerticalPositionLabel.top:\n          return spaceAbove;\n\n        case ViewportPositionerVerticalPositionLabel.insetTop:\n          return spaceAbove + this.anchorHeight;\n\n        case ViewportPositionerVerticalPositionLabel.insetBottom:\n          return spaceBelow + this.anchorHeight;\n\n        case ViewportPositionerVerticalPositionLabel.bottom:\n          return spaceBelow;\n      }\n    };\n    /**\n     *  Handle scroll events\n     */\n\n\n    this.handleScroll = () => {\n      this.requestFrame();\n    };\n    /**\n     *  Handle anchor resize events\n     */\n\n\n    this.handleAnchorResize = entries => {\n      const entry = entries[0];\n      this.anchorHeight = entry.contentRect.height;\n      this.anchorWidth = entry.contentRect.width;\n\n      if (this.state.currentVerticalPosition === ViewportPositionerVerticalPositionLabel.top || this.state.currentVerticalPosition === ViewportPositionerVerticalPositionLabel.insetTop) {\n        this.anchorBottom = this.anchorTop + this.anchorHeight;\n      } else {\n        this.anchorTop = this.anchorBottom - this.anchorHeight;\n      }\n\n      if (this.state.currentHorizontalPosition === ViewportPositionerHorizontalPositionLabel.left || this.state.currentHorizontalPosition === ViewportPositionerHorizontalPositionLabel.insetLeft) {\n        this.anchorRight = this.anchorLeft + this.anchorWidth;\n      } else {\n        this.anchorLeft = this.anchorRight - this.anchorWidth;\n      }\n\n      this.requestFrame();\n    };\n    /**\n     *  Handle collisions\n     */\n\n\n    this.handleCollision = (entries, observer) => {\n      entries.forEach(entry => {\n        if (entry.target === this.rootElement.current) {\n          this.handlePositionerCollision(entry, entries.length === 1);\n        } else {\n          this.handleAnchorCollision(entry);\n        }\n      });\n      const viewPortElement = this.getViewportElement(this.props.viewport);\n\n      if (!isNil(viewPortElement)) {\n        this.scrollTop = viewPortElement.scrollTop;\n        this.scrollLeft = viewPortElement.scrollLeft;\n      }\n\n      if (entries.length === 2) {\n        this.updatePositionerOffset();\n      }\n\n      this.requestFrame();\n    };\n    /**\n     *  Update data based on anchor collisions\n     */\n\n\n    this.handleAnchorCollision = anchorEntry => {\n      this.viewportRect = anchorEntry.rootBounds;\n      this.anchorTop = anchorEntry.boundingClientRect.top;\n      this.anchorRight = anchorEntry.boundingClientRect.right;\n      this.anchorBottom = anchorEntry.boundingClientRect.bottom;\n      this.anchorLeft = anchorEntry.boundingClientRect.left;\n      this.anchorHeight = anchorEntry.boundingClientRect.height;\n      this.anchorWidth = anchorEntry.boundingClientRect.width;\n    };\n    /**\n     *  Update data based on positioner collisions\n     */\n\n\n    this.handlePositionerCollision = (positionerEntry, shouldDeriveAnchorPosition) => {\n      this.viewportRect = positionerEntry.rootBounds;\n      this.positionerRect = positionerEntry.boundingClientRect;\n\n      if (shouldDeriveAnchorPosition) {\n        switch (this.state.currentVerticalPosition) {\n          case ViewportPositionerVerticalPositionLabel.top:\n            this.anchorTop = this.positionerRect.bottom - this.state.yTranslate;\n            this.anchorBottom = this.anchorTop + this.anchorHeight;\n            break;\n\n          case ViewportPositionerVerticalPositionLabel.insetTop:\n            this.anchorBottom = this.positionerRect.bottom - this.state.yTranslate;\n            this.anchorTop = this.anchorBottom - this.anchorHeight;\n            break;\n\n          case ViewportPositionerVerticalPositionLabel.insetBottom:\n            this.anchorTop = this.positionerRect.top - this.state.yTranslate;\n            this.anchorBottom = this.anchorTop + this.anchorHeight;\n            break;\n\n          case ViewportPositionerVerticalPositionLabel.bottom:\n            this.anchorBottom = this.positionerRect.top - this.state.yTranslate;\n            this.anchorTop = this.anchorBottom - this.anchorHeight;\n            break;\n        }\n\n        switch (this.state.currentHorizontalPosition) {\n          case ViewportPositionerHorizontalPositionLabel.left:\n            this.anchorLeft = this.positionerRect.right - this.state.xTranslate;\n            this.anchorRight = this.anchorLeft + this.anchorWidth;\n            break;\n\n          case ViewportPositionerHorizontalPositionLabel.insetLeft:\n            this.anchorRight = this.positionerRect.right - this.state.xTranslate;\n            this.anchorLeft = this.anchorRight - this.anchorWidth;\n            break;\n\n          case ViewportPositionerHorizontalPositionLabel.insetRight:\n            this.anchorLeft = this.positionerRect.left - this.state.xTranslate;\n            this.anchorRight = this.anchorLeft + this.anchorWidth;\n            break;\n\n          case ViewportPositionerHorizontalPositionLabel.right:\n            this.anchorRight = this.positionerRect.left - this.state.xTranslate;\n            this.anchorLeft = this.anchorRight - this.anchorWidth;\n            break;\n        }\n      }\n    };\n    /**\n     *  Update the offset values\n     */\n\n\n    this.updatePositionerOffset = () => {\n      if (this.props.horizontalPositioningMode === AxisPositioningMode.uncontrolled) {\n        this.baseHorizontalOffset = this.anchorLeft - this.positionerRect.left;\n      } else {\n        switch (this.state.currentHorizontalPosition) {\n          case ViewportPositionerHorizontalPositionLabel.undefined:\n            this.baseHorizontalOffset = this.anchorLeft + this.state.xTranslate - this.positionerRect.left;\n            break;\n\n          case ViewportPositionerHorizontalPositionLabel.left:\n            this.baseHorizontalOffset = this.baseHorizontalOffset + (this.anchorLeft + this.state.xTranslate - this.positionerRect.right);\n            break;\n\n          case ViewportPositionerHorizontalPositionLabel.insetLeft:\n            this.baseHorizontalOffset = this.baseHorizontalOffset + (this.anchorRight + this.state.xTranslate - this.positionerRect.right);\n            break;\n\n          case ViewportPositionerHorizontalPositionLabel.insetRight:\n            this.baseHorizontalOffset = this.baseHorizontalOffset + (this.anchorLeft + this.state.xTranslate - this.positionerRect.left);\n            break;\n\n          case ViewportPositionerHorizontalPositionLabel.right:\n            this.baseHorizontalOffset = this.baseHorizontalOffset + (this.anchorRight + this.state.xTranslate - this.positionerRect.left);\n            break;\n        }\n      }\n\n      if (this.props.verticalPositioningMode === AxisPositioningMode.uncontrolled) {\n        this.baseVerticalOffset = this.anchorBottom - this.positionerRect.top;\n      } else {\n        switch (this.state.currentVerticalPosition) {\n          case ViewportPositionerVerticalPositionLabel.undefined:\n            this.baseVerticalOffset = this.anchorBottom + this.state.yTranslate - this.positionerRect.top;\n            break;\n\n          case ViewportPositionerVerticalPositionLabel.top:\n            this.baseVerticalOffset = this.baseVerticalOffset + (this.anchorTop + this.state.yTranslate - this.positionerRect.bottom);\n            break;\n\n          case ViewportPositionerVerticalPositionLabel.insetTop:\n            this.baseVerticalOffset = this.baseVerticalOffset + (this.anchorBottom + this.state.yTranslate - this.positionerRect.bottom);\n            break;\n\n          case ViewportPositionerVerticalPositionLabel.insetBottom:\n            this.baseVerticalOffset = this.baseVerticalOffset + (this.anchorTop + this.state.yTranslate - this.positionerRect.top);\n            break;\n\n          case ViewportPositionerVerticalPositionLabel.bottom:\n            this.baseVerticalOffset = this.baseVerticalOffset + (this.anchorBottom + this.state.yTranslate - this.positionerRect.top);\n            break;\n        }\n      }\n    };\n    /**\n     * Check for scroll changes in viewport and adjust position data\n     */\n\n\n    this.updateForScrolling = () => {\n      const scrollingContainer = this.getViewportElement(this.props.viewport);\n\n      if (isNil(scrollingContainer) || isNaN(scrollingContainer.scrollTop)) {\n        return;\n      }\n\n      const scrollTop = scrollingContainer.scrollTop;\n      const scrollLeft = scrollingContainer.scrollLeft;\n\n      if (this.scrollTop !== scrollTop) {\n        const verticalScrollDelta = this.scrollTop - scrollTop;\n        this.scrollTop = scrollTop;\n        this.anchorTop = this.anchorTop + verticalScrollDelta;\n        this.anchorBottom = this.anchorBottom + verticalScrollDelta;\n      }\n\n      if (this.scrollLeft !== scrollLeft) {\n        const horizontalScrollDelta = this.scrollLeft - scrollLeft;\n        this.scrollLeft = scrollLeft;\n        this.anchorLeft = this.anchorLeft + horizontalScrollDelta;\n        this.anchorRight = this.anchorRight + horizontalScrollDelta;\n      }\n    };\n    /**\n     *  Recalculate layout related state values\n     */\n\n\n    this.updateLayout = () => {\n      this.openRequestAnimationFrame = null;\n\n      if (this.state.disabled || isNil(this.viewportRect) || isNil(this.positionerRect) || this.props.fixedAfterInitialPlacement && this.state.initialLayoutComplete || this.state.noObserverMode && this.state.initialLayoutComplete) {\n        return;\n      }\n\n      this.updateForScrolling();\n      let desiredVerticalPosition = ViewportPositionerVerticalPositionLabel.undefined;\n      let desiredHorizontalPosition = ViewportPositionerHorizontalPositionLabel.undefined;\n\n      if (this.props.horizontalPositioningMode !== AxisPositioningMode.uncontrolled) {\n        const horizontalOptions = this.getHorizontalPositioningOptions();\n        desiredHorizontalPosition = this.state.defaultHorizontalPosition;\n        const horizontalThreshold = this.props.horizontalThreshold !== undefined ? this.props.horizontalThreshold : this.positionerRect.width;\n\n        if (desiredHorizontalPosition === ViewportPositionerHorizontalPositionLabel.undefined || !this.props.horizontalLockToDefault && this.getAvailableWidth(desiredHorizontalPosition) < horizontalThreshold) {\n          desiredHorizontalPosition = this.getAvailableWidth(horizontalOptions[0]) > this.getAvailableWidth(horizontalOptions[1]) ? horizontalOptions[0] : horizontalOptions[1];\n        }\n      }\n\n      if (this.props.verticalPositioningMode !== AxisPositioningMode.uncontrolled) {\n        const verticalOptions = this.getVerticalPositioningOptions();\n        desiredVerticalPosition = this.state.defaultVerticalPosition;\n        const verticalThreshold = this.props.verticalThreshold !== undefined ? this.props.verticalThreshold : this.positionerRect.height;\n\n        if (desiredVerticalPosition === ViewportPositionerVerticalPositionLabel.undefined || !this.props.verticalLockToDefault && this.getAvailableHeight(desiredVerticalPosition) < verticalThreshold) {\n          desiredVerticalPosition = this.getAvailableHeight(verticalOptions[0]) > this.getAvailableHeight(verticalOptions[1]) ? verticalOptions[0] : verticalOptions[1];\n        }\n      }\n\n      const nextPositionerDimension = this.getNextPositionerDimension(desiredHorizontalPosition, desiredVerticalPosition);\n      this.setState(Object.assign({\n        xTranslate: this.getHorizontalTranslate(desiredHorizontalPosition),\n        yTranslate: this.getVerticalTranslate(desiredVerticalPosition),\n        initialLayoutComplete: true\n      }, this.getHorizontalPositioningState(desiredHorizontalPosition, nextPositionerDimension), this.getVerticalPositioningState(desiredVerticalPosition, nextPositionerDimension)));\n    };\n    /**\n     * Get positioner dimensions for next render\n     */\n\n\n    this.getNextPositionerDimension = (desiredHorizontalPosition, desiredVerticalPosition) => {\n      const newPositionerDimension = {\n        height: this.positionerRect.height,\n        width: this.positionerRect.width\n      };\n\n      if (this.props.scaleToFit) {\n        newPositionerDimension.height = Math.max(Math.min(this.getAvailableHeight(desiredVerticalPosition), this.viewportRect.height), isNil(this.props.verticalThreshold) ? 0 : this.props.verticalThreshold);\n        newPositionerDimension.width = Math.max(Math.min(this.getAvailableWidth(desiredHorizontalPosition), this.viewportRect.width), isNil(this.props.horizontalThreshold) ? 0 : this.props.horizontalThreshold);\n      }\n\n      return newPositionerDimension;\n    };\n    /**\n     * Get horizontal positioning state based on desired position\n     */\n\n\n    this.getHorizontalPositioningState = (desiredHorizontalPosition, nextPositionerDimension) => {\n      let right = null;\n      let left = null;\n      let xTransformOrigin = \"left\"\n      /* left */\n      ;\n\n      switch (desiredHorizontalPosition) {\n        case ViewportPositionerHorizontalPositionLabel.left:\n          xTransformOrigin = \"right\"\n          /* right */\n          ;\n          right = nextPositionerDimension.width - this.baseHorizontalOffset;\n          break;\n\n        case ViewportPositionerHorizontalPositionLabel.insetLeft:\n          xTransformOrigin = \"right\"\n          /* right */\n          ;\n          right = nextPositionerDimension.width - this.anchorWidth - this.baseHorizontalOffset;\n          break;\n\n        case ViewportPositionerHorizontalPositionLabel.insetRight:\n          xTransformOrigin = \"left\"\n          /* left */\n          ;\n          left = this.baseHorizontalOffset;\n          break;\n\n        case ViewportPositionerHorizontalPositionLabel.right:\n          xTransformOrigin = \"left\"\n          /* left */\n          ;\n          left = this.anchorWidth + this.baseHorizontalOffset;\n          break;\n      }\n\n      return {\n        xTransformOrigin,\n        right,\n        left,\n        currentHorizontalPosition: desiredHorizontalPosition,\n        horizontalSelectedPositionWidth: nextPositionerDimension.width\n      };\n    };\n    /**\n     * Get vertical positioning state based on desired position\n     */\n\n\n    this.getVerticalPositioningState = (desiredVerticalPosition, nextPositionerDimension) => {\n      let top = null;\n      let bottom = null;\n      let yTransformOrigin = \"top\"\n      /* top */\n      ;\n\n      switch (desiredVerticalPosition) {\n        case ViewportPositionerVerticalPositionLabel.top:\n          yTransformOrigin = \"bottom\"\n          /* bottom */\n          ;\n          bottom = nextPositionerDimension.height + this.anchorHeight - this.baseVerticalOffset;\n          break;\n\n        case ViewportPositionerVerticalPositionLabel.insetTop:\n          yTransformOrigin = \"bottom\"\n          /* bottom */\n          ;\n          bottom = nextPositionerDimension.height - this.baseVerticalOffset;\n          break;\n\n        case ViewportPositionerVerticalPositionLabel.insetBottom:\n          yTransformOrigin = \"top\"\n          /* top */\n          ;\n          top = this.baseVerticalOffset - this.anchorHeight;\n          break;\n\n        case ViewportPositionerVerticalPositionLabel.bottom:\n          yTransformOrigin = \"top\"\n          /* top */\n          ;\n          top = this.baseVerticalOffset;\n          break;\n      }\n\n      return {\n        yTransformOrigin,\n        top,\n        bottom,\n        currentVerticalPosition: desiredVerticalPosition,\n        verticalSelectedPositionHeight: nextPositionerDimension.height\n      };\n    };\n    /**\n     *  Calculate horizontal translation to keep positioner in view\n     */\n\n\n    this.getHorizontalTranslate = horizontalPosition => {\n      if (!this.props.horizontalAlwaysInView || this.state.disabled) {\n        return 0;\n      }\n\n      let translate = 0;\n\n      switch (horizontalPosition) {\n        case ViewportPositionerHorizontalPositionLabel.left:\n          translate = this.viewportRect.right - this.anchorLeft;\n          translate = translate < 0 ? translate - 1 : 0;\n          break;\n\n        case ViewportPositionerHorizontalPositionLabel.insetLeft:\n          translate = this.viewportRect.right - this.anchorRight;\n          translate = translate < 0 ? translate - 1 : 0;\n          break;\n\n        case ViewportPositionerHorizontalPositionLabel.insetRight:\n          translate = this.viewportRect.left - this.anchorLeft;\n          translate = translate > 0 ? translate + 1 : 0;\n          break;\n\n        case ViewportPositionerHorizontalPositionLabel.right:\n          translate = this.viewportRect.left - this.anchorRight;\n          translate = translate > 0 ? translate + 1 : 0;\n          break;\n      }\n\n      return translate;\n    };\n    /**\n     *  Calculate vertical translation to keep positioner in view\n     */\n\n\n    this.getVerticalTranslate = verticalPosition => {\n      if (!this.props.verticalAlwaysInView || this.state.disabled) {\n        return 0;\n      }\n\n      let translate = 0;\n\n      switch (verticalPosition) {\n        case ViewportPositionerVerticalPositionLabel.top:\n          translate = this.viewportRect.bottom - this.anchorTop;\n          translate = translate < 0 ? translate - 1 : 0;\n          break;\n\n        case ViewportPositionerVerticalPositionLabel.insetTop:\n          translate = this.viewportRect.bottom - this.anchorBottom;\n          translate = translate < 0 ? translate - 1 : 0;\n          break;\n\n        case ViewportPositionerVerticalPositionLabel.insetBottom:\n          translate = this.viewportRect.top - this.anchorTop;\n          translate = translate < 0 ? 0 : translate + 1;\n          break;\n\n        case ViewportPositionerVerticalPositionLabel.bottom:\n          translate = this.viewportRect.top - this.anchorBottom;\n          translate = translate < 0 ? 0 : translate + 1;\n          break;\n      }\n\n      return translate;\n    };\n    /**\n     * Request's an animation frame if there are currently no open animation frame requests\n     */\n\n\n    this.requestFrame = () => {\n      if (this.openRequestAnimationFrame === null) {\n        this.openRequestAnimationFrame = window.requestAnimationFrame(this.updateLayout);\n      }\n    };\n    /**\n     * get the anchor element\n     */\n\n\n    this.getAnchorElement = () => {\n      if (isNil(this.props.anchor)) {\n        return null;\n      }\n\n      return this.extractElementFromRef(this.props.anchor);\n    };\n    /**\n     * get the viewport element, prefer one provided in props, then context, then document root\n     */\n\n\n    this.getViewportElement = viewportRef => {\n      if (!isNil(viewportRef)) {\n        return this.extractElementFromRef(viewportRef);\n      }\n\n      if (!isNil(this.context.viewport)) {\n        return this.extractElementFromRef(this.context.viewport);\n      }\n\n      if (document.scrollingElement instanceof HTMLElement) {\n        return document.scrollingElement;\n      }\n\n      return null;\n    };\n    /**\n     * returns an html element from a ref\n     */\n\n\n    this.extractElementFromRef = sourceRef => {\n      if (sourceRef instanceof HTMLElement) {\n        return sourceRef;\n      }\n\n      if (!isNil(sourceRef.current)) {\n        if (sourceRef.current instanceof HTMLElement) {\n          return sourceRef.current;\n        }\n\n        const foundNode = ReactDOM.findDOMNode(sourceRef.current);\n\n        if (foundNode instanceof HTMLElement) {\n          return foundNode;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Converts simple horizontal position to a position label based on AxisPositioningMode\n     */\n\n\n    this.getHorizontalPositionToLabel = (positioningMode, position) => {\n      switch (positioningMode) {\n        case AxisPositioningMode.inset:\n          if (position === ViewportPositionerHorizontalPosition.left) {\n            return ViewportPositionerHorizontalPositionLabel.insetLeft;\n          } else if (position === ViewportPositionerHorizontalPosition.right) {\n            return ViewportPositionerHorizontalPositionLabel.insetRight;\n          }\n\n        case AxisPositioningMode.adjacent:\n          if (position === ViewportPositionerHorizontalPosition.left) {\n            return ViewportPositionerHorizontalPositionLabel.left;\n          } else if (position === ViewportPositionerHorizontalPosition.right) {\n            return ViewportPositionerHorizontalPositionLabel.right;\n          }\n\n        case AxisPositioningMode.uncontrolled:\n          return ViewportPositionerHorizontalPositionLabel.undefined;\n      }\n    };\n    /**\n     * Converts simple vertical position to a position label based on AxisPositioningMode\n     */\n\n\n    this.getVerticalPositionToLabel = (positioningMode, position) => {\n      switch (positioningMode) {\n        case AxisPositioningMode.inset:\n          if (position === ViewportPositionerVerticalPosition.top) {\n            return ViewportPositionerVerticalPositionLabel.insetTop;\n          } else if (position === ViewportPositionerVerticalPosition.bottom) {\n            return ViewportPositionerVerticalPositionLabel.insetBottom;\n          }\n\n        case AxisPositioningMode.adjacent:\n          if (position === ViewportPositionerVerticalPosition.top) {\n            return ViewportPositionerVerticalPositionLabel.top;\n          } else if (position === ViewportPositionerVerticalPosition.bottom) {\n            return ViewportPositionerVerticalPositionLabel.bottom;\n          }\n\n        case AxisPositioningMode.uncontrolled:\n          return ViewportPositionerVerticalPositionLabel.undefined;\n      }\n    };\n    /**\n     * Gets the uninitialized state\n     */\n\n\n    this.generateInitialState = () => {\n      return {\n        // Note: when the component is initialized or reset we start with a the disabled state set to true.\n        // This gets set to fals during component initialization assuming the disabled prop is not set to true and\n        // that required resources load correctly (ie an invalid anchor or viewport ref could prevent the component\n        // from ever becoming enabled regardless of the disable prop)\n        disabled: true,\n        noObserverMode: false,\n        xTransformOrigin: \"left\"\n        /* left */\n        ,\n        yTransformOrigin: \"top\"\n        /* top */\n        ,\n        xTranslate: 0,\n        yTranslate: 0,\n        top: null,\n        right: null,\n        bottom: null,\n        left: null,\n        currentHorizontalPosition: ViewportPositionerHorizontalPositionLabel.undefined,\n        currentVerticalPosition: ViewportPositionerVerticalPositionLabel.undefined,\n        defaultHorizontalPosition: this.getHorizontalPositionToLabel(this.props.horizontalPositioningMode, this.props.defaultHorizontalPosition),\n        defaultVerticalPosition: this.getVerticalPositionToLabel(this.props.verticalPositioningMode, this.props.defaultVerticalPosition),\n        horizontalSelectedPositionWidth: null,\n        verticalSelectedPositionHeight: null,\n        initialLayoutComplete: false,\n        validRefChecksRemaining: 2\n      };\n    };\n\n    this.state = this.generateInitialState();\n  }\n\n  componentDidMount() {\n    this.updateDisabledState();\n    this.requestFrame();\n  }\n\n  componentWillUnmount() {\n    this.disable();\n  }\n\n  componentDidUpdate(prevProps) {\n    // if anchor or viewport changes the component needs to reset\n    if (prevProps.anchor !== this.props.anchor || prevProps.viewport !== this.props.viewport) {\n      this.detachListeners(prevProps.viewport);\n      this.setState(this.generateInitialState());\n      return;\n    }\n\n    if (prevProps.disabled !== this.props.disabled || this.state.validRefChecksRemaining > 0) {\n      this.updateDisabledState();\n      return;\n    }\n\n    this.requestFrame();\n  }\n  /**\n   * Renders the component\n   */\n\n\n  render() {\n    return React.createElement(\"div\", Object.assign({}, this.unhandledProps(), {\n      ref: this.rootElement,\n      className: this.generateClassNames(),\n      style: this.getPositioningStyles()\n    }), this.props.children);\n  }\n  /**\n   * Create class-names\n   */\n\n\n  generateClassNames() {\n    const _this$props$managedCl = this.props.managedClasses,\n          viewportPositioner = _this$props$managedCl.viewportPositioner,\n          viewportPositioner__left = _this$props$managedCl.viewportPositioner__left,\n          viewportPositioner__right = _this$props$managedCl.viewportPositioner__right,\n          viewportPositioner__top = _this$props$managedCl.viewportPositioner__top,\n          viewportPositioner__bottom = _this$props$managedCl.viewportPositioner__bottom,\n          viewportPositioner__horizontalInset = _this$props$managedCl.viewportPositioner__horizontalInset,\n          viewportPositioner__verticalInset = _this$props$managedCl.viewportPositioner__verticalInset;\n    const horizontalPosition = this.state.currentHorizontalPosition;\n    const verticalPosition = this.state.currentVerticalPosition;\n    const isVerticalInset = verticalPosition === ViewportPositionerVerticalPositionLabel.insetTop || verticalPosition === ViewportPositionerVerticalPositionLabel.insetBottom;\n    const isHorizontalInset = horizontalPosition === ViewportPositionerHorizontalPositionLabel.insetLeft || horizontalPosition === ViewportPositionerHorizontalPositionLabel.insetRight;\n    return super.generateClassNames(classNames(viewportPositioner, [viewportPositioner__left, horizontalPosition === ViewportPositionerHorizontalPositionLabel.left || horizontalPosition === ViewportPositionerHorizontalPositionLabel.insetLeft], [viewportPositioner__right, horizontalPosition === ViewportPositionerHorizontalPositionLabel.right || horizontalPosition === ViewportPositionerHorizontalPositionLabel.insetRight], [viewportPositioner__horizontalInset, isHorizontalInset], [viewportPositioner__top, verticalPosition === ViewportPositionerVerticalPositionLabel.top || verticalPosition === ViewportPositionerVerticalPositionLabel.insetTop], [viewportPositioner__bottom, verticalPosition === ViewportPositionerVerticalPositionLabel.bottom || verticalPosition === ViewportPositionerVerticalPositionLabel.insetBottom], [viewportPositioner__verticalInset, isVerticalInset]));\n  }\n\n}\n\nViewportPositioner.displayName = `${DisplayNamePrefix}ViewportPositioner`;\nViewportPositioner.contextType = ViewportContext;\nViewportPositioner.defaultProps = {\n  horizontalPositioningMode: AxisPositioningMode.uncontrolled,\n  defaultHorizontalPosition: ViewportPositionerHorizontalPosition.uncontrolled,\n  verticalPositioningMode: AxisPositioningMode.adjacent,\n  defaultVerticalPosition: ViewportPositionerVerticalPosition.bottom,\n  horizontalAlwaysInView: false,\n  verticalAlwaysInView: false,\n  verticalLockToDefault: false,\n  horizontalLockToDefault: false,\n  fixedAfterInitialPlacement: false,\n  scaleToFit: false,\n  managedClasses: {}\n};\nViewportPositioner.contextType = ViewportContext;\nexport default ViewportPositioner;\nexport * from \"./viewport-positioner.props\";\nexport { ViewportContext };","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-react-base/dist/viewport-positioner/viewport-positioner.js"],"names":["Foundation","classNames","canUseDOM","get","isNil","React","ReactDOM","DisplayNamePrefix","AxisPositioningMode","ViewportPositionerHorizontalPosition","ViewportPositionerVerticalPosition","ViewportContext","ViewportPositionerHorizontalPositionLabel","ViewportPositionerVerticalPositionLabel","ViewportPositioner","constructor","props","handledProps","managedClasses","anchor","viewport","horizontalPositioningMode","defaultHorizontalPosition","horizontalThreshold","horizontalAlwaysInView","horizontalLockToDefault","verticalPositioningMode","defaultVerticalPosition","verticalThreshold","verticalAlwaysInView","verticalLockToDefault","fixedAfterInitialPlacement","scaleToFit","disabled","rootElement","createRef","openRequestAnimationFrame","anchorTop","anchorRight","anchorBottom","anchorLeft","anchorHeight","anchorWidth","scrollTop","scrollLeft","baseHorizontalOffset","baseVerticalOffset","getPositioningStyles","styleProps","Object","assign","height","state","verticalSelectedPositionHeight","width","horizontalSelectedPositionWidth","opacity","initialLayoutComplete","undefined","position","transformOrigin","xTransformOrigin","yTransformOrigin","transform","Math","floor","xTranslate","yTranslate","top","right","bottom","left","updateDisabledState","disable","getAnchorElement","getViewportElement","validRefChecksRemaining","setState","enableComponent","viewportElement","anchorElement","current","window","IntersectionObserver","ResizeObserver","setNoObserverMode","noObserverMode","collisionDetector","handleCollision","root","rootMargin","threshold","observe","resizeDetector","handleAnchorResize","addEventListener","handleScroll","positionerRect","getBoundingClientRect","viewportRect","anchorRect","updatePositionerOffset","requestFrame","detachListeners","viewportRef","viewPortElement","removeEventListener","disconnect","getHorizontalPositioningOptions","inset","insetLeft","insetRight","adjacent","getVerticalPositioningOptions","insetTop","insetBottom","getAvailableWidth","positionOption","spaceLeft","spaceRight","getAvailableHeight","spaceAbove","spaceBelow","entries","entry","contentRect","currentVerticalPosition","currentHorizontalPosition","observer","forEach","target","handlePositionerCollision","length","handleAnchorCollision","anchorEntry","rootBounds","boundingClientRect","positionerEntry","shouldDeriveAnchorPosition","uncontrolled","updateForScrolling","scrollingContainer","isNaN","verticalScrollDelta","horizontalScrollDelta","updateLayout","desiredVerticalPosition","desiredHorizontalPosition","horizontalOptions","verticalOptions","nextPositionerDimension","getNextPositionerDimension","getHorizontalTranslate","getVerticalTranslate","getHorizontalPositioningState","getVerticalPositioningState","newPositionerDimension","max","min","horizontalPosition","translate","verticalPosition","requestAnimationFrame","extractElementFromRef","context","document","scrollingElement","HTMLElement","sourceRef","foundNode","findDOMNode","getHorizontalPositionToLabel","positioningMode","getVerticalPositionToLabel","generateInitialState","componentDidMount","componentWillUnmount","componentDidUpdate","prevProps","render","createElement","unhandledProps","ref","className","generateClassNames","style","children","viewportPositioner","viewportPositioner__left","viewportPositioner__right","viewportPositioner__top","viewportPositioner__bottom","viewportPositioner__horizontalInset","viewportPositioner__verticalInset","isVerticalInset","isHorizontalInset","displayName","contextType","defaultProps"],"mappings":"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","sourcesContent":["import Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isNil } from \"lodash-es\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { DisplayNamePrefix, } from \"../utilities\";\nimport { AxisPositioningMode, ViewportPositionerHorizontalPosition, ViewportPositionerVerticalPosition, } from \"./viewport-positioner.props\";\nimport { ViewportContext } from \"./viewport-context\";\nexport var ViewportPositionerHorizontalPositionLabel;\n(function (ViewportPositionerHorizontalPositionLabel) {\n    ViewportPositionerHorizontalPositionLabel[\"left\"] = \"left\";\n    ViewportPositionerHorizontalPositionLabel[\"insetLeft\"] = \"insetLeft\";\n    ViewportPositionerHorizontalPositionLabel[\"insetRight\"] = \"insetRight\";\n    ViewportPositionerHorizontalPositionLabel[\"right\"] = \"right\";\n    ViewportPositionerHorizontalPositionLabel[\"undefined\"] = \"undefined\";\n})(ViewportPositionerHorizontalPositionLabel || (ViewportPositionerHorizontalPositionLabel = {}));\nexport var ViewportPositionerVerticalPositionLabel;\n(function (ViewportPositionerVerticalPositionLabel) {\n    ViewportPositionerVerticalPositionLabel[\"top\"] = \"top\";\n    ViewportPositionerVerticalPositionLabel[\"insetTop\"] = \"insetTop\";\n    ViewportPositionerVerticalPositionLabel[\"insetBottom\"] = \"insetBottom\";\n    ViewportPositionerVerticalPositionLabel[\"bottom\"] = \"bottom\";\n    ViewportPositionerVerticalPositionLabel[\"undefined\"] = \"undefined\";\n})(ViewportPositionerVerticalPositionLabel || (ViewportPositionerVerticalPositionLabel = {}));\nclass ViewportPositioner extends Foundation {\n    /**\n     * constructor\n     */\n    constructor(props) {\n        super(props);\n        this.handledProps = {\n            managedClasses: void 0,\n            anchor: void 0,\n            viewport: void 0,\n            horizontalPositioningMode: void 0,\n            defaultHorizontalPosition: void 0,\n            horizontalThreshold: void 0,\n            horizontalAlwaysInView: void 0,\n            horizontalLockToDefault: void 0,\n            verticalPositioningMode: void 0,\n            defaultVerticalPosition: void 0,\n            verticalThreshold: void 0,\n            verticalAlwaysInView: void 0,\n            verticalLockToDefault: void 0,\n            fixedAfterInitialPlacement: void 0,\n            scaleToFit: void 0,\n            disabled: void 0,\n        };\n        this.rootElement = React.createRef();\n        this.openRequestAnimationFrame = null;\n        this.anchorTop = 0;\n        this.anchorRight = 0;\n        this.anchorBottom = 0;\n        this.anchorLeft = 0;\n        this.anchorHeight = 0;\n        this.anchorWidth = 0;\n        this.scrollTop = 0;\n        this.scrollLeft = 0;\n        /**\n         * base offsets between the positioner's base position and the anchor's\n         */\n        this.baseHorizontalOffset = 0;\n        this.baseVerticalOffset = 0;\n        /**\n         *  gets the CSS classes to be programmatically applied to the component\n         */\n        this.getPositioningStyles = () => {\n            // Check if there is already a style object being passed as props\n            const styleProps = get(this.props, \"style\");\n            return Object.assign({}, (this.props.scaleToFit\n                ? {\n                    height: `${this.state.verticalSelectedPositionHeight}px`,\n                    width: `${this.state.horizontalSelectedPositionWidth}px`,\n                }\n                : {}), { \n                // hide the component until afer initial layout attempst (to avoid a flicker)\n                opacity: !this.props.disabled && !this.state.initialLayoutComplete ? 0 : undefined, position: \"relative\", transformOrigin: `${this.state.xTransformOrigin} ${this.state.yTransformOrigin}`, transform: `translate(\n                ${Math.floor(this.state.xTranslate)}px, \n                ${Math.floor(this.state.yTranslate)}px\n            )`, top: this.state.top === null ? null : `${this.state.top}px`, right: this.state.right === null ? null : `${this.state.right}px`, bottom: this.state.bottom === null ? null : `${this.state.bottom}px`, left: this.state.left === null ? null : `${this.state.left}px` }, styleProps);\n        };\n        /**\n         *  Checks whether component should be disabled or not\n         */\n        this.updateDisabledState = () => {\n            if (!canUseDOM() || this.props.disabled === true) {\n                this.disable();\n                return;\n            }\n            if (this.getAnchorElement() === null ||\n                this.getViewportElement(this.props.viewport) === null) {\n                if (this.state.validRefChecksRemaining > 0) {\n                    this.setState({\n                        validRefChecksRemaining: this.state.validRefChecksRemaining - 1,\n                        initialLayoutComplete: this.state.validRefChecksRemaining <= 1,\n                    });\n                    return;\n                }\n            }\n            this.enableComponent();\n        };\n        /**\n         *  Enable the component\n         */\n        this.enableComponent = () => {\n            const viewportElement = this.getViewportElement(this.props.viewport);\n            const anchorElement = this.getAnchorElement();\n            if (!this.state.disabled ||\n                this.props.disabled ||\n                isNil(anchorElement) ||\n                isNil(viewportElement) ||\n                isNil(this.rootElement.current)) {\n                return;\n            }\n            if (!window.IntersectionObserver ||\n                !window.ResizeObserver) {\n                this.setNoObserverMode();\n                return;\n            }\n            this.setState({\n                disabled: false,\n                noObserverMode: false,\n                validRefChecksRemaining: 0,\n            });\n            this.collisionDetector = new window.IntersectionObserver(this.handleCollision, {\n                root: viewportElement,\n                rootMargin: \"0px\",\n                threshold: [0, 1],\n            });\n            this.collisionDetector.observe(this.rootElement.current);\n            this.collisionDetector.observe(anchorElement);\n            this.resizeDetector = new window.ResizeObserver(this.handleAnchorResize);\n            this.resizeDetector.observe(anchorElement);\n            viewportElement.addEventListener(\"scroll\", this.handleScroll);\n        };\n        /**\n         *  If observers are not supported we do expensive getBoundingClientRect calls\n         *  once to get correct initial placement\n         */\n        this.setNoObserverMode = () => {\n            const viewportElement = this.getViewportElement(this.props.viewport);\n            const anchorElement = this.getAnchorElement();\n            if (isNil(viewportElement) || isNil(anchorElement)) {\n                return;\n            }\n            this.positionerRect = this.rootElement.current.getBoundingClientRect();\n            this.viewportRect = viewportElement.getBoundingClientRect();\n            const anchorRect = anchorElement.getBoundingClientRect();\n            this.anchorTop = anchorRect.top;\n            this.anchorRight = anchorRect.right;\n            this.anchorBottom = anchorRect.bottom;\n            this.anchorLeft = anchorRect.left;\n            this.anchorWidth = anchorRect.width;\n            this.anchorHeight = anchorRect.height;\n            this.updatePositionerOffset();\n            this.setState({\n                validRefChecksRemaining: 0,\n                disabled: false,\n                noObserverMode: true,\n            });\n            this.requestFrame();\n        };\n        /**\n         *  Disable the component\n         */\n        this.disable = () => {\n            if (this.state.disabled) {\n                return;\n            }\n            this.detachListeners(this.props.viewport);\n            this.setState({\n                disabled: true,\n                validRefChecksRemaining: 0,\n            });\n        };\n        /**\n         *  removes event listeners and observers when component is being unmounted or reset\n         */\n        this.detachListeners = (viewportRef) => {\n            const viewPortElement = this.getViewportElement(viewportRef);\n            if (!isNil(viewPortElement)) {\n                viewPortElement.removeEventListener(\"scroll\", this.handleScroll);\n            }\n            if (this.collisionDetector &&\n                typeof this.collisionDetector.disconnect === \"function\") {\n                this.collisionDetector.disconnect();\n                this.collisionDetector = null;\n            }\n            // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142\n            // Full browser support imminent\n            // Revisit usage once Safari and Firefox adapt\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409\n            // https://bugs.webkit.org/show_bug.cgi?id=157743\n            if (this.resizeDetector && typeof this.resizeDetector.disconnect === \"function\") {\n                this.resizeDetector.disconnect();\n                this.resizeDetector = null;\n            }\n        };\n        /**\n         *  Get available Horizontal positions based on positioning mode\n         */\n        this.getHorizontalPositioningOptions = () => {\n            switch (this.props.horizontalPositioningMode) {\n                case AxisPositioningMode.inset:\n                    return [\n                        ViewportPositionerHorizontalPositionLabel.insetLeft,\n                        ViewportPositionerHorizontalPositionLabel.insetRight,\n                    ];\n                case AxisPositioningMode.adjacent:\n                    return [\n                        ViewportPositionerHorizontalPositionLabel.left,\n                        ViewportPositionerHorizontalPositionLabel.right,\n                    ];\n            }\n        };\n        /**\n         * Get available Vertical positions based on positioning mode\n         */\n        this.getVerticalPositioningOptions = () => {\n            switch (this.props.verticalPositioningMode) {\n                case AxisPositioningMode.inset:\n                    return [\n                        ViewportPositionerVerticalPositionLabel.insetTop,\n                        ViewportPositionerVerticalPositionLabel.insetBottom,\n                    ];\n                case AxisPositioningMode.adjacent:\n                    return [\n                        ViewportPositionerVerticalPositionLabel.top,\n                        ViewportPositionerVerticalPositionLabel.bottom,\n                    ];\n            }\n        };\n        /**\n         *  Get the width available for a particular horizontal position\n         */\n        this.getAvailableWidth = (positionOption) => {\n            const spaceLeft = this.anchorLeft - this.viewportRect.left;\n            const spaceRight = this.viewportRect.right - (this.anchorLeft + this.anchorWidth);\n            switch (positionOption) {\n                case ViewportPositionerHorizontalPositionLabel.left:\n                    return spaceLeft;\n                case ViewportPositionerHorizontalPositionLabel.insetLeft:\n                    return spaceLeft + this.anchorWidth;\n                case ViewportPositionerHorizontalPositionLabel.insetRight:\n                    return spaceRight + this.anchorWidth;\n                case ViewportPositionerHorizontalPositionLabel.right:\n                    return spaceRight;\n            }\n        };\n        /**\n         *  Get the height available for a particular vertical position\n         */\n        this.getAvailableHeight = (positionOption) => {\n            const spaceAbove = this.anchorTop - this.viewportRect.top;\n            const spaceBelow = this.viewportRect.bottom - (this.anchorTop + this.anchorHeight);\n            switch (positionOption) {\n                case ViewportPositionerVerticalPositionLabel.top:\n                    return spaceAbove;\n                case ViewportPositionerVerticalPositionLabel.insetTop:\n                    return spaceAbove + this.anchorHeight;\n                case ViewportPositionerVerticalPositionLabel.insetBottom:\n                    return spaceBelow + this.anchorHeight;\n                case ViewportPositionerVerticalPositionLabel.bottom:\n                    return spaceBelow;\n            }\n        };\n        /**\n         *  Handle scroll events\n         */\n        this.handleScroll = () => {\n            this.requestFrame();\n        };\n        /**\n         *  Handle anchor resize events\n         */\n        this.handleAnchorResize = (entries) => {\n            const entry = entries[0];\n            this.anchorHeight = entry.contentRect.height;\n            this.anchorWidth = entry.contentRect.width;\n            if (this.state.currentVerticalPosition ===\n                ViewportPositionerVerticalPositionLabel.top ||\n                this.state.currentVerticalPosition ===\n                    ViewportPositionerVerticalPositionLabel.insetTop) {\n                this.anchorBottom = this.anchorTop + this.anchorHeight;\n            }\n            else {\n                this.anchorTop = this.anchorBottom - this.anchorHeight;\n            }\n            if (this.state.currentHorizontalPosition ===\n                ViewportPositionerHorizontalPositionLabel.left ||\n                this.state.currentHorizontalPosition ===\n                    ViewportPositionerHorizontalPositionLabel.insetLeft) {\n                this.anchorRight = this.anchorLeft + this.anchorWidth;\n            }\n            else {\n                this.anchorLeft = this.anchorRight - this.anchorWidth;\n            }\n            this.requestFrame();\n        };\n        /**\n         *  Handle collisions\n         */\n        this.handleCollision = (entries, observer) => {\n            entries.forEach((entry) => {\n                if (entry.target === this.rootElement.current) {\n                    this.handlePositionerCollision(entry, entries.length === 1);\n                }\n                else {\n                    this.handleAnchorCollision(entry);\n                }\n            });\n            const viewPortElement = this.getViewportElement(this.props.viewport);\n            if (!isNil(viewPortElement)) {\n                this.scrollTop = viewPortElement.scrollTop;\n                this.scrollLeft = viewPortElement.scrollLeft;\n            }\n            if (entries.length === 2) {\n                this.updatePositionerOffset();\n            }\n            this.requestFrame();\n        };\n        /**\n         *  Update data based on anchor collisions\n         */\n        this.handleAnchorCollision = (anchorEntry) => {\n            this.viewportRect = anchorEntry.rootBounds;\n            this.anchorTop = anchorEntry.boundingClientRect.top;\n            this.anchorRight = anchorEntry.boundingClientRect.right;\n            this.anchorBottom = anchorEntry.boundingClientRect.bottom;\n            this.anchorLeft = anchorEntry.boundingClientRect.left;\n            this.anchorHeight = anchorEntry.boundingClientRect.height;\n            this.anchorWidth = anchorEntry.boundingClientRect.width;\n        };\n        /**\n         *  Update data based on positioner collisions\n         */\n        this.handlePositionerCollision = (positionerEntry, shouldDeriveAnchorPosition) => {\n            this.viewportRect = positionerEntry.rootBounds;\n            this.positionerRect = positionerEntry.boundingClientRect;\n            if (shouldDeriveAnchorPosition) {\n                switch (this.state.currentVerticalPosition) {\n                    case ViewportPositionerVerticalPositionLabel.top:\n                        this.anchorTop = this.positionerRect.bottom - this.state.yTranslate;\n                        this.anchorBottom = this.anchorTop + this.anchorHeight;\n                        break;\n                    case ViewportPositionerVerticalPositionLabel.insetTop:\n                        this.anchorBottom =\n                            this.positionerRect.bottom - this.state.yTranslate;\n                        this.anchorTop = this.anchorBottom - this.anchorHeight;\n                        break;\n                    case ViewportPositionerVerticalPositionLabel.insetBottom:\n                        this.anchorTop = this.positionerRect.top - this.state.yTranslate;\n                        this.anchorBottom = this.anchorTop + this.anchorHeight;\n                        break;\n                    case ViewportPositionerVerticalPositionLabel.bottom:\n                        this.anchorBottom = this.positionerRect.top - this.state.yTranslate;\n                        this.anchorTop = this.anchorBottom - this.anchorHeight;\n                        break;\n                }\n                switch (this.state.currentHorizontalPosition) {\n                    case ViewportPositionerHorizontalPositionLabel.left:\n                        this.anchorLeft = this.positionerRect.right - this.state.xTranslate;\n                        this.anchorRight = this.anchorLeft + this.anchorWidth;\n                        break;\n                    case ViewportPositionerHorizontalPositionLabel.insetLeft:\n                        this.anchorRight = this.positionerRect.right - this.state.xTranslate;\n                        this.anchorLeft = this.anchorRight - this.anchorWidth;\n                        break;\n                    case ViewportPositionerHorizontalPositionLabel.insetRight:\n                        this.anchorLeft = this.positionerRect.left - this.state.xTranslate;\n                        this.anchorRight = this.anchorLeft + this.anchorWidth;\n                        break;\n                    case ViewportPositionerHorizontalPositionLabel.right:\n                        this.anchorRight = this.positionerRect.left - this.state.xTranslate;\n                        this.anchorLeft = this.anchorRight - this.anchorWidth;\n                        break;\n                }\n            }\n        };\n        /**\n         *  Update the offset values\n         */\n        this.updatePositionerOffset = () => {\n            if (this.props.horizontalPositioningMode === AxisPositioningMode.uncontrolled) {\n                this.baseHorizontalOffset = this.anchorLeft - this.positionerRect.left;\n            }\n            else {\n                switch (this.state.currentHorizontalPosition) {\n                    case ViewportPositionerHorizontalPositionLabel.undefined:\n                        this.baseHorizontalOffset =\n                            this.anchorLeft +\n                                this.state.xTranslate -\n                                this.positionerRect.left;\n                        break;\n                    case ViewportPositionerHorizontalPositionLabel.left:\n                        this.baseHorizontalOffset =\n                            this.baseHorizontalOffset +\n                                (this.anchorLeft +\n                                    this.state.xTranslate -\n                                    this.positionerRect.right);\n                        break;\n                    case ViewportPositionerHorizontalPositionLabel.insetLeft:\n                        this.baseHorizontalOffset =\n                            this.baseHorizontalOffset +\n                                (this.anchorRight +\n                                    this.state.xTranslate -\n                                    this.positionerRect.right);\n                        break;\n                    case ViewportPositionerHorizontalPositionLabel.insetRight:\n                        this.baseHorizontalOffset =\n                            this.baseHorizontalOffset +\n                                (this.anchorLeft +\n                                    this.state.xTranslate -\n                                    this.positionerRect.left);\n                        break;\n                    case ViewportPositionerHorizontalPositionLabel.right:\n                        this.baseHorizontalOffset =\n                            this.baseHorizontalOffset +\n                                (this.anchorRight +\n                                    this.state.xTranslate -\n                                    this.positionerRect.left);\n                        break;\n                }\n            }\n            if (this.props.verticalPositioningMode === AxisPositioningMode.uncontrolled) {\n                this.baseVerticalOffset = this.anchorBottom - this.positionerRect.top;\n            }\n            else {\n                switch (this.state.currentVerticalPosition) {\n                    case ViewportPositionerVerticalPositionLabel.undefined:\n                        this.baseVerticalOffset =\n                            this.anchorBottom +\n                                this.state.yTranslate -\n                                this.positionerRect.top;\n                        break;\n                    case ViewportPositionerVerticalPositionLabel.top:\n                        this.baseVerticalOffset =\n                            this.baseVerticalOffset +\n                                (this.anchorTop +\n                                    this.state.yTranslate -\n                                    this.positionerRect.bottom);\n                        break;\n                    case ViewportPositionerVerticalPositionLabel.insetTop:\n                        this.baseVerticalOffset =\n                            this.baseVerticalOffset +\n                                (this.anchorBottom +\n                                    this.state.yTranslate -\n                                    this.positionerRect.bottom);\n                        break;\n                    case ViewportPositionerVerticalPositionLabel.insetBottom:\n                        this.baseVerticalOffset =\n                            this.baseVerticalOffset +\n                                (this.anchorTop +\n                                    this.state.yTranslate -\n                                    this.positionerRect.top);\n                        break;\n                    case ViewportPositionerVerticalPositionLabel.bottom:\n                        this.baseVerticalOffset =\n                            this.baseVerticalOffset +\n                                (this.anchorBottom +\n                                    this.state.yTranslate -\n                                    this.positionerRect.top);\n                        break;\n                }\n            }\n        };\n        /**\n         * Check for scroll changes in viewport and adjust position data\n         */\n        this.updateForScrolling = () => {\n            const scrollingContainer = this.getViewportElement(this.props.viewport);\n            if (isNil(scrollingContainer) || isNaN(scrollingContainer.scrollTop)) {\n                return;\n            }\n            const scrollTop = scrollingContainer.scrollTop;\n            const scrollLeft = scrollingContainer.scrollLeft;\n            if (this.scrollTop !== scrollTop) {\n                const verticalScrollDelta = this.scrollTop - scrollTop;\n                this.scrollTop = scrollTop;\n                this.anchorTop = this.anchorTop + verticalScrollDelta;\n                this.anchorBottom = this.anchorBottom + verticalScrollDelta;\n            }\n            if (this.scrollLeft !== scrollLeft) {\n                const horizontalScrollDelta = this.scrollLeft - scrollLeft;\n                this.scrollLeft = scrollLeft;\n                this.anchorLeft = this.anchorLeft + horizontalScrollDelta;\n                this.anchorRight = this.anchorRight + horizontalScrollDelta;\n            }\n        };\n        /**\n         *  Recalculate layout related state values\n         */\n        this.updateLayout = () => {\n            this.openRequestAnimationFrame = null;\n            if (this.state.disabled ||\n                isNil(this.viewportRect) ||\n                isNil(this.positionerRect) ||\n                (this.props.fixedAfterInitialPlacement && this.state.initialLayoutComplete) ||\n                (this.state.noObserverMode && this.state.initialLayoutComplete)) {\n                return;\n            }\n            this.updateForScrolling();\n            let desiredVerticalPosition = ViewportPositionerVerticalPositionLabel.undefined;\n            let desiredHorizontalPosition = ViewportPositionerHorizontalPositionLabel.undefined;\n            if (this.props.horizontalPositioningMode !== AxisPositioningMode.uncontrolled) {\n                const horizontalOptions = this.getHorizontalPositioningOptions();\n                desiredHorizontalPosition = this.state.defaultHorizontalPosition;\n                const horizontalThreshold = this.props.horizontalThreshold !== undefined\n                    ? this.props.horizontalThreshold\n                    : this.positionerRect.width;\n                if (desiredHorizontalPosition ===\n                    ViewportPositionerHorizontalPositionLabel.undefined ||\n                    (!this.props.horizontalLockToDefault &&\n                        this.getAvailableWidth(desiredHorizontalPosition) <\n                            horizontalThreshold)) {\n                    desiredHorizontalPosition =\n                        this.getAvailableWidth(horizontalOptions[0]) >\n                            this.getAvailableWidth(horizontalOptions[1])\n                            ? horizontalOptions[0]\n                            : horizontalOptions[1];\n                }\n            }\n            if (this.props.verticalPositioningMode !== AxisPositioningMode.uncontrolled) {\n                const verticalOptions = this.getVerticalPositioningOptions();\n                desiredVerticalPosition = this.state.defaultVerticalPosition;\n                const verticalThreshold = this.props.verticalThreshold !== undefined\n                    ? this.props.verticalThreshold\n                    : this.positionerRect.height;\n                if (desiredVerticalPosition ===\n                    ViewportPositionerVerticalPositionLabel.undefined ||\n                    (!this.props.verticalLockToDefault &&\n                        this.getAvailableHeight(desiredVerticalPosition) < verticalThreshold)) {\n                    desiredVerticalPosition =\n                        this.getAvailableHeight(verticalOptions[0]) >\n                            this.getAvailableHeight(verticalOptions[1])\n                            ? verticalOptions[0]\n                            : verticalOptions[1];\n                }\n            }\n            const nextPositionerDimension = this.getNextPositionerDimension(desiredHorizontalPosition, desiredVerticalPosition);\n            this.setState(Object.assign({\n                xTranslate: this.getHorizontalTranslate(desiredHorizontalPosition),\n                yTranslate: this.getVerticalTranslate(desiredVerticalPosition),\n                initialLayoutComplete: true,\n            }, this.getHorizontalPositioningState(desiredHorizontalPosition, nextPositionerDimension), this.getVerticalPositioningState(desiredVerticalPosition, nextPositionerDimension)));\n        };\n        /**\n         * Get positioner dimensions for next render\n         */\n        this.getNextPositionerDimension = (desiredHorizontalPosition, desiredVerticalPosition) => {\n            const newPositionerDimension = {\n                height: this.positionerRect.height,\n                width: this.positionerRect.width,\n            };\n            if (this.props.scaleToFit) {\n                newPositionerDimension.height = Math.max(Math.min(this.getAvailableHeight(desiredVerticalPosition), this.viewportRect.height), isNil(this.props.verticalThreshold) ? 0 : this.props.verticalThreshold);\n                newPositionerDimension.width = Math.max(Math.min(this.getAvailableWidth(desiredHorizontalPosition), this.viewportRect.width), isNil(this.props.horizontalThreshold) ? 0 : this.props.horizontalThreshold);\n            }\n            return newPositionerDimension;\n        };\n        /**\n         * Get horizontal positioning state based on desired position\n         */\n        this.getHorizontalPositioningState = (desiredHorizontalPosition, nextPositionerDimension) => {\n            let right = null;\n            let left = null;\n            let xTransformOrigin = \"left\" /* left */;\n            switch (desiredHorizontalPosition) {\n                case ViewportPositionerHorizontalPositionLabel.left:\n                    xTransformOrigin = \"right\" /* right */;\n                    right = nextPositionerDimension.width - this.baseHorizontalOffset;\n                    break;\n                case ViewportPositionerHorizontalPositionLabel.insetLeft:\n                    xTransformOrigin = \"right\" /* right */;\n                    right =\n                        nextPositionerDimension.width -\n                            this.anchorWidth -\n                            this.baseHorizontalOffset;\n                    break;\n                case ViewportPositionerHorizontalPositionLabel.insetRight:\n                    xTransformOrigin = \"left\" /* left */;\n                    left = this.baseHorizontalOffset;\n                    break;\n                case ViewportPositionerHorizontalPositionLabel.right:\n                    xTransformOrigin = \"left\" /* left */;\n                    left = this.anchorWidth + this.baseHorizontalOffset;\n                    break;\n            }\n            return {\n                xTransformOrigin,\n                right,\n                left,\n                currentHorizontalPosition: desiredHorizontalPosition,\n                horizontalSelectedPositionWidth: nextPositionerDimension.width,\n            };\n        };\n        /**\n         * Get vertical positioning state based on desired position\n         */\n        this.getVerticalPositioningState = (desiredVerticalPosition, nextPositionerDimension) => {\n            let top = null;\n            let bottom = null;\n            let yTransformOrigin = \"top\" /* top */;\n            switch (desiredVerticalPosition) {\n                case ViewportPositionerVerticalPositionLabel.top:\n                    yTransformOrigin = \"bottom\" /* bottom */;\n                    bottom =\n                        nextPositionerDimension.height +\n                            this.anchorHeight -\n                            this.baseVerticalOffset;\n                    break;\n                case ViewportPositionerVerticalPositionLabel.insetTop:\n                    yTransformOrigin = \"bottom\" /* bottom */;\n                    bottom = nextPositionerDimension.height - this.baseVerticalOffset;\n                    break;\n                case ViewportPositionerVerticalPositionLabel.insetBottom:\n                    yTransformOrigin = \"top\" /* top */;\n                    top = this.baseVerticalOffset - this.anchorHeight;\n                    break;\n                case ViewportPositionerVerticalPositionLabel.bottom:\n                    yTransformOrigin = \"top\" /* top */;\n                    top = this.baseVerticalOffset;\n                    break;\n            }\n            return {\n                yTransformOrigin,\n                top,\n                bottom,\n                currentVerticalPosition: desiredVerticalPosition,\n                verticalSelectedPositionHeight: nextPositionerDimension.height,\n            };\n        };\n        /**\n         *  Calculate horizontal translation to keep positioner in view\n         */\n        this.getHorizontalTranslate = (horizontalPosition) => {\n            if (!this.props.horizontalAlwaysInView || this.state.disabled) {\n                return 0;\n            }\n            let translate = 0;\n            switch (horizontalPosition) {\n                case ViewportPositionerHorizontalPositionLabel.left:\n                    translate = this.viewportRect.right - this.anchorLeft;\n                    translate = translate < 0 ? translate - 1 : 0;\n                    break;\n                case ViewportPositionerHorizontalPositionLabel.insetLeft:\n                    translate = this.viewportRect.right - this.anchorRight;\n                    translate = translate < 0 ? translate - 1 : 0;\n                    break;\n                case ViewportPositionerHorizontalPositionLabel.insetRight:\n                    translate = this.viewportRect.left - this.anchorLeft;\n                    translate = translate > 0 ? translate + 1 : 0;\n                    break;\n                case ViewportPositionerHorizontalPositionLabel.right:\n                    translate = this.viewportRect.left - this.anchorRight;\n                    translate = translate > 0 ? translate + 1 : 0;\n                    break;\n            }\n            return translate;\n        };\n        /**\n         *  Calculate vertical translation to keep positioner in view\n         */\n        this.getVerticalTranslate = (verticalPosition) => {\n            if (!this.props.verticalAlwaysInView || this.state.disabled) {\n                return 0;\n            }\n            let translate = 0;\n            switch (verticalPosition) {\n                case ViewportPositionerVerticalPositionLabel.top:\n                    translate = this.viewportRect.bottom - this.anchorTop;\n                    translate = translate < 0 ? translate - 1 : 0;\n                    break;\n                case ViewportPositionerVerticalPositionLabel.insetTop:\n                    translate = this.viewportRect.bottom - this.anchorBottom;\n                    translate = translate < 0 ? translate - 1 : 0;\n                    break;\n                case ViewportPositionerVerticalPositionLabel.insetBottom:\n                    translate = this.viewportRect.top - this.anchorTop;\n                    translate = translate < 0 ? 0 : translate + 1;\n                    break;\n                case ViewportPositionerVerticalPositionLabel.bottom:\n                    translate = this.viewportRect.top - this.anchorBottom;\n                    translate = translate < 0 ? 0 : translate + 1;\n                    break;\n            }\n            return translate;\n        };\n        /**\n         * Request's an animation frame if there are currently no open animation frame requests\n         */\n        this.requestFrame = () => {\n            if (this.openRequestAnimationFrame === null) {\n                this.openRequestAnimationFrame = window.requestAnimationFrame(this.updateLayout);\n            }\n        };\n        /**\n         * get the anchor element\n         */\n        this.getAnchorElement = () => {\n            if (isNil(this.props.anchor)) {\n                return null;\n            }\n            return this.extractElementFromRef(this.props.anchor);\n        };\n        /**\n         * get the viewport element, prefer one provided in props, then context, then document root\n         */\n        this.getViewportElement = (viewportRef) => {\n            if (!isNil(viewportRef)) {\n                return this.extractElementFromRef(viewportRef);\n            }\n            if (!isNil(this.context.viewport)) {\n                return this.extractElementFromRef(this.context.viewport);\n            }\n            if (document.scrollingElement instanceof HTMLElement) {\n                return document.scrollingElement;\n            }\n            return null;\n        };\n        /**\n         * returns an html element from a ref\n         */\n        this.extractElementFromRef = (sourceRef) => {\n            if (sourceRef instanceof HTMLElement) {\n                return sourceRef;\n            }\n            if (!isNil(sourceRef.current)) {\n                if (sourceRef.current instanceof HTMLElement) {\n                    return sourceRef.current;\n                }\n                const foundNode = ReactDOM.findDOMNode(sourceRef.current);\n                if (foundNode instanceof HTMLElement) {\n                    return foundNode;\n                }\n            }\n            return null;\n        };\n        /**\n         * Converts simple horizontal position to a position label based on AxisPositioningMode\n         */\n        this.getHorizontalPositionToLabel = (positioningMode, position) => {\n            switch (positioningMode) {\n                case AxisPositioningMode.inset:\n                    if (position === ViewportPositionerHorizontalPosition.left) {\n                        return ViewportPositionerHorizontalPositionLabel.insetLeft;\n                    }\n                    else if (position === ViewportPositionerHorizontalPosition.right) {\n                        return ViewportPositionerHorizontalPositionLabel.insetRight;\n                    }\n                case AxisPositioningMode.adjacent:\n                    if (position === ViewportPositionerHorizontalPosition.left) {\n                        return ViewportPositionerHorizontalPositionLabel.left;\n                    }\n                    else if (position === ViewportPositionerHorizontalPosition.right) {\n                        return ViewportPositionerHorizontalPositionLabel.right;\n                    }\n                case AxisPositioningMode.uncontrolled:\n                    return ViewportPositionerHorizontalPositionLabel.undefined;\n            }\n        };\n        /**\n         * Converts simple vertical position to a position label based on AxisPositioningMode\n         */\n        this.getVerticalPositionToLabel = (positioningMode, position) => {\n            switch (positioningMode) {\n                case AxisPositioningMode.inset:\n                    if (position === ViewportPositionerVerticalPosition.top) {\n                        return ViewportPositionerVerticalPositionLabel.insetTop;\n                    }\n                    else if (position === ViewportPositionerVerticalPosition.bottom) {\n                        return ViewportPositionerVerticalPositionLabel.insetBottom;\n                    }\n                case AxisPositioningMode.adjacent:\n                    if (position === ViewportPositionerVerticalPosition.top) {\n                        return ViewportPositionerVerticalPositionLabel.top;\n                    }\n                    else if (position === ViewportPositionerVerticalPosition.bottom) {\n                        return ViewportPositionerVerticalPositionLabel.bottom;\n                    }\n                case AxisPositioningMode.uncontrolled:\n                    return ViewportPositionerVerticalPositionLabel.undefined;\n            }\n        };\n        /**\n         * Gets the uninitialized state\n         */\n        this.generateInitialState = () => {\n            return {\n                // Note: when the component is initialized or reset we start with a the disabled state set to true.\n                // This gets set to fals during component initialization assuming the disabled prop is not set to true and\n                // that required resources load correctly (ie an invalid anchor or viewport ref could prevent the component\n                // from ever becoming enabled regardless of the disable prop)\n                disabled: true,\n                noObserverMode: false,\n                xTransformOrigin: \"left\" /* left */,\n                yTransformOrigin: \"top\" /* top */,\n                xTranslate: 0,\n                yTranslate: 0,\n                top: null,\n                right: null,\n                bottom: null,\n                left: null,\n                currentHorizontalPosition: ViewportPositionerHorizontalPositionLabel.undefined,\n                currentVerticalPosition: ViewportPositionerVerticalPositionLabel.undefined,\n                defaultHorizontalPosition: this.getHorizontalPositionToLabel(this.props.horizontalPositioningMode, this.props.defaultHorizontalPosition),\n                defaultVerticalPosition: this.getVerticalPositionToLabel(this.props.verticalPositioningMode, this.props.defaultVerticalPosition),\n                horizontalSelectedPositionWidth: null,\n                verticalSelectedPositionHeight: null,\n                initialLayoutComplete: false,\n                validRefChecksRemaining: 2,\n            };\n        };\n        this.state = this.generateInitialState();\n    }\n    componentDidMount() {\n        this.updateDisabledState();\n        this.requestFrame();\n    }\n    componentWillUnmount() {\n        this.disable();\n    }\n    componentDidUpdate(prevProps) {\n        // if anchor or viewport changes the component needs to reset\n        if (prevProps.anchor !== this.props.anchor ||\n            prevProps.viewport !== this.props.viewport) {\n            this.detachListeners(prevProps.viewport);\n            this.setState(this.generateInitialState());\n            return;\n        }\n        if (prevProps.disabled !== this.props.disabled ||\n            this.state.validRefChecksRemaining > 0) {\n            this.updateDisabledState();\n            return;\n        }\n        this.requestFrame();\n    }\n    /**\n     * Renders the component\n     */\n    render() {\n        return (React.createElement(\"div\", Object.assign({}, this.unhandledProps(), { ref: this.rootElement, className: this.generateClassNames(), style: this.getPositioningStyles() }), this.props.children));\n    }\n    /**\n     * Create class-names\n     */\n    generateClassNames() {\n        const { viewportPositioner, viewportPositioner__left, viewportPositioner__right, viewportPositioner__top, viewportPositioner__bottom, viewportPositioner__horizontalInset, viewportPositioner__verticalInset, } = this.props.managedClasses;\n        const horizontalPosition = this.state\n            .currentHorizontalPosition;\n        const verticalPosition = this.state\n            .currentVerticalPosition;\n        const isVerticalInset = verticalPosition === ViewportPositionerVerticalPositionLabel.insetTop ||\n            verticalPosition === ViewportPositionerVerticalPositionLabel.insetBottom;\n        const isHorizontalInset = horizontalPosition === ViewportPositionerHorizontalPositionLabel.insetLeft ||\n            horizontalPosition === ViewportPositionerHorizontalPositionLabel.insetRight;\n        return super.generateClassNames(classNames(viewportPositioner, [\n            viewportPositioner__left,\n            horizontalPosition ===\n                ViewportPositionerHorizontalPositionLabel.left ||\n                horizontalPosition ===\n                    ViewportPositionerHorizontalPositionLabel.insetLeft,\n        ], [\n            viewportPositioner__right,\n            horizontalPosition ===\n                ViewportPositionerHorizontalPositionLabel.right ||\n                horizontalPosition ===\n                    ViewportPositionerHorizontalPositionLabel.insetRight,\n        ], [viewportPositioner__horizontalInset, isHorizontalInset], [\n            viewportPositioner__top,\n            verticalPosition === ViewportPositionerVerticalPositionLabel.top ||\n                verticalPosition ===\n                    ViewportPositionerVerticalPositionLabel.insetTop,\n        ], [\n            viewportPositioner__bottom,\n            verticalPosition === ViewportPositionerVerticalPositionLabel.bottom ||\n                verticalPosition ===\n                    ViewportPositionerVerticalPositionLabel.insetBottom,\n        ], [viewportPositioner__verticalInset, isVerticalInset]));\n    }\n}\nViewportPositioner.displayName = `${DisplayNamePrefix}ViewportPositioner`;\nViewportPositioner.contextType = ViewportContext;\nViewportPositioner.defaultProps = {\n    horizontalPositioningMode: AxisPositioningMode.uncontrolled,\n    defaultHorizontalPosition: ViewportPositionerHorizontalPosition.uncontrolled,\n    verticalPositioningMode: AxisPositioningMode.adjacent,\n    defaultVerticalPosition: ViewportPositionerVerticalPosition.bottom,\n    horizontalAlwaysInView: false,\n    verticalAlwaysInView: false,\n    verticalLockToDefault: false,\n    horizontalLockToDefault: false,\n    fixedAfterInitialPlacement: false,\n    scaleToFit: false,\n    managedClasses: {},\n};\nViewportPositioner.contextType = ViewportContext;\nexport default ViewportPositioner;\nexport * from \"./viewport-positioner.props\";\nexport { ViewportContext };\n"]},"metadata":{},"sourceType":"module"}