{"ast":null,"code":"import _classCallCheck from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport React from \"react\";\nimport { get, isPlainObject, pick, set } from \"lodash-es\";\n/**\n * The foundation component is the component that all fast base components are built on top of. It provides a common\n * set of utilities that each component inherits.\n * @param H - These are the props that are \"handled\". \"handled\" props are not mapped automatically to the root element\n * returned by the render function. Use handled props to expose inputs that will not map directly to DOM attributes\n * (eg a custom callback) or where the DOM attribute would be required.\n * @param U - These are \"unhandled\" props. Any props from this interface will be mapped onto the root DOM node of the\n * render function as-is. It is advised that these props map to valid HTML attributes - otherwise you will likely have HTML errors.\n * @param S - The state interface of the component.\n */\n\nvar Foundation =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Foundation, _React$Component);\n\n  function Foundation() {\n    var _this;\n\n    _classCallCheck(this, Foundation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Foundation).apply(this, arguments));\n    /**\n     * Store all memoized ref callbacks so they can quickly be accessed. Storing the functions\n     * allows us to not create new ref functions every update cycle\n     */\n\n    _this.referenceResolverStore = {};\n    /**\n     * Location where all react element and component references are stored\n     */\n\n    _this.referenceStore = {};\n    return _this;\n  }\n  /**\n   * Stores a react ref callback under the path provided as arguments. Paths are resolved using lodash's get/set API.\n   * The reference object itself will be stored on the referenceStore under the path provided and can be accessed via\n   * the getRef method under the same path.\n   *\n   * Usage: <div ref={this.setRef(\"content-container\")} />\n   */\n\n\n  _createClass(Foundation, [{\n    key: \"setRef\",\n    value: function setRef() {\n      var _this2 = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var storageKey = this.processStorageKey(args);\n      var resolverFunction = get(this.referenceResolverStore, storageKey);\n\n      if (!storageKey || isPlainObject(resolverFunction) || Array.isArray(resolverFunction)) {\n        return;\n      }\n\n      if (typeof resolverFunction === \"function\") {\n        return resolverFunction;\n      } else {\n        resolverFunction = function resolverFunction(ref) {\n          set(_this2.referenceStore, storageKey, ref);\n        };\n\n        set(this.referenceResolverStore, storageKey, resolverFunction);\n        return resolverFunction;\n      }\n    }\n    /**\n     * Get a reference by key , where function arguments are used as to create the keyname,\n     * eg. getRef('foo', 'bar', 0) resolves to this.references.foo.bar[0];\n     *\n     * Usage: const contentContainer = this.getRef(\"content-container\");\n     */\n\n  }, {\n    key: \"getRef\",\n    value: function getRef() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return get(this.referenceStore, this.processStorageKey(args));\n    }\n    /**\n     * Returns an object containing all props that are not enumerated as handledProps\n     */\n\n  }, {\n    key: \"unhandledProps\",\n    value: function unhandledProps() {\n      var _this3 = this;\n\n      var unhandledPropKeys = Object.keys(this.props).filter(function (key) {\n        return !(Foundation.defaultHandledProps.indexOf(key) > -1) && _this3.handledProps && !_this3.handledProps.hasOwnProperty(key);\n      });\n      return pick(this.props, unhandledPropKeys);\n    }\n    /**\n     * Joins any string with the className prop passed to the component. Used for applying a className to the root\n     * element of a component's render function.\n     */\n\n  }, {\n    key: \"generateClassNames\",\n    value: function generateClassNames() {\n      var componentClasses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      return componentClasses.concat(\" \".concat(this.props.className || \"\")).trim().replace(/(\\s){2,}/g, \" \") || null;\n    }\n    /*\n     * Return an array of all nodes who's slot prop matches the provided slot.\n     * If no nodes are provided, `this.props.children` will be used\n     */\n\n  }, {\n    key: \"withSlot\",\n    value: function withSlot(slot) {\n      var _this4 = this;\n\n      var nodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.children;\n      return React.Children.map(nodes, function (node) {\n        return _this4.hasSlot(slot, node) ? node : null;\n      });\n    }\n  }, {\n    key: \"withoutSlot\",\n    value: function withoutSlot(slot) {\n      var _this5 = this;\n\n      var nodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.children;\n      return React.Children.map(nodes, function (node) {\n        return !_this5.hasSlot(slot, node) ? node : null;\n      });\n    }\n    /**\n     * Determine if a single node has a slot property\n     */\n\n  }, {\n    key: \"hasSlot\",\n    value: function hasSlot(slot, node) {\n      var nodeSlot = get(node, \"props.slot\");\n      return Array.isArray(slot) ? slot.indexOf(nodeSlot) !== -1 : slot === nodeSlot;\n    }\n    /**\n     * Generates a string that conforms to object/array accessor syntax that can be used by lodash's get / set,\n     * eg. => [\"foo\", \"bar\", 0] => \"foo[bar][0]\"\n     */\n\n  }, {\n    key: \"processStorageKey\",\n    value: function processStorageKey(args) {\n      return args.filter(function (item) {\n        return typeof item === \"string\" || typeof item === \"number\";\n      }).map(function (item, index) {\n        return index === 0 ? item : \"[\".concat(item, \"]\");\n      }).join(\"\");\n    }\n  }]);\n\n  return Foundation;\n}(React.Component);\n/**\n * The props that should never be passed to the root element by unhandled props\n */\n\n\nFoundation.defaultHandledProps = [\"children\"];\nexport default Foundation;","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-foundation-react/dist/foundation/foundation.js"],"names":["React","get","isPlainObject","pick","set","Foundation","arguments","referenceResolverStore","referenceStore","args","storageKey","processStorageKey","resolverFunction","Array","isArray","ref","unhandledPropKeys","Object","keys","props","filter","key","defaultHandledProps","indexOf","handledProps","hasOwnProperty","componentClasses","concat","className","trim","replace","slot","nodes","children","Children","map","node","hasSlot","nodeSlot","item","index","join","Component"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { get, isPlainObject, pick, set } from \"lodash-es\";\n/**\n * The foundation component is the component that all fast base components are built on top of. It provides a common\n * set of utilities that each component inherits.\n * @param H - These are the props that are \"handled\". \"handled\" props are not mapped automatically to the root element\n * returned by the render function. Use handled props to expose inputs that will not map directly to DOM attributes\n * (eg a custom callback) or where the DOM attribute would be required.\n * @param U - These are \"unhandled\" props. Any props from this interface will be mapped onto the root DOM node of the\n * render function as-is. It is advised that these props map to valid HTML attributes - otherwise you will likely have HTML errors.\n * @param S - The state interface of the component.\n */\nclass Foundation extends React.Component {\n    constructor() {\n        super(...arguments);\n        /**\n         * Store all memoized ref callbacks so they can quickly be accessed. Storing the functions\n         * allows us to not create new ref functions every update cycle\n         */\n        this.referenceResolverStore = {};\n        /**\n         * Location where all react element and component references are stored\n         */\n        this.referenceStore = {};\n    }\n    /**\n     * Stores a react ref callback under the path provided as arguments. Paths are resolved using lodash's get/set API.\n     * The reference object itself will be stored on the referenceStore under the path provided and can be accessed via\n     * the getRef method under the same path.\n     *\n     * Usage: <div ref={this.setRef(\"content-container\")} />\n     */\n    setRef(...args) {\n        const storageKey = this.processStorageKey(args);\n        let resolverFunction = get(this.referenceResolverStore, storageKey);\n        if (!storageKey ||\n            isPlainObject(resolverFunction) ||\n            Array.isArray(resolverFunction)) {\n            return;\n        }\n        if (typeof resolverFunction === \"function\") {\n            return resolverFunction;\n        }\n        else {\n            resolverFunction = (ref) => {\n                set(this.referenceStore, storageKey, ref);\n            };\n            set(this.referenceResolverStore, storageKey, resolverFunction);\n            return resolverFunction;\n        }\n    }\n    /**\n     * Get a reference by key , where function arguments are used as to create the keyname,\n     * eg. getRef('foo', 'bar', 0) resolves to this.references.foo.bar[0];\n     *\n     * Usage: const contentContainer = this.getRef(\"content-container\");\n     */\n    getRef(...args) {\n        return get(this.referenceStore, this.processStorageKey(args));\n    }\n    /**\n     * Returns an object containing all props that are not enumerated as handledProps\n     */\n    unhandledProps() {\n        const unhandledPropKeys = Object.keys(this.props).filter((key) => {\n            return (!(Foundation.defaultHandledProps.indexOf(key) > -1) &&\n                (this.handledProps && !this.handledProps.hasOwnProperty(key)));\n        });\n        return pick(this.props, unhandledPropKeys);\n    }\n    /**\n     * Joins any string with the className prop passed to the component. Used for applying a className to the root\n     * element of a component's render function.\n     */\n    generateClassNames(componentClasses = \"\") {\n        return (componentClasses\n            .concat(` ${this.props.className || \"\"}`)\n            .trim()\n            .replace(/(\\s){2,}/g, \" \") || null);\n    }\n    /*\n     * Return an array of all nodes who's slot prop matches the provided slot.\n     * If no nodes are provided, `this.props.children` will be used\n     */\n    withSlot(slot, nodes = this.props.children) {\n        return React.Children.map(nodes, (node) => {\n            return this.hasSlot(slot, node) ? node : null;\n        });\n    }\n    withoutSlot(slot, nodes = this.props.children) {\n        return React.Children.map(nodes, (node) => {\n            return !this.hasSlot(slot, node) ? node : null;\n        });\n    }\n    /**\n     * Determine if a single node has a slot property\n     */\n    hasSlot(slot, node) {\n        const nodeSlot = get(node, \"props.slot\");\n        return Array.isArray(slot) ? slot.indexOf(nodeSlot) !== -1 : slot === nodeSlot;\n    }\n    /**\n     * Generates a string that conforms to object/array accessor syntax that can be used by lodash's get / set,\n     * eg. => [\"foo\", \"bar\", 0] => \"foo[bar][0]\"\n     */\n    processStorageKey(args) {\n        return args\n            .filter((item) => {\n            return typeof item === \"string\" || typeof item === \"number\";\n        })\n            .map((item, index) => {\n            return index === 0 ? item : `[${item}]`;\n        })\n            .join(\"\");\n    }\n}\n/**\n * The props that should never be passed to the root element by unhandled props\n */\nFoundation.defaultHandledProps = [\"children\"];\nexport default Foundation;\n"]},"metadata":{},"sourceType":"module"}