{"ast":null,"code":"import { canUseDOM } from \"exenv-es6\";\nimport { isBoolean } from \"lodash-es\";\n/**\n * A test that ensures that all arguments are HTML Elements\n */\n\nexport function isHTMLElement() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return args.every(function (arg) {\n    return arg instanceof HTMLElement;\n  });\n}\n/**\n * Returns all displayed elements inside of a root node that match a provided selector\n */\n\nexport function getDisplayedNodes(rootNode, selector) {\n  if (!isHTMLElement(rootNode)) {\n    return;\n  }\n\n  var nodes = Array.from(rootNode.querySelectorAll(selector)); // offsetParent will be null if the element isn't currently displayed,\n  // so this will allow us to operate only on visible nodes\n\n  return nodes.filter(function (node) {\n    return node.offsetParent !== null;\n  });\n}\n/**\n * Gets the numeric key code associated with a keyboard event. This method is for use with DOM level 3 events\n * that still use the deprecated keyCode property.\n */\n\nexport function getKeyCode(event) {\n  return event === null ? null : event.which || event.keyCode || event.charCode;\n}\n/**\n * Test if the document supports :focus-visible\n */\n\nvar _canUseFocusVisible;\n\nexport function canUseFocusVisible() {\n  if (isBoolean(_canUseFocusVisible)) {\n    return _canUseFocusVisible;\n  }\n\n  if (!canUseDOM()) {\n    _canUseFocusVisible = false;\n    return _canUseFocusVisible;\n  } // Check to see if the document supports the focus-visible element\n\n\n  var styleElement = document.createElement(\"style\");\n  document.head.appendChild(styleElement);\n\n  try {\n    styleElement.sheet.insertRule(\"foo:focus-visible {color:inherit}\", 0);\n    _canUseFocusVisible = true;\n  } catch (e) {\n    _canUseFocusVisible = false;\n  } finally {\n    document.head.removeChild(styleElement);\n  }\n\n  return _canUseFocusVisible;\n}\n\nvar _canUseCssGrid;\n\nexport function canUseCssGrid() {\n  if (isBoolean(_canUseCssGrid)) {\n    return _canUseCssGrid;\n  }\n\n  try {\n    _canUseCssGrid = CSS.supports(\"display\", \"grid\");\n  } catch (_a) {\n    _canUseCssGrid = false;\n  }\n\n  return _canUseCssGrid;\n}\nexport function canUseForcedColors() {\n  return canUseDOM() && (window.matchMedia(\"(forced-colors: none)\").matches || window.matchMedia(\"(forced-colors: active)\").matches);\n}\n/**\n * @deprecated Use 'canUseForcedColors' instead\n */\n\nexport var canUsedForcedColors = canUseForcedColors;","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-web-utilities/dist/dom.js"],"names":["canUseDOM","isBoolean","isHTMLElement","args","every","arg","HTMLElement","getDisplayedNodes","rootNode","selector","nodes","Array","from","querySelectorAll","filter","node","offsetParent","getKeyCode","event","which","keyCode","charCode","_canUseFocusVisible","canUseFocusVisible","styleElement","document","createElement","head","appendChild","sheet","insertRule","e","removeChild","_canUseCssGrid","canUseCssGrid","CSS","supports","_a","canUseForcedColors","window","matchMedia","matches","canUsedForcedColors"],"mappings":"AAAA,SAASA,SAAT,QAA0B,WAA1B;AACA,SAASC,SAAT,QAA0B,WAA1B;AACA;;;;AAGA,OAAO,SAASC,aAAT,GAAgC;AAAA,oCAANC,IAAM;AAANA,IAAAA,IAAM;AAAA;;AACnC,SAAOA,IAAI,CAACC,KAAL,CAAW,UAACC,GAAD;AAAA,WAASA,GAAG,YAAYC,WAAxB;AAAA,GAAX,CAAP;AACH;AACD;;;;AAGA,OAAO,SAASC,iBAAT,CAA2BC,QAA3B,EAAqCC,QAArC,EAA+C;AAClD,MAAI,CAACP,aAAa,CAACM,QAAD,CAAlB,EAA8B;AAC1B;AACH;;AACD,MAAME,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAWJ,QAAQ,CAACK,gBAAT,CAA0BJ,QAA1B,CAAX,CAAd,CAJkD,CAKlD;AACA;;AACA,SAAOC,KAAK,CAACI,MAAN,CAAa,UAACC,IAAD;AAAA,WAAUA,IAAI,CAACC,YAAL,KAAsB,IAAhC;AAAA,GAAb,CAAP;AACH;AACD;;;;;AAIA,OAAO,SAASC,UAAT,CAAoBC,KAApB,EAA2B;AAC9B,SAAOA,KAAK,KAAK,IAAV,GAAiB,IAAjB,GAAwBA,KAAK,CAACC,KAAN,IAAeD,KAAK,CAACE,OAArB,IAAgCF,KAAK,CAACG,QAArE;AACH;AACD;;;;AAGA,IAAIC,mBAAJ;;AACA,OAAO,SAASC,kBAAT,GAA8B;AACjC,MAAItB,SAAS,CAACqB,mBAAD,CAAb,EAAoC;AAChC,WAAOA,mBAAP;AACH;;AACD,MAAI,CAACtB,SAAS,EAAd,EAAkB;AACdsB,IAAAA,mBAAmB,GAAG,KAAtB;AACA,WAAOA,mBAAP;AACH,GAPgC,CAQjC;;;AACA,MAAME,YAAY,GAAGC,QAAQ,CAACC,aAAT,CAAuB,OAAvB,CAArB;AACAD,EAAAA,QAAQ,CAACE,IAAT,CAAcC,WAAd,CAA0BJ,YAA1B;;AACA,MAAI;AACAA,IAAAA,YAAY,CAACK,KAAb,CAAmBC,UAAnB,CAA8B,mCAA9B,EAAmE,CAAnE;AACAR,IAAAA,mBAAmB,GAAG,IAAtB;AACH,GAHD,CAIA,OAAOS,CAAP,EAAU;AACNT,IAAAA,mBAAmB,GAAG,KAAtB;AACH,GAND,SAOQ;AACJG,IAAAA,QAAQ,CAACE,IAAT,CAAcK,WAAd,CAA0BR,YAA1B;AACH;;AACD,SAAOF,mBAAP;AACH;;AACD,IAAIW,cAAJ;;AACA,OAAO,SAASC,aAAT,GAAyB;AAC5B,MAAIjC,SAAS,CAACgC,cAAD,CAAb,EAA+B;AAC3B,WAAOA,cAAP;AACH;;AACD,MAAI;AACAA,IAAAA,cAAc,GAAGE,GAAG,CAACC,QAAJ,CAAa,SAAb,EAAwB,MAAxB,CAAjB;AACH,GAFD,CAGA,OAAOC,EAAP,EAAW;AACPJ,IAAAA,cAAc,GAAG,KAAjB;AACH;;AACD,SAAOA,cAAP;AACH;AACD,OAAO,SAASK,kBAAT,GAA8B;AACjC,SAAQtC,SAAS,OACZuC,MAAM,CAACC,UAAP,CAAkB,uBAAlB,EAA2CC,OAA3C,IACGF,MAAM,CAACC,UAAP,CAAkB,yBAAlB,EAA6CC,OAFpC,CAAjB;AAGH;AACD;;;;AAGA,OAAO,IAAMC,mBAAmB,GAAGJ,kBAA5B","sourcesContent":["import { canUseDOM } from \"exenv-es6\";\nimport { isBoolean } from \"lodash-es\";\n/**\n * A test that ensures that all arguments are HTML Elements\n */\nexport function isHTMLElement(...args) {\n    return args.every((arg) => arg instanceof HTMLElement);\n}\n/**\n * Returns all displayed elements inside of a root node that match a provided selector\n */\nexport function getDisplayedNodes(rootNode, selector) {\n    if (!isHTMLElement(rootNode)) {\n        return;\n    }\n    const nodes = Array.from(rootNode.querySelectorAll(selector));\n    // offsetParent will be null if the element isn't currently displayed,\n    // so this will allow us to operate only on visible nodes\n    return nodes.filter((node) => node.offsetParent !== null);\n}\n/**\n * Gets the numeric key code associated with a keyboard event. This method is for use with DOM level 3 events\n * that still use the deprecated keyCode property.\n */\nexport function getKeyCode(event) {\n    return event === null ? null : event.which || event.keyCode || event.charCode;\n}\n/**\n * Test if the document supports :focus-visible\n */\nlet _canUseFocusVisible;\nexport function canUseFocusVisible() {\n    if (isBoolean(_canUseFocusVisible)) {\n        return _canUseFocusVisible;\n    }\n    if (!canUseDOM()) {\n        _canUseFocusVisible = false;\n        return _canUseFocusVisible;\n    }\n    // Check to see if the document supports the focus-visible element\n    const styleElement = document.createElement(\"style\");\n    document.head.appendChild(styleElement);\n    try {\n        styleElement.sheet.insertRule(\"foo:focus-visible {color:inherit}\", 0);\n        _canUseFocusVisible = true;\n    }\n    catch (e) {\n        _canUseFocusVisible = false;\n    }\n    finally {\n        document.head.removeChild(styleElement);\n    }\n    return _canUseFocusVisible;\n}\nlet _canUseCssGrid;\nexport function canUseCssGrid() {\n    if (isBoolean(_canUseCssGrid)) {\n        return _canUseCssGrid;\n    }\n    try {\n        _canUseCssGrid = CSS.supports(\"display\", \"grid\");\n    }\n    catch (_a) {\n        _canUseCssGrid = false;\n    }\n    return _canUseCssGrid;\n}\nexport function canUseForcedColors() {\n    return (canUseDOM() &&\n        (window.matchMedia(\"(forced-colors: none)\").matches ||\n            window.matchMedia(\"(forced-colors: active)\").matches));\n}\n/**\n * @deprecated Use 'canUseForcedColors' instead\n */\nexport const canUsedForcedColors = canUseForcedColors;\n"]},"metadata":{},"sourceType":"module"}