{"ast":null,"code":"import _possibleConstructorReturn from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport React from \"react\";\nimport Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames, getDisplayedNodes, isHTMLElement, keyCodeEnd, keyCodeHome } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { DisplayNamePrefix } from \"../utilities\";\nexport var TreeViewContext = React.createContext({\n  setLastFocused: null,\n  adjustNestedTreeItemCount: null,\n  nested: false\n});\n/**\n * Simple state machine to track how many nodes have nested nodes\n */\n\nvar ChildNodeCountTracker =\n/*#__PURE__*/\nfunction () {\n  function ChildNodeCountTracker() {\n    _classCallCheck(this, ChildNodeCountTracker);\n\n    this._count = 0;\n  }\n\n  _createClass(ChildNodeCountTracker, [{\n    key: \"adjust\",\n    value: function adjust(delta) {\n      this._count += delta;\n    }\n  }, {\n    key: \"count\",\n    get: function get() {\n      return this._count;\n    }\n  }]);\n\n  return ChildNodeCountTracker;\n}();\n/* tslint:disable-next-line */\n\n\nvar TreeView =\n/*#__PURE__*/\nfunction (_Foundation) {\n  _inherits(TreeView, _Foundation);\n\n  function TreeView(props) {\n    var _this;\n\n    _classCallCheck(this, TreeView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TreeView).call(this, props));\n    _this.handledProps = {\n      managedClasses: void 0,\n      children: void 0\n    };\n    _this.rootElement = React.createRef();\n    /**\n     * Track how many tree-items have children\n     */\n\n    _this.nestedTreeItemTracker = new ChildNodeCountTracker();\n\n    _this.setLastFocused = function (ref) {\n      _this.setState({\n        lastFocused: ref\n      });\n    };\n\n    _this.adjustNestedTreeItemCount = function (delta) {\n      _this.nestedTreeItemTracker.adjust(delta);\n\n      if (_this.nestedTreeItemTracker.count > 0 && !_this.state.nested) {\n        _this.setState({\n          nested: true\n        });\n      } else if (_this.nestedTreeItemTracker.count === 0 && _this.state.nested) {\n        _this.setState({\n          nested: false\n        });\n      }\n    };\n\n    _this.handleBlur = function (e) {\n      var root = _this.rootElement.current;\n      /**\n       * If we focus outside of the tree\n       */\n\n      if (isHTMLElement(root) && !root.contains(e.relatedTarget)) {\n        _this.setState({\n          focusable: true\n        });\n      }\n    };\n\n    _this.handleFocus = function (e) {\n      if (!canUseDOM() || !isHTMLElement(_this.rootElement.current)) {\n        return;\n      }\n\n      var root = _this.rootElement.current;\n      var lastFocused = _this.state.lastFocused;\n      /**\n       * If the tree view is receiving focus\n       */\n\n      if (isHTMLElement(root) && root === e.target) {\n        // If we have a last focused item, focus it - otherwise check for an initially selected item or focus the first \"[role='treeitem']\"\n        // If there is no \"[role='treeitem']\" to be focused AND no last-focused, then there are likely no children\n        // or children are malformed so keep the tree in the tab-order in the hopes that the author cleans up\n        // the children\n        var selectedChild = root.querySelector(\"[aria-selected='true']\");\n        var toBeFocused = !!lastFocused ? lastFocused.current : !!selectedChild ? selectedChild : root.querySelector(\"[role='treeitem']\");\n\n        if (isHTMLElement(toBeFocused)) {\n          toBeFocused.focus();\n\n          if (_this.state.focusable) {\n            _this.setState({\n              focusable: false\n            });\n          }\n        }\n      } else {\n        // A child is receiving focus. While focus is within the tree, we simply need to ensure\n        // that the tree is not focusable.\n        if (_this.state.focusable) {\n          _this.setState({\n            focusable: false\n          });\n        }\n      }\n    };\n\n    _this.handleKeyDown = function (e) {\n      var nodes;\n\n      if (canUseDOM()) {\n        switch (e.keyCode) {\n          case keyCodeHome:\n            nodes = _this.getVisibleNodes();\n\n            if (nodes && nodes.length) {\n              nodes[0].focus();\n            }\n\n            break;\n\n          case keyCodeEnd:\n            nodes = _this.getVisibleNodes();\n\n            if (nodes && nodes.length) {\n              nodes[nodes.length - 1].focus();\n            }\n\n            break;\n        }\n      }\n    };\n\n    _this.state = {\n      focusable: true,\n      lastFocused: null,\n      nested: false\n    };\n    return _this;\n  }\n\n  _createClass(TreeView, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", Object.assign({}, this.unhandledProps(), {\n        role: \"tree\",\n        tabIndex: this.state.focusable ? 0 : -1,\n        className: this.generateClassNames(),\n        ref: this.rootElement,\n        onFocus: this.handleFocus,\n        onBlur: this.handleBlur,\n        onKeyDown: this.handleKeyDown\n      }), React.createElement(TreeViewContext.Provider, {\n        value: {\n          setLastFocused: this.setLastFocused,\n          adjustNestedTreeItemCount: this.adjustNestedTreeItemCount,\n          nested: this.state.nested\n        }\n      }, this.props.children));\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.ensureFocusability();\n    }\n  }, {\n    key: \"generateClassNames\",\n    value: function generateClassNames() {\n      return _get(_getPrototypeOf(TreeView.prototype), \"generateClassNames\", this).call(this, classNames(this.props.managedClasses.treeView));\n    }\n    /**\n     * Verifies that the tree has a focusable child.\n     * If it does not, the tree will begin to accept focus\n     */\n\n  }, {\n    key: \"ensureFocusability\",\n    value: function ensureFocusability() {\n      if (canUseDOM() && !this.state.focusable && isHTMLElement(this.rootElement.current)) {\n        var focusableChild = this.rootElement.current.querySelector(\"[role='treeitem'][tabindex='0']\");\n\n        if (!isHTMLElement(focusableChild)) {\n          this.setState({\n            focusable: true\n          });\n        }\n      }\n    }\n  }, {\n    key: \"getVisibleNodes\",\n    value: function getVisibleNodes() {\n      return canUseDOM() ? getDisplayedNodes(this.rootElement.current, \"[role='treeitem']\") : [];\n    }\n  }]);\n\n  return TreeView;\n}(Foundation);\n\nTreeView.displayName = \"\".concat(DisplayNamePrefix, \"TreeView\");\nTreeView.defaultProps = {\n  managedClasses: {}\n};\nexport default TreeView;","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-react-base/dist/tree-view/tree-view.js"],"names":["React","Foundation","classNames","getDisplayedNodes","isHTMLElement","keyCodeEnd","keyCodeHome","canUseDOM","DisplayNamePrefix","TreeViewContext","createContext","setLastFocused","adjustNestedTreeItemCount","nested","ChildNodeCountTracker","_count","delta","TreeView","props","handledProps","managedClasses","children","rootElement","createRef","nestedTreeItemTracker","ref","setState","lastFocused","adjust","count","state","handleBlur","e","root","current","contains","relatedTarget","focusable","handleFocus","target","selectedChild","querySelector","toBeFocused","focus","handleKeyDown","nodes","keyCode","getVisibleNodes","length","createElement","Object","assign","unhandledProps","role","tabIndex","className","generateClassNames","onFocus","onBlur","onKeyDown","Provider","value","ensureFocusability","treeView","focusableChild","displayName","defaultProps"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames, getDisplayedNodes, isHTMLElement, keyCodeEnd, keyCodeHome, } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { DisplayNamePrefix } from \"../utilities\";\nexport const TreeViewContext = React.createContext({\n    setLastFocused: null,\n    adjustNestedTreeItemCount: null,\n    nested: false,\n});\n/**\n * Simple state machine to track how many nodes have nested nodes\n */\nclass ChildNodeCountTracker {\n    constructor() {\n        this._count = 0;\n    }\n    get count() {\n        return this._count;\n    }\n    adjust(delta) {\n        this._count += delta;\n    }\n}\n/* tslint:disable-next-line */\nclass TreeView extends Foundation {\n    constructor(props) {\n        super(props);\n        this.handledProps = {\n            managedClasses: void 0,\n            children: void 0,\n        };\n        this.rootElement = React.createRef();\n        /**\n         * Track how many tree-items have children\n         */\n        this.nestedTreeItemTracker = new ChildNodeCountTracker();\n        this.setLastFocused = (ref) => {\n            this.setState({\n                lastFocused: ref,\n            });\n        };\n        this.adjustNestedTreeItemCount = (delta) => {\n            this.nestedTreeItemTracker.adjust(delta);\n            if (this.nestedTreeItemTracker.count > 0 && !this.state.nested) {\n                this.setState({ nested: true });\n            }\n            else if (this.nestedTreeItemTracker.count === 0 && this.state.nested) {\n                this.setState({ nested: false });\n            }\n        };\n        this.handleBlur = (e) => {\n            const root = this.rootElement.current;\n            /**\n             * If we focus outside of the tree\n             */\n            if (isHTMLElement(root) && !root.contains(e.relatedTarget)) {\n                this.setState({\n                    focusable: true,\n                });\n            }\n        };\n        this.handleFocus = (e) => {\n            if (!canUseDOM() || !isHTMLElement(this.rootElement.current)) {\n                return;\n            }\n            const root = this.rootElement.current;\n            const lastFocused = this.state\n                .lastFocused;\n            /**\n             * If the tree view is receiving focus\n             */\n            if (isHTMLElement(root) && root === e.target) {\n                // If we have a last focused item, focus it - otherwise check for an initially selected item or focus the first \"[role='treeitem']\"\n                // If there is no \"[role='treeitem']\" to be focused AND no last-focused, then there are likely no children\n                // or children are malformed so keep the tree in the tab-order in the hopes that the author cleans up\n                // the children\n                const selectedChild = root.querySelector(\"[aria-selected='true']\");\n                const toBeFocused = !!lastFocused\n                    ? lastFocused.current\n                    : !!selectedChild\n                        ? selectedChild\n                        : root.querySelector(\"[role='treeitem']\");\n                if (isHTMLElement(toBeFocused)) {\n                    toBeFocused.focus();\n                    if (this.state.focusable) {\n                        this.setState({ focusable: false });\n                    }\n                }\n            }\n            else {\n                // A child is receiving focus. While focus is within the tree, we simply need to ensure\n                // that the tree is not focusable.\n                if (this.state.focusable) {\n                    this.setState({\n                        focusable: false,\n                    });\n                }\n            }\n        };\n        this.handleKeyDown = (e) => {\n            let nodes;\n            if (canUseDOM()) {\n                switch (e.keyCode) {\n                    case keyCodeHome:\n                        nodes = this.getVisibleNodes();\n                        if (nodes && nodes.length) {\n                            nodes[0].focus();\n                        }\n                        break;\n                    case keyCodeEnd:\n                        nodes = this.getVisibleNodes();\n                        if (nodes && nodes.length) {\n                            nodes[nodes.length - 1].focus();\n                        }\n                        break;\n                }\n            }\n        };\n        this.state = {\n            focusable: true,\n            lastFocused: null,\n            nested: false,\n        };\n    }\n    render() {\n        return (React.createElement(\"div\", Object.assign({}, this.unhandledProps(), { role: \"tree\", tabIndex: this.state.focusable ? 0 : -1, className: this.generateClassNames(), ref: this.rootElement, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown }),\n            React.createElement(TreeViewContext.Provider, { value: {\n                    setLastFocused: this.setLastFocused,\n                    adjustNestedTreeItemCount: this.adjustNestedTreeItemCount,\n                    nested: this.state.nested,\n                } }, this.props.children)));\n    }\n    componentDidUpdate() {\n        this.ensureFocusability();\n    }\n    generateClassNames() {\n        return super.generateClassNames(classNames(this.props.managedClasses.treeView));\n    }\n    /**\n     * Verifies that the tree has a focusable child.\n     * If it does not, the tree will begin to accept focus\n     */\n    ensureFocusability() {\n        if (canUseDOM() &&\n            !this.state.focusable &&\n            isHTMLElement(this.rootElement.current)) {\n            const focusableChild = this.rootElement.current.querySelector(\"[role='treeitem'][tabindex='0']\");\n            if (!isHTMLElement(focusableChild)) {\n                this.setState({\n                    focusable: true,\n                });\n            }\n        }\n    }\n    getVisibleNodes() {\n        return canUseDOM()\n            ? getDisplayedNodes(this.rootElement.current, \"[role='treeitem']\")\n            : [];\n    }\n}\nTreeView.displayName = `${DisplayNamePrefix}TreeView`;\nTreeView.defaultProps = {\n    managedClasses: {},\n};\nexport default TreeView;\n"]},"metadata":{},"sourceType":"module"}