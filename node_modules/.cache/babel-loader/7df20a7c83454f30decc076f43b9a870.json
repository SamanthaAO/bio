{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Animation mode describes if an animation should animate toward an elements natural position or away from it\n */\n\nvar AnimationMode;\n\n(function (AnimationMode) {\n  AnimationMode[AnimationMode[\"animateTo\"] = 0] = \"animateTo\";\n  AnimationMode[AnimationMode[\"animateFrom\"] = 1] = \"animateFrom\";\n})(AnimationMode = exports.AnimationMode || (exports.AnimationMode = {}));\n\nvar Animate =\n/** @class */\nfunction () {\n  function Animate(element, options, effectTiming) {\n    var _this = this;\n    /**\n     * Stores animation timing functions\n     */\n\n\n    this.effectTiming = {\n      fill: \"forwards\",\n      iterations: 1,\n      duration: 500\n    };\n    /**\n     * Stores animation keyframe sets and is accessed by a getter\n     */\n\n    this._keyframes = [];\n    /**\n     * plays the animation\n     */\n\n    this.play = function () {\n      _this.ensureAnimationObjectExists();\n\n      _this.animation.play();\n    };\n    /**\n     * pauses the animation\n     */\n\n\n    this.pause = function () {\n      _this.ensureAnimationObjectExists();\n\n      _this.animation.pause();\n    };\n    /**\n     * finishes the animation\n     */\n\n\n    this.finish = function () {\n      _this.ensureAnimationObjectExists();\n\n      _this.animation.finish();\n    };\n    /**\n     * cancels the animation\n     */\n\n\n    this.cancel = function () {\n      _this.ensureAnimationObjectExists();\n\n      _this.animation.cancel();\n    };\n    /**\n     * reverses an animation\n     */\n\n\n    this.reverse = function () {\n      _this.ensureAnimationObjectExists();\n\n      _this.animation.reverse();\n    };\n    /**\n     * adds a set of keyframes to set of animation keyframes the animation should execute\n     */\n\n\n    this.addKeyframes = function (keyframes) {\n      _this._keyframes.push(keyframes);\n    };\n\n    this.animationTarget = element;\n\n    if (Boolean(effectTiming)) {\n      this.effectTiming = Object.assign({}, this.effectTiming, effectTiming);\n    }\n\n    if (options) {\n      if (options.transformOrigin) {\n        element.style.transformOrigin = options.transformOrigin;\n      }\n\n      if (options.transformStyle) {\n        element.style.transformStyle = options.transformStyle;\n      }\n    }\n\n    this.options = options || {};\n  }\n\n  Object.defineProperty(Animate.prototype, \"onFinish\", {\n    get: function () {\n      return this._onFinish;\n    },\n    set: function (callback) {\n      this._onFinish = callback;\n\n      if (Boolean(this.animation)) {\n        this.animation.onfinish = callback;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Ensure animation object\n   */\n\n  Animate.prototype.ensureAnimationObjectExists = function () {\n    if (typeof this.animation === \"undefined\") {\n      this.createAnimationObject();\n    }\n  };\n  /**\n   * Creates the animation object\n   */\n\n\n  Animate.prototype.createAnimationObject = function () {\n    this.animation = new Animation(this.keyframeEffect, document.timeline);\n\n    if (typeof this.onFinish !== \"undefined\") {\n      this.animation.onfinish = this.onFinish;\n    }\n\n    if (typeof this.onCancel !== \"undefined\") {\n      this.animation.oncancel = this.onCancel;\n    }\n  };\n  /**\n   * Returns a list of properties that will be animated based options\n   */\n\n\n  Animate.prototype.getPropertiesToAnimate = function () {\n    var _this = this;\n\n    return Object.keys(Animate.propertyMap).filter(function (property) {\n      // Filter out all properties that don't need to be set based on our options\n      return Animate.propertyMap[property].reduce(function (hasProperty, animationProp) {\n        return typeof _this.options[animationProp] !== \"undefined\" || hasProperty;\n      }, false);\n    });\n  };\n  /**\n   * Current implmentations of web animations seem to have trouble animating both scale and opacity\n   * from a starting value of 0. This method detects when those values are 0 and alters them slightly\n   * to known-working starting values\n   */\n\n\n  Animate.prototype.normalizeInitialValue = function (property, value) {\n    if (value === undefined) {\n      return;\n    }\n\n    var coercedReturn = \"0.01\";\n\n    switch (property) {\n      case \"transform\":\n        var matrixValuesRegex = /matrix\\((.+)\\)/;\n        var matrixValues = value.match(matrixValuesRegex);\n\n        if (Array.isArray(matrixValues)) {\n          var normalizedValues = matrixValues[1].split(\",\").map(function (matchedValue, index) {\n            var parsedValueIsZero = parseFloat(value) === 0;\n\n            if (!parsedValueIsZero) {\n              return matchedValue;\n            } // If this is the scaleX index or the scaleY index, return the coerced value\n\n\n            return index === 0 || index === 3 ? coercedReturn : matchedValue;\n          });\n          return \"matrix(\" + normalizedValues.join(\",\") + \")\";\n        }\n\n        break;\n\n      case \"opacity\":\n        return parseFloat(value) === 0 ? coercedReturn : value;\n    }\n\n    return value;\n  };\n  /**\n   * Returns the initial values for all properties being animated\n   */\n\n\n  Animate.prototype.getInitialKeyframeValues = function () {\n    var _this = this;\n\n    if (!(this.animationTarget instanceof HTMLElement) || typeof window === \"undefined\") {\n      return {};\n    }\n\n    var animatedProperties = this.getPropertiesToAnimate();\n    var computedStyle = window.getComputedStyle(this.animationTarget);\n    var initialKeyframeValues = {};\n    animatedProperties.forEach(function (property) {\n      initialKeyframeValues[property] = _this.normalizeInitialValue(property, computedStyle[property]);\n    });\n    return initialKeyframeValues;\n  };\n  /**\n   * Formats a config option into a transform function\n   */\n\n\n  Animate.prototype.formatTransformFunction = function (functionType, value) {\n    // If `functionType` can't be converted into a transform function, just return empty string\n    if (Animate.propertyMap.transform.indexOf(functionType) === -1) {\n      return \"\";\n    }\n\n    switch (functionType) {\n      case \"x\":\n      case \"y\":\n        functionType = \"translate\" + functionType.toUpperCase();\n        value = typeof value === \"number\" ? value = this.pixelify(value) : value;\n        break;\n\n      case \"rotate\":\n        value = value.toString() + \"deg\";\n        break;\n\n      case \"scale\":\n        if (value === 0) {\n          // There is a strange bug where you can't animate from a scale 0\n          value = 0.01;\n        }\n\n    }\n\n    if (typeof value !== \"string\") {\n      value = value.toString();\n    }\n\n    return functionType + \"(\" + value + \")\";\n  };\n  /**\n   * Converts a number to a pixel string\n   */\n\n\n  Animate.prototype.pixelify = function (num) {\n    return num + \"px\";\n  };\n  /**\n   * Returns keyframe values based on option configuration\n   */\n\n\n  Animate.prototype.getOptionKeyframeValues = function () {\n    var _this = this;\n\n    var animateProperties = this.getPropertiesToAnimate();\n    var keyframeValues = {};\n    animateProperties.forEach(function (property) {\n      keyframeValues[property] = Animate.propertyMap[property].map(function (option) {\n        var value = _this.options[option];\n\n        if (typeof value === \"undefined\") {\n          return null;\n        }\n\n        switch (option) {\n          case \"opacity\":\n            return value.toString();\n\n          case \"top\":\n          case \"right\":\n          case \"bottom\":\n          case \"left\":\n            return typeof value === \"number\" ? _this.pixelify(value) : value;\n\n          default:\n            return _this.formatTransformFunction(option, value);\n        }\n      }).filter(function (option) {\n        return Boolean(option);\n      }).join(\" \");\n    });\n    return keyframeValues;\n  };\n  /**\n   * Gets all keyframes configured by options\n   */\n\n\n  Animate.prototype.getOptionKeyframes = function () {\n    var keyframes = [this.getInitialKeyframeValues(), this.getOptionKeyframeValues()];\n    return this.mode === AnimationMode.animateFrom ? keyframes.reverse() : keyframes;\n  };\n  /**\n   * Sorts an array of offset keys in ascending order\n   */\n\n\n  Animate.prototype.sortOffsets = function (offsets) {\n    return offsets.sort(function (a, b) {\n      var A = parseFloat(a);\n      var B = parseFloat(b);\n\n      if (A < B) {\n        return -1;\n      } else if (A > B) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n  };\n  /**\n   * Consolidates all keyframe arrays into a single keyframe array\n   */\n\n\n  Animate.prototype.consolidateKeyframes = function (keyframeSets) {\n    var frames = []; // Merge all keyframes into a single frames object where each key is a keyframe offset\n\n    keyframeSets.forEach(function (keyframeSet) {\n      keyframeSet.forEach(function (keyframe, index) {\n        var offset = keyframe.offset;\n\n        if (typeof offset === \"undefined\") {\n          offset = index === 0 ? 0 : 1;\n          keyframe.offset = offset;\n        }\n\n        var offsetKey = offset.toString();\n        frames[offsetKey] = typeof frames[offsetKey] === \"undefined\" ? keyframe : Object.assign(frames[offsetKey], keyframe);\n      });\n    });\n    return this.sortOffsets(Object.keys(frames)).map(function (offset) {\n      return frames[offset];\n    });\n  };\n\n  Object.defineProperty(Animate.prototype, \"keyframes\", {\n    /**\n     * Returns the animation's keyframes\n     */\n    get: function () {\n      var optionKeyframes = this.getOptionKeyframes();\n      return this.consolidateKeyframes(this._keyframes.concat([this.getOptionKeyframes()]));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Animate.prototype, \"keyframeEffect\", {\n    /**\n     * Returns the key frame effect object\n     */\n    get: function () {\n      return new KeyframeEffect(this.animationTarget, this.keyframes, this.effectTiming);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * A mapping between animation options and the css property names they apply to\n   */\n\n  Animate.propertyMap = {\n    opacity: [\"opacity\"],\n    transform: [\"x\", \"y\", \"rotate\", \"scale\"],\n    top: [\"top\"],\n    left: [\"left\"],\n    bottom: [\"bottom\"],\n    right: [\"right\"]\n  };\n  return Animate;\n}();\n\nexports.default = Animate;","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-animation/dist/animate/index.js"],"names":["Object","defineProperty","exports","value","AnimationMode","Animate","element","options","effectTiming","_this","fill","iterations","duration","_keyframes","play","ensureAnimationObjectExists","animation","pause","finish","cancel","reverse","addKeyframes","keyframes","push","animationTarget","Boolean","assign","transformOrigin","style","transformStyle","prototype","get","_onFinish","set","callback","onfinish","enumerable","configurable","createAnimationObject","Animation","keyframeEffect","document","timeline","onFinish","onCancel","oncancel","getPropertiesToAnimate","keys","propertyMap","filter","property","reduce","hasProperty","animationProp","normalizeInitialValue","undefined","coercedReturn","matrixValuesRegex","matrixValues","match","Array","isArray","normalizedValues","split","map","matchedValue","index","parsedValueIsZero","parseFloat","join","getInitialKeyframeValues","HTMLElement","window","animatedProperties","computedStyle","getComputedStyle","initialKeyframeValues","forEach","formatTransformFunction","functionType","transform","indexOf","toUpperCase","pixelify","toString","num","getOptionKeyframeValues","animateProperties","keyframeValues","option","getOptionKeyframes","mode","animateFrom","sortOffsets","offsets","sort","a","b","A","B","consolidateKeyframes","keyframeSets","frames","keyframeSet","keyframe","offset","offsetKey","optionKeyframes","concat","KeyframeEffect","opacity","top","left","bottom","right","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Animation mode describes if an animation should animate toward an elements natural position or away from it\n */\nvar AnimationMode;\n(function (AnimationMode) {\n    AnimationMode[AnimationMode[\"animateTo\"] = 0] = \"animateTo\";\n    AnimationMode[AnimationMode[\"animateFrom\"] = 1] = \"animateFrom\";\n})(AnimationMode = exports.AnimationMode || (exports.AnimationMode = {}));\nvar Animate = /** @class */ (function () {\n    function Animate(element, options, effectTiming) {\n        var _this = this;\n        /**\n         * Stores animation timing functions\n         */\n        this.effectTiming = {\n            fill: \"forwards\",\n            iterations: 1,\n            duration: 500,\n        };\n        /**\n         * Stores animation keyframe sets and is accessed by a getter\n         */\n        this._keyframes = [];\n        /**\n         * plays the animation\n         */\n        this.play = function () {\n            _this.ensureAnimationObjectExists();\n            _this.animation.play();\n        };\n        /**\n         * pauses the animation\n         */\n        this.pause = function () {\n            _this.ensureAnimationObjectExists();\n            _this.animation.pause();\n        };\n        /**\n         * finishes the animation\n         */\n        this.finish = function () {\n            _this.ensureAnimationObjectExists();\n            _this.animation.finish();\n        };\n        /**\n         * cancels the animation\n         */\n        this.cancel = function () {\n            _this.ensureAnimationObjectExists();\n            _this.animation.cancel();\n        };\n        /**\n         * reverses an animation\n         */\n        this.reverse = function () {\n            _this.ensureAnimationObjectExists();\n            _this.animation.reverse();\n        };\n        /**\n         * adds a set of keyframes to set of animation keyframes the animation should execute\n         */\n        this.addKeyframes = function (keyframes) {\n            _this._keyframes.push(keyframes);\n        };\n        this.animationTarget = element;\n        if (Boolean(effectTiming)) {\n            this.effectTiming = Object.assign({}, this.effectTiming, effectTiming);\n        }\n        if (options) {\n            if (options.transformOrigin) {\n                element.style.transformOrigin = options.transformOrigin;\n            }\n            if (options.transformStyle) {\n                element.style.transformStyle = options.transformStyle;\n            }\n        }\n        this.options = options || {};\n    }\n    Object.defineProperty(Animate.prototype, \"onFinish\", {\n        get: function () {\n            return this._onFinish;\n        },\n        set: function (callback) {\n            this._onFinish = callback;\n            if (Boolean(this.animation)) {\n                this.animation.onfinish = callback;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Ensure animation object\n     */\n    Animate.prototype.ensureAnimationObjectExists = function () {\n        if (typeof this.animation === \"undefined\") {\n            this.createAnimationObject();\n        }\n    };\n    /**\n     * Creates the animation object\n     */\n    Animate.prototype.createAnimationObject = function () {\n        this.animation = new Animation(this.keyframeEffect, document.timeline);\n        if (typeof this.onFinish !== \"undefined\") {\n            this.animation.onfinish = this.onFinish;\n        }\n        if (typeof this.onCancel !== \"undefined\") {\n            this.animation.oncancel = this.onCancel;\n        }\n    };\n    /**\n     * Returns a list of properties that will be animated based options\n     */\n    Animate.prototype.getPropertiesToAnimate = function () {\n        var _this = this;\n        return Object.keys(Animate.propertyMap).filter(function (property) {\n            // Filter out all properties that don't need to be set based on our options\n            return Animate.propertyMap[property].reduce(function (hasProperty, animationProp) {\n                return (typeof _this.options[animationProp] !== \"undefined\" || hasProperty);\n            }, false);\n        });\n    };\n    /**\n     * Current implmentations of web animations seem to have trouble animating both scale and opacity\n     * from a starting value of 0. This method detects when those values are 0 and alters them slightly\n     * to known-working starting values\n     */\n    Animate.prototype.normalizeInitialValue = function (property, value) {\n        if (value === undefined) {\n            return;\n        }\n        var coercedReturn = \"0.01\";\n        switch (property) {\n            case \"transform\":\n                var matrixValuesRegex = /matrix\\((.+)\\)/;\n                var matrixValues = value.match(matrixValuesRegex);\n                if (Array.isArray(matrixValues)) {\n                    var normalizedValues = matrixValues[1]\n                        .split(\",\")\n                        .map(function (matchedValue, index) {\n                        var parsedValueIsZero = parseFloat(value) === 0;\n                        if (!parsedValueIsZero) {\n                            return matchedValue;\n                        }\n                        // If this is the scaleX index or the scaleY index, return the coerced value\n                        return index === 0 || index === 3\n                            ? coercedReturn\n                            : matchedValue;\n                    });\n                    return \"matrix(\" + normalizedValues.join(\",\") + \")\";\n                }\n                break;\n            case \"opacity\":\n                return parseFloat(value) === 0 ? coercedReturn : value;\n        }\n        return value;\n    };\n    /**\n     * Returns the initial values for all properties being animated\n     */\n    Animate.prototype.getInitialKeyframeValues = function () {\n        var _this = this;\n        if (!(this.animationTarget instanceof HTMLElement) ||\n            typeof window === \"undefined\") {\n            return {};\n        }\n        var animatedProperties = this.getPropertiesToAnimate();\n        var computedStyle = window.getComputedStyle(this.animationTarget);\n        var initialKeyframeValues = {};\n        animatedProperties.forEach(function (property) {\n            initialKeyframeValues[property] = _this.normalizeInitialValue(property, computedStyle[property]);\n        });\n        return initialKeyframeValues;\n    };\n    /**\n     * Formats a config option into a transform function\n     */\n    Animate.prototype.formatTransformFunction = function (functionType, value) {\n        // If `functionType` can't be converted into a transform function, just return empty string\n        if (Animate.propertyMap.transform.indexOf(functionType) === -1) {\n            return \"\";\n        }\n        switch (functionType) {\n            case \"x\":\n            case \"y\":\n                functionType = \"translate\" + functionType.toUpperCase();\n                value =\n                    typeof value === \"number\" ? (value = this.pixelify(value)) : value;\n                break;\n            case \"rotate\":\n                value = value.toString() + \"deg\";\n                break;\n            case \"scale\":\n                if (value === 0) {\n                    // There is a strange bug where you can't animate from a scale 0\n                    value = 0.01;\n                }\n        }\n        if (typeof value !== \"string\") {\n            value = value.toString();\n        }\n        return functionType + \"(\" + value + \")\";\n    };\n    /**\n     * Converts a number to a pixel string\n     */\n    Animate.prototype.pixelify = function (num) {\n        return num + \"px\";\n    };\n    /**\n     * Returns keyframe values based on option configuration\n     */\n    Animate.prototype.getOptionKeyframeValues = function () {\n        var _this = this;\n        var animateProperties = this.getPropertiesToAnimate();\n        var keyframeValues = {};\n        animateProperties.forEach(function (property) {\n            keyframeValues[property] = Animate.propertyMap[property]\n                .map(function (option) {\n                var value = _this.options[option];\n                if (typeof value === \"undefined\") {\n                    return null;\n                }\n                switch (option) {\n                    case \"opacity\":\n                        return value.toString();\n                    case \"top\":\n                    case \"right\":\n                    case \"bottom\":\n                    case \"left\":\n                        return typeof value === \"number\"\n                            ? _this.pixelify(value)\n                            : value;\n                    default:\n                        return _this.formatTransformFunction(option, value);\n                }\n            })\n                .filter(function (option) { return Boolean(option); })\n                .join(\" \");\n        });\n        return keyframeValues;\n    };\n    /**\n     * Gets all keyframes configured by options\n     */\n    Animate.prototype.getOptionKeyframes = function () {\n        var keyframes = [\n            this.getInitialKeyframeValues(),\n            this.getOptionKeyframeValues(),\n        ];\n        return this.mode === AnimationMode.animateFrom ? keyframes.reverse() : keyframes;\n    };\n    /**\n     * Sorts an array of offset keys in ascending order\n     */\n    Animate.prototype.sortOffsets = function (offsets) {\n        return offsets.sort(function (a, b) {\n            var A = parseFloat(a);\n            var B = parseFloat(b);\n            if (A < B) {\n                return -1;\n            }\n            else if (A > B) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n    };\n    /**\n     * Consolidates all keyframe arrays into a single keyframe array\n     */\n    Animate.prototype.consolidateKeyframes = function (keyframeSets) {\n        var frames = [];\n        // Merge all keyframes into a single frames object where each key is a keyframe offset\n        keyframeSets.forEach(function (keyframeSet) {\n            keyframeSet.forEach(function (keyframe, index) {\n                var offset = keyframe.offset;\n                if (typeof offset === \"undefined\") {\n                    offset = index === 0 ? 0 : 1;\n                    keyframe.offset = offset;\n                }\n                var offsetKey = offset.toString();\n                frames[offsetKey] =\n                    typeof frames[offsetKey] === \"undefined\"\n                        ? keyframe\n                        : Object.assign(frames[offsetKey], keyframe);\n            });\n        });\n        return this.sortOffsets(Object.keys(frames)).map(function (offset) {\n            return frames[offset];\n        });\n    };\n    Object.defineProperty(Animate.prototype, \"keyframes\", {\n        /**\n         * Returns the animation's keyframes\n         */\n        get: function () {\n            var optionKeyframes = this.getOptionKeyframes();\n            return this.consolidateKeyframes(this._keyframes.concat([this.getOptionKeyframes()]));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Animate.prototype, \"keyframeEffect\", {\n        /**\n         * Returns the key frame effect object\n         */\n        get: function () {\n            return new KeyframeEffect(this.animationTarget, this.keyframes, this.effectTiming);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * A mapping between animation options and the css property names they apply to\n     */\n    Animate.propertyMap = {\n        opacity: [\"opacity\"],\n        transform: [\"x\", \"y\", \"rotate\", \"scale\"],\n        top: [\"top\"],\n        left: [\"left\"],\n        bottom: [\"bottom\"],\n        right: [\"right\"],\n    };\n    return Animate;\n}());\nexports.default = Animate;\n"]},"metadata":{},"sourceType":"script"}