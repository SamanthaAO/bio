{"ast":null,"code":"import { ColorHSL } from \"./color-hsl\";\nimport { ColorHSV } from \"./color-hsv\";\nimport { ColorLAB } from \"./color-lab\";\nimport { ColorLCH } from \"./color-lch\";\nimport { ColorRGBA64 } from \"./color-rgba-64\";\nimport { ColorXYZ } from \"./color-xyz\";\nimport { degreesToRadians, radiansToDegrees } from \"./math-utilities\"; // All hue values are in degrees rather than radians or normalized\n// All conversions use the D65 2 degree white point for XYZ\n// Info on conversions and constants used can be found in the following:\n// https://en.wikipedia.org/wiki/CIELAB_color_space\n// https://en.wikipedia.org/wiki/Illuminant_D65\n// https://ninedegreesbelow.com/photography/xyz-rgb.html\n// http://user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html\n// https://web.stanford.edu/~sujason/ColorBalancing/adaptation.html\n// http://brucelindbloom.com/index.html\n\n/**\n * Get the relative luminance of a color.\n * Adjusts the color to sRGB space, which is necessary for the WCAG contrast spec.\n * The alpha channel of the input is ignored.\n * @param rgb The input color\n */\n\nexport function rgbToRelativeLuminance(rgb) {\n  function luminanceHelper(i) {\n    if (i <= 0.03928) {\n      return i / 12.92;\n    }\n\n    return Math.pow((i + 0.055) / 1.055, 2.4);\n  }\n\n  return rgbToLinearLuminance(new ColorRGBA64(luminanceHelper(rgb.r), luminanceHelper(rgb.g), luminanceHelper(rgb.b), 1));\n}\n\nconst calculateContrastRatio = (a, b) => (a + 0.05) / (b + 0.05); // The alpha channel of the input is ignored\n\n\nexport function contrastRatio(a, b) {\n  const luminanceA = rgbToRelativeLuminance(a);\n  const luminanceB = rgbToRelativeLuminance(b);\n  return luminanceA > luminanceB ? calculateContrastRatio(luminanceA, luminanceB) : calculateContrastRatio(luminanceB, luminanceA);\n}\n/**\n * Get the luminance of a color in the linear RGB space.\n * This is not the same as the relative luminance in the sRGB space for WCAG contrast calculations. Use rgbToRelativeLuminance instead.\n * @param rgb The input color\n */\n\nexport function rgbToLinearLuminance(rgb) {\n  return rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722;\n} // The alpha channel of the input is ignored\n\nexport function rgbToHSL(rgb) {\n  const max = Math.max(rgb.r, rgb.g, rgb.b);\n  const min = Math.min(rgb.r, rgb.g, rgb.b);\n  const delta = max - min;\n  let hue = 0;\n\n  if (delta !== 0) {\n    if (max === rgb.r) {\n      hue = 60 * ((rgb.g - rgb.b) / delta % 6);\n    } else if (max === rgb.g) {\n      hue = 60 * ((rgb.b - rgb.r) / delta + 2);\n    } else {\n      hue = 60 * ((rgb.r - rgb.g) / delta + 4);\n    }\n  }\n\n  if (hue < 0) {\n    hue += 360;\n  }\n\n  const lum = (max + min) / 2;\n  let sat = 0;\n\n  if (delta !== 0) {\n    sat = delta / (1 - Math.abs(2 * lum - 1));\n  }\n\n  return new ColorHSL(hue, sat, lum);\n}\nexport function hslToRGB(hsl, alpha = 1) {\n  const c = (1 - Math.abs(2 * hsl.l - 1)) * hsl.s;\n  const x = c * (1 - Math.abs(hsl.h / 60 % 2 - 1));\n  const m = hsl.l - c / 2;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n\n  if (hsl.h < 60) {\n    r = c;\n    g = x;\n    b = 0;\n  } else if (hsl.h < 120) {\n    r = x;\n    g = c;\n    b = 0;\n  } else if (hsl.h < 180) {\n    r = 0;\n    g = c;\n    b = x;\n  } else if (hsl.h < 240) {\n    r = 0;\n    g = x;\n    b = c;\n  } else if (hsl.h < 300) {\n    r = x;\n    g = 0;\n    b = c;\n  } else if (hsl.h < 360) {\n    r = c;\n    g = 0;\n    b = x;\n  }\n\n  return new ColorRGBA64(r + m, g + m, b + m, alpha);\n} // The alpha channel of the input is ignored\n\nexport function rgbToHSV(rgb) {\n  const max = Math.max(rgb.r, rgb.g, rgb.b);\n  const min = Math.min(rgb.r, rgb.g, rgb.b);\n  const delta = max - min;\n  let hue = 0;\n\n  if (delta !== 0) {\n    if (max === rgb.r) {\n      hue = 60 * ((rgb.g - rgb.b) / delta % 6);\n    } else if (max === rgb.g) {\n      hue = 60 * ((rgb.b - rgb.r) / delta + 2);\n    } else {\n      hue = 60 * ((rgb.r - rgb.g) / delta + 4);\n    }\n  }\n\n  if (hue < 0) {\n    hue += 360;\n  }\n\n  let sat = 0;\n\n  if (max !== 0) {\n    sat = delta / max;\n  }\n\n  return new ColorHSV(hue, sat, max);\n}\nexport function hsvToRGB(hsv, alpha = 1) {\n  const c = hsv.s * hsv.v;\n  const x = c * (1 - Math.abs(hsv.h / 60 % 2 - 1));\n  const m = hsv.v - c;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n\n  if (hsv.h < 60) {\n    r = c;\n    g = x;\n    b = 0;\n  } else if (hsv.h < 120) {\n    r = x;\n    g = c;\n    b = 0;\n  } else if (hsv.h < 180) {\n    r = 0;\n    g = c;\n    b = x;\n  } else if (hsv.h < 240) {\n    r = 0;\n    g = x;\n    b = c;\n  } else if (hsv.h < 300) {\n    r = x;\n    g = 0;\n    b = c;\n  } else if (hsv.h < 360) {\n    r = c;\n    g = 0;\n    b = x;\n  }\n\n  return new ColorRGBA64(r + m, g + m, b + m, alpha);\n}\nexport function lchToLAB(lch) {\n  let a = 0;\n  let b = 0;\n\n  if (lch.h !== 0) {\n    a = Math.cos(degreesToRadians(lch.h)) * lch.c;\n    b = Math.sin(degreesToRadians(lch.h)) * lch.c;\n  }\n\n  return new ColorLAB(lch.l, a, b);\n} // The discontinuity in the C parameter at 0 means that floating point errors will often result in values near 0 giving unpredictable results.\n// EG: 0.0000001 gives a very different result than -0.0000001\n// More info about the atan2 function: https://en.wikipedia.org/wiki/Atan2\n\nexport function labToLCH(lab) {\n  let h = 0;\n\n  if (lab.b !== 0 || lab.a !== 0) {\n    h = radiansToDegrees(Math.atan2(lab.b, lab.a));\n  }\n\n  if (h < 0) {\n    h += 360;\n  }\n\n  const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);\n  return new ColorLCH(lab.l, c, h);\n}\nexport function labToXYZ(lab) {\n  const fy = (lab.l + 16) / 116;\n  const fx = fy + lab.a / 500;\n  const fz = fy - lab.b / 200;\n  const xcubed = Math.pow(fx, 3);\n  const ycubed = Math.pow(fy, 3);\n  const zcubed = Math.pow(fz, 3);\n  let x = 0;\n\n  if (xcubed > ColorLAB.epsilon) {\n    x = xcubed;\n  } else {\n    x = (116 * fx - 16) / ColorLAB.kappa;\n  }\n\n  let y = 0;\n\n  if (lab.l > ColorLAB.epsilon * ColorLAB.kappa) {\n    y = ycubed;\n  } else {\n    y = lab.l / ColorLAB.kappa;\n  }\n\n  let z = 0;\n\n  if (zcubed > ColorLAB.epsilon) {\n    z = zcubed;\n  } else {\n    z = (116 * fz - 16) / ColorLAB.kappa;\n  }\n\n  x = ColorXYZ.whitePoint.x * x;\n  y = ColorXYZ.whitePoint.y * y;\n  z = ColorXYZ.whitePoint.z * z;\n  return new ColorXYZ(x, y, z);\n}\nexport function xyzToLAB(xyz) {\n  function xyzToLABHelper(i) {\n    if (i > ColorLAB.epsilon) {\n      return Math.pow(i, 1 / 3);\n    }\n\n    return (ColorLAB.kappa * i + 16) / 116;\n  }\n\n  const x = xyzToLABHelper(xyz.x / ColorXYZ.whitePoint.x);\n  const y = xyzToLABHelper(xyz.y / ColorXYZ.whitePoint.y);\n  const z = xyzToLABHelper(xyz.z / ColorXYZ.whitePoint.z);\n  const l = 116 * y - 16;\n  const a = 500 * (x - y);\n  const b = 200 * (y - z);\n  return new ColorLAB(l, a, b);\n} // The alpha channel of the input is ignored\n\nexport function rgbToXYZ(rgb) {\n  function rgbToXYZHelper(i) {\n    if (i <= 0.04045) {\n      return i / 12.92;\n    }\n\n    return Math.pow((i + 0.055) / 1.055, 2.4);\n  }\n\n  const r = rgbToXYZHelper(rgb.r);\n  const g = rgbToXYZHelper(rgb.g);\n  const b = rgbToXYZHelper(rgb.b);\n  const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;\n  const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;\n  const z = r * 0.0193339 + g * 0.119192 + b * 0.9503041;\n  return new ColorXYZ(x, y, z);\n} // Note that the xyz color space is significantly larger than sRGB. As such, this can return colors rgb values greater than 1 or less than 0\n\nexport function xyzToRGB(xyz, alpha = 1) {\n  function xyzToRGBHelper(i) {\n    if (i <= 0.0031308) {\n      return i * 12.92;\n    }\n\n    return 1.055 * Math.pow(i, 1 / 2.4) - 0.055;\n  }\n\n  const r = xyzToRGBHelper(xyz.x * 3.2404542 - xyz.y * 1.5371385 - xyz.z * 0.4985314);\n  const g = xyzToRGBHelper(xyz.x * -0.969266 + xyz.y * 1.8760108 + xyz.z * 0.041556);\n  const b = xyzToRGBHelper(xyz.x * 0.0556434 - xyz.y * 0.2040259 + xyz.z * 1.0572252);\n  return new ColorRGBA64(r, g, b, alpha);\n} // The alpha channel of the input is ignored\n\nexport function rgbToLAB(rgb) {\n  return xyzToLAB(rgbToXYZ(rgb));\n} // Note that the xyz color space (which the conversion from LAB uses) is significantly larger than sRGB. As such, this can return colors rgb values greater than 1 or less than 0\n\nexport function labToRGB(lab, alpha = 1) {\n  return xyzToRGB(labToXYZ(lab), alpha);\n} // The alpha channel of the input is ignored\n\nexport function rgbToLCH(rgb) {\n  return labToLCH(rgbToLAB(rgb));\n}\nexport function lchToRGB(lch, alpha = 1) {\n  return labToRGB(lchToLAB(lch), alpha);\n}\nexport function temperatureToRGB(tempKelvin, alpha = 1) {\n  // The constants I could find assumed a decimal range of [0,255] for each channel. Just going to put a /255.0 at the end\n  let r = 0;\n  let g = 0;\n  let b = 0;\n\n  if (tempKelvin <= 1000) {\n    tempKelvin = 1000;\n  } else if (tempKelvin >= 40000) {\n    tempKelvin = 40000;\n  }\n\n  if (tempKelvin < 6600.0) {\n    r = 255.0;\n    g = tempKelvin / 100.0 - 2.0;\n    g = -155.25485562709179 - 0.44596950469579133 * g + 104.49216199393888 * Math.log(g);\n  } else {\n    r = tempKelvin / 100.0 - 55.0;\n    r = 351.97690566805693 + 0.114206453784165 * r - 40.25366309332127 * Math.log(r);\n    g = tempKelvin / 100.0 - 50.0;\n    g = 325.4494125711974 + 0.07943456536662342 * g - 28.0852963507957 * Math.log(g);\n  }\n\n  if (tempKelvin >= 6600.0) {\n    b = 255.0;\n  } else if (tempKelvin < 2000.0) {\n    b = 0.0;\n  } else {\n    b = tempKelvin / 100.0 - 10;\n    b = -254.76935184120902 + 0.8274096064007395 * b + 115.67994401066147 * Math.log(b);\n  }\n\n  return new ColorRGBA64(r / 255, g / 255, b / 255, alpha);\n} // The alpha channel of the input is ignored\n\nexport function rgbToTemperature(rgb) {\n  let t = 0;\n  let min = 1000;\n  let max = 40000;\n\n  while (max - min > 0.4) {\n    t = (max + min) / 2.0;\n    const testColor = temperatureToRGB(t);\n\n    if (testColor.b / testColor.r >= rgb.b / rgb.r) {\n      max = t;\n    } else {\n      min = t;\n    }\n  }\n\n  return Math.round(t);\n}","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-colors/dist/color-converters.js"],"names":["ColorHSL","ColorHSV","ColorLAB","ColorLCH","ColorRGBA64","ColorXYZ","degreesToRadians","radiansToDegrees","rgbToRelativeLuminance","rgb","luminanceHelper","i","Math","pow","rgbToLinearLuminance","r","g","b","calculateContrastRatio","a","contrastRatio","luminanceA","luminanceB","rgbToHSL","max","min","delta","hue","lum","sat","abs","hslToRGB","hsl","alpha","c","l","s","x","h","m","rgbToHSV","hsvToRGB","hsv","v","lchToLAB","lch","cos","sin","labToLCH","lab","atan2","sqrt","labToXYZ","fy","fx","fz","xcubed","ycubed","zcubed","epsilon","kappa","y","z","whitePoint","xyzToLAB","xyz","xyzToLABHelper","rgbToXYZ","rgbToXYZHelper","xyzToRGB","xyzToRGBHelper","rgbToLAB","labToRGB","rgbToLCH","lchToRGB","temperatureToRGB","tempKelvin","log","rgbToTemperature","t","testColor","round"],"mappings":"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","sourcesContent":["import { ColorHSL } from \"./color-hsl\";\nimport { ColorHSV } from \"./color-hsv\";\nimport { ColorLAB } from \"./color-lab\";\nimport { ColorLCH } from \"./color-lch\";\nimport { ColorRGBA64 } from \"./color-rgba-64\";\nimport { ColorXYZ } from \"./color-xyz\";\nimport { degreesToRadians, radiansToDegrees } from \"./math-utilities\";\n// All hue values are in degrees rather than radians or normalized\n// All conversions use the D65 2 degree white point for XYZ\n// Info on conversions and constants used can be found in the following:\n// https://en.wikipedia.org/wiki/CIELAB_color_space\n// https://en.wikipedia.org/wiki/Illuminant_D65\n// https://ninedegreesbelow.com/photography/xyz-rgb.html\n// http://user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html\n// https://web.stanford.edu/~sujason/ColorBalancing/adaptation.html\n// http://brucelindbloom.com/index.html\n/**\n * Get the relative luminance of a color.\n * Adjusts the color to sRGB space, which is necessary for the WCAG contrast spec.\n * The alpha channel of the input is ignored.\n * @param rgb The input color\n */\nexport function rgbToRelativeLuminance(rgb) {\n    function luminanceHelper(i) {\n        if (i <= 0.03928) {\n            return i / 12.92;\n        }\n        return Math.pow((i + 0.055) / 1.055, 2.4);\n    }\n    return rgbToLinearLuminance(new ColorRGBA64(luminanceHelper(rgb.r), luminanceHelper(rgb.g), luminanceHelper(rgb.b), 1));\n}\nconst calculateContrastRatio = (a, b) => (a + 0.05) / (b + 0.05);\n// The alpha channel of the input is ignored\nexport function contrastRatio(a, b) {\n    const luminanceA = rgbToRelativeLuminance(a);\n    const luminanceB = rgbToRelativeLuminance(b);\n    return luminanceA > luminanceB\n        ? calculateContrastRatio(luminanceA, luminanceB)\n        : calculateContrastRatio(luminanceB, luminanceA);\n}\n/**\n * Get the luminance of a color in the linear RGB space.\n * This is not the same as the relative luminance in the sRGB space for WCAG contrast calculations. Use rgbToRelativeLuminance instead.\n * @param rgb The input color\n */\nexport function rgbToLinearLuminance(rgb) {\n    return rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722;\n}\n// The alpha channel of the input is ignored\nexport function rgbToHSL(rgb) {\n    const max = Math.max(rgb.r, rgb.g, rgb.b);\n    const min = Math.min(rgb.r, rgb.g, rgb.b);\n    const delta = max - min;\n    let hue = 0;\n    if (delta !== 0) {\n        if (max === rgb.r) {\n            hue = 60 * (((rgb.g - rgb.b) / delta) % 6);\n        }\n        else if (max === rgb.g) {\n            hue = 60 * ((rgb.b - rgb.r) / delta + 2);\n        }\n        else {\n            hue = 60 * ((rgb.r - rgb.g) / delta + 4);\n        }\n    }\n    if (hue < 0) {\n        hue += 360;\n    }\n    const lum = (max + min) / 2;\n    let sat = 0;\n    if (delta !== 0) {\n        sat = delta / (1 - Math.abs(2 * lum - 1));\n    }\n    return new ColorHSL(hue, sat, lum);\n}\nexport function hslToRGB(hsl, alpha = 1) {\n    const c = (1 - Math.abs(2 * hsl.l - 1)) * hsl.s;\n    const x = c * (1 - Math.abs(((hsl.h / 60) % 2) - 1));\n    const m = hsl.l - c / 2;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (hsl.h < 60) {\n        r = c;\n        g = x;\n        b = 0;\n    }\n    else if (hsl.h < 120) {\n        r = x;\n        g = c;\n        b = 0;\n    }\n    else if (hsl.h < 180) {\n        r = 0;\n        g = c;\n        b = x;\n    }\n    else if (hsl.h < 240) {\n        r = 0;\n        g = x;\n        b = c;\n    }\n    else if (hsl.h < 300) {\n        r = x;\n        g = 0;\n        b = c;\n    }\n    else if (hsl.h < 360) {\n        r = c;\n        g = 0;\n        b = x;\n    }\n    return new ColorRGBA64(r + m, g + m, b + m, alpha);\n}\n// The alpha channel of the input is ignored\nexport function rgbToHSV(rgb) {\n    const max = Math.max(rgb.r, rgb.g, rgb.b);\n    const min = Math.min(rgb.r, rgb.g, rgb.b);\n    const delta = max - min;\n    let hue = 0;\n    if (delta !== 0) {\n        if (max === rgb.r) {\n            hue = 60 * (((rgb.g - rgb.b) / delta) % 6);\n        }\n        else if (max === rgb.g) {\n            hue = 60 * ((rgb.b - rgb.r) / delta + 2);\n        }\n        else {\n            hue = 60 * ((rgb.r - rgb.g) / delta + 4);\n        }\n    }\n    if (hue < 0) {\n        hue += 360;\n    }\n    let sat = 0;\n    if (max !== 0) {\n        sat = delta / max;\n    }\n    return new ColorHSV(hue, sat, max);\n}\nexport function hsvToRGB(hsv, alpha = 1) {\n    const c = hsv.s * hsv.v;\n    const x = c * (1 - Math.abs(((hsv.h / 60) % 2) - 1));\n    const m = hsv.v - c;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (hsv.h < 60) {\n        r = c;\n        g = x;\n        b = 0;\n    }\n    else if (hsv.h < 120) {\n        r = x;\n        g = c;\n        b = 0;\n    }\n    else if (hsv.h < 180) {\n        r = 0;\n        g = c;\n        b = x;\n    }\n    else if (hsv.h < 240) {\n        r = 0;\n        g = x;\n        b = c;\n    }\n    else if (hsv.h < 300) {\n        r = x;\n        g = 0;\n        b = c;\n    }\n    else if (hsv.h < 360) {\n        r = c;\n        g = 0;\n        b = x;\n    }\n    return new ColorRGBA64(r + m, g + m, b + m, alpha);\n}\nexport function lchToLAB(lch) {\n    let a = 0;\n    let b = 0;\n    if (lch.h !== 0) {\n        a = Math.cos(degreesToRadians(lch.h)) * lch.c;\n        b = Math.sin(degreesToRadians(lch.h)) * lch.c;\n    }\n    return new ColorLAB(lch.l, a, b);\n}\n// The discontinuity in the C parameter at 0 means that floating point errors will often result in values near 0 giving unpredictable results.\n// EG: 0.0000001 gives a very different result than -0.0000001\n// More info about the atan2 function: https://en.wikipedia.org/wiki/Atan2\nexport function labToLCH(lab) {\n    let h = 0;\n    if (lab.b !== 0 || lab.a !== 0) {\n        h = radiansToDegrees(Math.atan2(lab.b, lab.a));\n    }\n    if (h < 0) {\n        h += 360;\n    }\n    const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);\n    return new ColorLCH(lab.l, c, h);\n}\nexport function labToXYZ(lab) {\n    const fy = (lab.l + 16) / 116;\n    const fx = fy + lab.a / 500;\n    const fz = fy - lab.b / 200;\n    const xcubed = Math.pow(fx, 3);\n    const ycubed = Math.pow(fy, 3);\n    const zcubed = Math.pow(fz, 3);\n    let x = 0;\n    if (xcubed > ColorLAB.epsilon) {\n        x = xcubed;\n    }\n    else {\n        x = (116 * fx - 16) / ColorLAB.kappa;\n    }\n    let y = 0;\n    if (lab.l > ColorLAB.epsilon * ColorLAB.kappa) {\n        y = ycubed;\n    }\n    else {\n        y = lab.l / ColorLAB.kappa;\n    }\n    let z = 0;\n    if (zcubed > ColorLAB.epsilon) {\n        z = zcubed;\n    }\n    else {\n        z = (116 * fz - 16) / ColorLAB.kappa;\n    }\n    x = ColorXYZ.whitePoint.x * x;\n    y = ColorXYZ.whitePoint.y * y;\n    z = ColorXYZ.whitePoint.z * z;\n    return new ColorXYZ(x, y, z);\n}\nexport function xyzToLAB(xyz) {\n    function xyzToLABHelper(i) {\n        if (i > ColorLAB.epsilon) {\n            return Math.pow(i, 1 / 3);\n        }\n        return (ColorLAB.kappa * i + 16) / 116;\n    }\n    const x = xyzToLABHelper(xyz.x / ColorXYZ.whitePoint.x);\n    const y = xyzToLABHelper(xyz.y / ColorXYZ.whitePoint.y);\n    const z = xyzToLABHelper(xyz.z / ColorXYZ.whitePoint.z);\n    const l = 116 * y - 16;\n    const a = 500 * (x - y);\n    const b = 200 * (y - z);\n    return new ColorLAB(l, a, b);\n}\n// The alpha channel of the input is ignored\nexport function rgbToXYZ(rgb) {\n    function rgbToXYZHelper(i) {\n        if (i <= 0.04045) {\n            return i / 12.92;\n        }\n        return Math.pow((i + 0.055) / 1.055, 2.4);\n    }\n    const r = rgbToXYZHelper(rgb.r);\n    const g = rgbToXYZHelper(rgb.g);\n    const b = rgbToXYZHelper(rgb.b);\n    const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;\n    const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;\n    const z = r * 0.0193339 + g * 0.119192 + b * 0.9503041;\n    return new ColorXYZ(x, y, z);\n}\n// Note that the xyz color space is significantly larger than sRGB. As such, this can return colors rgb values greater than 1 or less than 0\nexport function xyzToRGB(xyz, alpha = 1) {\n    function xyzToRGBHelper(i) {\n        if (i <= 0.0031308) {\n            return i * 12.92;\n        }\n        return 1.055 * Math.pow(i, 1 / 2.4) - 0.055;\n    }\n    const r = xyzToRGBHelper(xyz.x * 3.2404542 - xyz.y * 1.5371385 - xyz.z * 0.4985314);\n    const g = xyzToRGBHelper(xyz.x * -0.969266 + xyz.y * 1.8760108 + xyz.z * 0.041556);\n    const b = xyzToRGBHelper(xyz.x * 0.0556434 - xyz.y * 0.2040259 + xyz.z * 1.0572252);\n    return new ColorRGBA64(r, g, b, alpha);\n}\n// The alpha channel of the input is ignored\nexport function rgbToLAB(rgb) {\n    return xyzToLAB(rgbToXYZ(rgb));\n}\n// Note that the xyz color space (which the conversion from LAB uses) is significantly larger than sRGB. As such, this can return colors rgb values greater than 1 or less than 0\nexport function labToRGB(lab, alpha = 1) {\n    return xyzToRGB(labToXYZ(lab), alpha);\n}\n// The alpha channel of the input is ignored\nexport function rgbToLCH(rgb) {\n    return labToLCH(rgbToLAB(rgb));\n}\nexport function lchToRGB(lch, alpha = 1) {\n    return labToRGB(lchToLAB(lch), alpha);\n}\nexport function temperatureToRGB(tempKelvin, alpha = 1) {\n    // The constants I could find assumed a decimal range of [0,255] for each channel. Just going to put a /255.0 at the end\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (tempKelvin <= 1000) {\n        tempKelvin = 1000;\n    }\n    else if (tempKelvin >= 40000) {\n        tempKelvin = 40000;\n    }\n    if (tempKelvin < 6600.0) {\n        r = 255.0;\n        g = tempKelvin / 100.0 - 2.0;\n        g =\n            -155.25485562709179 -\n                0.44596950469579133 * g +\n                104.49216199393888 * Math.log(g);\n    }\n    else {\n        r = tempKelvin / 100.0 - 55.0;\n        r = 351.97690566805693 + 0.114206453784165 * r - 40.25366309332127 * Math.log(r);\n        g = tempKelvin / 100.0 - 50.0;\n        g = 325.4494125711974 + 0.07943456536662342 * g - 28.0852963507957 * Math.log(g);\n    }\n    if (tempKelvin >= 6600.0) {\n        b = 255.0;\n    }\n    else if (tempKelvin < 2000.0) {\n        b = 0.0;\n    }\n    else {\n        b = tempKelvin / 100.0 - 10;\n        b =\n            -254.76935184120902 +\n                0.8274096064007395 * b +\n                115.67994401066147 * Math.log(b);\n    }\n    return new ColorRGBA64(r / 255, g / 255, b / 255, alpha);\n}\n// The alpha channel of the input is ignored\nexport function rgbToTemperature(rgb) {\n    let t = 0;\n    let min = 1000;\n    let max = 40000;\n    while (max - min > 0.4) {\n        t = (max + min) / 2.0;\n        const testColor = temperatureToRGB(t);\n        if (testColor.b / testColor.r >= rgb.b / rgb.r) {\n            max = t;\n        }\n        else {\n            min = t;\n        }\n    }\n    return Math.round(t);\n}\n"]},"metadata":{},"sourceType":"module"}