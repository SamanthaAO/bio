{"ast":null,"code":"// tslint:disable:member-ordering\n// tslint:disable:prefer-for-of\nimport { contrastRatio } from \"./color-converters\";\nimport { ColorInterpolationSpace, interpolateByColorSpace } from \"./color-interpolation\";\nexport class ColorScale {\n  static createBalancedColorScale(colors) {\n    if (colors == null || colors.length === 0) {\n      throw new Error(\"The colors argument must be non-empty\");\n    }\n\n    const stops = new Array(colors.length);\n\n    for (let i = 0; i < colors.length; i++) {\n      // Special case first and last in order to avoid floating point jaggies\n      if (i === 0) {\n        stops[i] = {\n          color: colors[i],\n          position: 0\n        };\n      } else if (i === colors.length - 1) {\n        stops[i] = {\n          color: colors[i],\n          position: 1\n        };\n      } else {\n        stops[i] = {\n          color: colors[i],\n          position: i * (1 / (colors.length - 1))\n        };\n      }\n    }\n\n    return new ColorScale(stops);\n  }\n\n  constructor(stops) {\n    if (stops == null || stops.length === 0) {\n      throw new Error(\"The stops argument must be non-empty\");\n    } else {\n      this.stops = this.sortColorScaleStops(stops);\n    }\n  }\n\n  getColor(position, interpolationMode = ColorInterpolationSpace.RGB) {\n    if (this.stops.length === 1) {\n      return this.stops[0].color;\n    } else if (position <= 0) {\n      return this.stops[0].color;\n    } else if (position >= 1) {\n      return this.stops[this.stops.length - 1].color;\n    }\n\n    let lowerIndex = 0;\n\n    for (let i = 0; i < this.stops.length; i++) {\n      if (this.stops[i].position <= position) {\n        lowerIndex = i;\n      }\n    }\n\n    let upperIndex = lowerIndex + 1;\n\n    if (upperIndex >= this.stops.length) {\n      upperIndex = this.stops.length - 1;\n    }\n\n    const scalePosition = (position - this.stops[lowerIndex].position) * (1.0 / (this.stops[upperIndex].position - this.stops[lowerIndex].position));\n    return interpolateByColorSpace(scalePosition, interpolationMode, this.stops[lowerIndex].color, this.stops[upperIndex].color);\n  }\n\n  trim(lowerBound, upperBound, interpolationMode = ColorInterpolationSpace.RGB) {\n    if (lowerBound < 0 || upperBound > 1 || upperBound < lowerBound) {\n      throw new Error(\"Invalid bounds\");\n    }\n\n    if (lowerBound === upperBound) {\n      return new ColorScale([{\n        color: this.getColor(lowerBound, interpolationMode),\n        position: 0\n      }]);\n    }\n\n    const containedStops = [];\n\n    for (let i = 0; i < this.stops.length; i++) {\n      if (this.stops[i].position >= lowerBound && this.stops[i].position <= upperBound) {\n        containedStops.push(this.stops[i]);\n      }\n    }\n\n    if (containedStops.length === 0) {\n      return new ColorScale([{\n        color: this.getColor(lowerBound),\n        position: lowerBound\n      }, {\n        color: this.getColor(upperBound),\n        position: upperBound\n      }]);\n    }\n\n    if (containedStops[0].position !== lowerBound) {\n      containedStops.unshift({\n        color: this.getColor(lowerBound),\n        position: lowerBound\n      });\n    }\n\n    if (containedStops[containedStops.length - 1].position !== upperBound) {\n      containedStops.push({\n        color: this.getColor(upperBound),\n        position: upperBound\n      });\n    }\n\n    const range = upperBound - lowerBound;\n    const finalStops = new Array(containedStops.length);\n\n    for (let i = 0; i < containedStops.length; i++) {\n      finalStops[i] = {\n        color: containedStops[i].color,\n        position: (containedStops[i].position - lowerBound) / range\n      };\n    }\n\n    return new ColorScale(finalStops);\n  }\n\n  findNextColor(position, contrast, searchDown = false, interpolationMode = ColorInterpolationSpace.RGB, contrastErrorMargin = 0.005, maxSearchIterations = 32) {\n    if (isNaN(position) || position <= 0) {\n      position = 0;\n    } else if (position >= 1) {\n      position = 1;\n    }\n\n    const startingColor = this.getColor(position, interpolationMode);\n    const finalPosition = searchDown ? 0 : 1;\n    const finalColor = this.getColor(finalPosition, interpolationMode);\n    const finalContrast = contrastRatio(startingColor, finalColor);\n\n    if (finalContrast <= contrast) {\n      return finalPosition;\n    }\n\n    let testRangeMin = searchDown ? 0 : position;\n    let testRangeMax = searchDown ? position : 0;\n    let mid = finalPosition;\n    let iterations = 0;\n\n    while (iterations <= maxSearchIterations) {\n      mid = Math.abs(testRangeMax - testRangeMin) / 2 + testRangeMin;\n      const midColor = this.getColor(mid, interpolationMode);\n      const midContrast = contrastRatio(startingColor, midColor);\n\n      if (Math.abs(midContrast - contrast) <= contrastErrorMargin) {\n        return mid;\n      } else if (midContrast > contrast) {\n        if (searchDown) {\n          testRangeMin = mid;\n        } else {\n          testRangeMax = mid;\n        }\n      } else {\n        if (searchDown) {\n          testRangeMax = mid;\n        } else {\n          testRangeMin = mid;\n        }\n      }\n\n      iterations++;\n    }\n\n    return mid;\n  }\n\n  clone() {\n    const newStops = new Array(this.stops.length);\n\n    for (let i = 0; i < newStops.length; i++) {\n      newStops[i] = {\n        color: this.stops[i].color,\n        position: this.stops[i].position\n      };\n    }\n\n    return new ColorScale(newStops);\n  }\n\n  sortColorScaleStops(stops) {\n    return stops.sort((a, b) => {\n      const A = a.position;\n      const B = b.position;\n\n      if (A < B) {\n        return -1;\n      } else if (A > B) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-colors/dist/color-scale.js"],"names":["contrastRatio","ColorInterpolationSpace","interpolateByColorSpace","ColorScale","createBalancedColorScale","colors","length","Error","stops","Array","i","color","position","constructor","sortColorScaleStops","getColor","interpolationMode","RGB","lowerIndex","upperIndex","scalePosition","trim","lowerBound","upperBound","containedStops","push","unshift","range","finalStops","findNextColor","contrast","searchDown","contrastErrorMargin","maxSearchIterations","isNaN","startingColor","finalPosition","finalColor","finalContrast","testRangeMin","testRangeMax","mid","iterations","Math","abs","midColor","midContrast","clone","newStops","sort","a","b","A","B"],"mappings":"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","sourcesContent":["// tslint:disable:member-ordering\n// tslint:disable:prefer-for-of\nimport { contrastRatio } from \"./color-converters\";\nimport { ColorInterpolationSpace, interpolateByColorSpace } from \"./color-interpolation\";\nexport class ColorScale {\n    static createBalancedColorScale(colors) {\n        if (colors == null || colors.length === 0) {\n            throw new Error(\"The colors argument must be non-empty\");\n        }\n        const stops = new Array(colors.length);\n        for (let i = 0; i < colors.length; i++) {\n            // Special case first and last in order to avoid floating point jaggies\n            if (i === 0) {\n                stops[i] = { color: colors[i], position: 0 };\n            }\n            else if (i === colors.length - 1) {\n                stops[i] = { color: colors[i], position: 1 };\n            }\n            else {\n                stops[i] = {\n                    color: colors[i],\n                    position: i * (1 / (colors.length - 1)),\n                };\n            }\n        }\n        return new ColorScale(stops);\n    }\n    constructor(stops) {\n        if (stops == null || stops.length === 0) {\n            throw new Error(\"The stops argument must be non-empty\");\n        }\n        else {\n            this.stops = this.sortColorScaleStops(stops);\n        }\n    }\n    getColor(position, interpolationMode = ColorInterpolationSpace.RGB) {\n        if (this.stops.length === 1) {\n            return this.stops[0].color;\n        }\n        else if (position <= 0) {\n            return this.stops[0].color;\n        }\n        else if (position >= 1) {\n            return this.stops[this.stops.length - 1].color;\n        }\n        let lowerIndex = 0;\n        for (let i = 0; i < this.stops.length; i++) {\n            if (this.stops[i].position <= position) {\n                lowerIndex = i;\n            }\n        }\n        let upperIndex = lowerIndex + 1;\n        if (upperIndex >= this.stops.length) {\n            upperIndex = this.stops.length - 1;\n        }\n        const scalePosition = (position - this.stops[lowerIndex].position) *\n            (1.0 / (this.stops[upperIndex].position - this.stops[lowerIndex].position));\n        return interpolateByColorSpace(scalePosition, interpolationMode, this.stops[lowerIndex].color, this.stops[upperIndex].color);\n    }\n    trim(lowerBound, upperBound, interpolationMode = ColorInterpolationSpace.RGB) {\n        if (lowerBound < 0 || upperBound > 1 || upperBound < lowerBound) {\n            throw new Error(\"Invalid bounds\");\n        }\n        if (lowerBound === upperBound) {\n            return new ColorScale([\n                { color: this.getColor(lowerBound, interpolationMode), position: 0 },\n            ]);\n        }\n        const containedStops = [];\n        for (let i = 0; i < this.stops.length; i++) {\n            if (this.stops[i].position >= lowerBound &&\n                this.stops[i].position <= upperBound) {\n                containedStops.push(this.stops[i]);\n            }\n        }\n        if (containedStops.length === 0) {\n            return new ColorScale([\n                { color: this.getColor(lowerBound), position: lowerBound },\n                { color: this.getColor(upperBound), position: upperBound },\n            ]);\n        }\n        if (containedStops[0].position !== lowerBound) {\n            containedStops.unshift({\n                color: this.getColor(lowerBound),\n                position: lowerBound,\n            });\n        }\n        if (containedStops[containedStops.length - 1].position !== upperBound) {\n            containedStops.push({\n                color: this.getColor(upperBound),\n                position: upperBound,\n            });\n        }\n        const range = upperBound - lowerBound;\n        const finalStops = new Array(containedStops.length);\n        for (let i = 0; i < containedStops.length; i++) {\n            finalStops[i] = {\n                color: containedStops[i].color,\n                position: (containedStops[i].position - lowerBound) / range,\n            };\n        }\n        return new ColorScale(finalStops);\n    }\n    findNextColor(position, contrast, searchDown = false, interpolationMode = ColorInterpolationSpace.RGB, contrastErrorMargin = 0.005, maxSearchIterations = 32) {\n        if (isNaN(position) || position <= 0) {\n            position = 0;\n        }\n        else if (position >= 1) {\n            position = 1;\n        }\n        const startingColor = this.getColor(position, interpolationMode);\n        const finalPosition = searchDown ? 0 : 1;\n        const finalColor = this.getColor(finalPosition, interpolationMode);\n        const finalContrast = contrastRatio(startingColor, finalColor);\n        if (finalContrast <= contrast) {\n            return finalPosition;\n        }\n        let testRangeMin = searchDown ? 0 : position;\n        let testRangeMax = searchDown ? position : 0;\n        let mid = finalPosition;\n        let iterations = 0;\n        while (iterations <= maxSearchIterations) {\n            mid = Math.abs(testRangeMax - testRangeMin) / 2 + testRangeMin;\n            const midColor = this.getColor(mid, interpolationMode);\n            const midContrast = contrastRatio(startingColor, midColor);\n            if (Math.abs(midContrast - contrast) <= contrastErrorMargin) {\n                return mid;\n            }\n            else if (midContrast > contrast) {\n                if (searchDown) {\n                    testRangeMin = mid;\n                }\n                else {\n                    testRangeMax = mid;\n                }\n            }\n            else {\n                if (searchDown) {\n                    testRangeMax = mid;\n                }\n                else {\n                    testRangeMin = mid;\n                }\n            }\n            iterations++;\n        }\n        return mid;\n    }\n    clone() {\n        const newStops = new Array(this.stops.length);\n        for (let i = 0; i < newStops.length; i++) {\n            newStops[i] = {\n                color: this.stops[i].color,\n                position: this.stops[i].position,\n            };\n        }\n        return new ColorScale(newStops);\n    }\n    sortColorScaleStops(stops) {\n        return stops.sort((a, b) => {\n            const A = a.position;\n            const B = b.position;\n            if (A < B) {\n                return -1;\n            }\n            else if (A > B) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}