{"ast":null,"code":"import React from \"react\";\nimport { get, isPlainObject, pick, set } from \"lodash-es\";\n/**\n * The foundation component is the component that all fast base components are built on top of. It provides a common\n * set of utilities that each component inherits.\n * @param H - These are the props that are \"handled\". \"handled\" props are not mapped automatically to the root element\n * returned by the render function. Use handled props to expose inputs that will not map directly to DOM attributes\n * (eg a custom callback) or where the DOM attribute would be required.\n * @param U - These are \"unhandled\" props. Any props from this interface will be mapped onto the root DOM node of the\n * render function as-is. It is advised that these props map to valid HTML attributes - otherwise you will likely have HTML errors.\n * @param S - The state interface of the component.\n */\n\nclass Foundation extends React.Component {\n  constructor() {\n    super(...arguments);\n    /**\n     * Store all memoized ref callbacks so they can quickly be accessed. Storing the functions\n     * allows us to not create new ref functions every update cycle\n     */\n\n    this.referenceResolverStore = {};\n    /**\n     * Location where all react element and component references are stored\n     */\n\n    this.referenceStore = {};\n  }\n  /**\n   * Stores a react ref callback under the path provided as arguments. Paths are resolved using lodash's get/set API.\n   * The reference object itself will be stored on the referenceStore under the path provided and can be accessed via\n   * the getRef method under the same path.\n   *\n   * Usage: <div ref={this.setRef(\"content-container\")} />\n   */\n\n\n  setRef(...args) {\n    const storageKey = this.processStorageKey(args);\n    let resolverFunction = get(this.referenceResolverStore, storageKey);\n\n    if (!storageKey || isPlainObject(resolverFunction) || Array.isArray(resolverFunction)) {\n      return;\n    }\n\n    if (typeof resolverFunction === \"function\") {\n      return resolverFunction;\n    } else {\n      resolverFunction = ref => {\n        set(this.referenceStore, storageKey, ref);\n      };\n\n      set(this.referenceResolverStore, storageKey, resolverFunction);\n      return resolverFunction;\n    }\n  }\n  /**\n   * Get a reference by key , where function arguments are used as to create the keyname,\n   * eg. getRef('foo', 'bar', 0) resolves to this.references.foo.bar[0];\n   *\n   * Usage: const contentContainer = this.getRef(\"content-container\");\n   */\n\n\n  getRef(...args) {\n    return get(this.referenceStore, this.processStorageKey(args));\n  }\n  /**\n   * Returns an object containing all props that are not enumerated as handledProps\n   */\n\n\n  unhandledProps() {\n    const unhandledPropKeys = Object.keys(this.props).filter(key => {\n      return !(Foundation.defaultHandledProps.indexOf(key) > -1) && this.handledProps && !this.handledProps.hasOwnProperty(key);\n    });\n    return pick(this.props, unhandledPropKeys);\n  }\n  /**\n   * Joins any string with the className prop passed to the component. Used for applying a className to the root\n   * element of a component's render function.\n   */\n\n\n  generateClassNames(componentClasses = \"\") {\n    return componentClasses.concat(` ${this.props.className || \"\"}`).trim().replace(/(\\s){2,}/g, \" \") || null;\n  }\n  /*\n   * Return an array of all nodes who's slot prop matches the provided slot.\n   * If no nodes are provided, `this.props.children` will be used\n   */\n\n\n  withSlot(slot, nodes = this.props.children) {\n    return React.Children.map(nodes, node => {\n      return this.hasSlot(slot, node) ? node : null;\n    });\n  }\n\n  withoutSlot(slot, nodes = this.props.children) {\n    return React.Children.map(nodes, node => {\n      return !this.hasSlot(slot, node) ? node : null;\n    });\n  }\n  /**\n   * Determine if a single node has a slot property\n   */\n\n\n  hasSlot(slot, node) {\n    const nodeSlot = get(node, \"props.slot\");\n    return Array.isArray(slot) ? slot.indexOf(nodeSlot) !== -1 : slot === nodeSlot;\n  }\n  /**\n   * Generates a string that conforms to object/array accessor syntax that can be used by lodash's get / set,\n   * eg. => [\"foo\", \"bar\", 0] => \"foo[bar][0]\"\n   */\n\n\n  processStorageKey(args) {\n    return args.filter(item => {\n      return typeof item === \"string\" || typeof item === \"number\";\n    }).map((item, index) => {\n      return index === 0 ? item : `[${item}]`;\n    }).join(\"\");\n  }\n\n}\n/**\n * The props that should never be passed to the root element by unhandled props\n */\n\n\nFoundation.defaultHandledProps = [\"children\"];\nexport default Foundation;","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-foundation-react/dist/foundation/foundation.js"],"names":["React","get","isPlainObject","pick","set","Foundation","Component","constructor","arguments","referenceResolverStore","referenceStore","setRef","args","storageKey","processStorageKey","resolverFunction","Array","isArray","ref","getRef","unhandledProps","unhandledPropKeys","Object","keys","props","filter","key","defaultHandledProps","indexOf","handledProps","hasOwnProperty","generateClassNames","componentClasses","concat","className","trim","replace","withSlot","slot","nodes","children","Children","map","node","hasSlot","withoutSlot","nodeSlot","item","index","join"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { get, isPlainObject, pick, set } from \"lodash-es\";\n/**\n * The foundation component is the component that all fast base components are built on top of. It provides a common\n * set of utilities that each component inherits.\n * @param H - These are the props that are \"handled\". \"handled\" props are not mapped automatically to the root element\n * returned by the render function. Use handled props to expose inputs that will not map directly to DOM attributes\n * (eg a custom callback) or where the DOM attribute would be required.\n * @param U - These are \"unhandled\" props. Any props from this interface will be mapped onto the root DOM node of the\n * render function as-is. It is advised that these props map to valid HTML attributes - otherwise you will likely have HTML errors.\n * @param S - The state interface of the component.\n */\nclass Foundation extends React.Component {\n    constructor() {\n        super(...arguments);\n        /**\n         * Store all memoized ref callbacks so they can quickly be accessed. Storing the functions\n         * allows us to not create new ref functions every update cycle\n         */\n        this.referenceResolverStore = {};\n        /**\n         * Location where all react element and component references are stored\n         */\n        this.referenceStore = {};\n    }\n    /**\n     * Stores a react ref callback under the path provided as arguments. Paths are resolved using lodash's get/set API.\n     * The reference object itself will be stored on the referenceStore under the path provided and can be accessed via\n     * the getRef method under the same path.\n     *\n     * Usage: <div ref={this.setRef(\"content-container\")} />\n     */\n    setRef(...args) {\n        const storageKey = this.processStorageKey(args);\n        let resolverFunction = get(this.referenceResolverStore, storageKey);\n        if (!storageKey ||\n            isPlainObject(resolverFunction) ||\n            Array.isArray(resolverFunction)) {\n            return;\n        }\n        if (typeof resolverFunction === \"function\") {\n            return resolverFunction;\n        }\n        else {\n            resolverFunction = (ref) => {\n                set(this.referenceStore, storageKey, ref);\n            };\n            set(this.referenceResolverStore, storageKey, resolverFunction);\n            return resolverFunction;\n        }\n    }\n    /**\n     * Get a reference by key , where function arguments are used as to create the keyname,\n     * eg. getRef('foo', 'bar', 0) resolves to this.references.foo.bar[0];\n     *\n     * Usage: const contentContainer = this.getRef(\"content-container\");\n     */\n    getRef(...args) {\n        return get(this.referenceStore, this.processStorageKey(args));\n    }\n    /**\n     * Returns an object containing all props that are not enumerated as handledProps\n     */\n    unhandledProps() {\n        const unhandledPropKeys = Object.keys(this.props).filter((key) => {\n            return (!(Foundation.defaultHandledProps.indexOf(key) > -1) &&\n                (this.handledProps && !this.handledProps.hasOwnProperty(key)));\n        });\n        return pick(this.props, unhandledPropKeys);\n    }\n    /**\n     * Joins any string with the className prop passed to the component. Used for applying a className to the root\n     * element of a component's render function.\n     */\n    generateClassNames(componentClasses = \"\") {\n        return (componentClasses\n            .concat(` ${this.props.className || \"\"}`)\n            .trim()\n            .replace(/(\\s){2,}/g, \" \") || null);\n    }\n    /*\n     * Return an array of all nodes who's slot prop matches the provided slot.\n     * If no nodes are provided, `this.props.children` will be used\n     */\n    withSlot(slot, nodes = this.props.children) {\n        return React.Children.map(nodes, (node) => {\n            return this.hasSlot(slot, node) ? node : null;\n        });\n    }\n    withoutSlot(slot, nodes = this.props.children) {\n        return React.Children.map(nodes, (node) => {\n            return !this.hasSlot(slot, node) ? node : null;\n        });\n    }\n    /**\n     * Determine if a single node has a slot property\n     */\n    hasSlot(slot, node) {\n        const nodeSlot = get(node, \"props.slot\");\n        return Array.isArray(slot) ? slot.indexOf(nodeSlot) !== -1 : slot === nodeSlot;\n    }\n    /**\n     * Generates a string that conforms to object/array accessor syntax that can be used by lodash's get / set,\n     * eg. => [\"foo\", \"bar\", 0] => \"foo[bar][0]\"\n     */\n    processStorageKey(args) {\n        return args\n            .filter((item) => {\n            return typeof item === \"string\" || typeof item === \"number\";\n        })\n            .map((item, index) => {\n            return index === 0 ? item : `[${item}]`;\n        })\n            .join(\"\");\n    }\n}\n/**\n * The props that should never be passed to the root element by unhandled props\n */\nFoundation.defaultHandledProps = [\"children\"];\nexport default Foundation;\n"]},"metadata":{},"sourceType":"module"}