{"ast":null,"code":"import _classCallCheck from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames, Direction, getClientRectWithMargin, RtlScrollConverter } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isNil } from \"lodash-es\";\nimport throttle from \"raf-throttle\";\nimport React from \"react\";\nimport { DisplayNamePrefix } from \"../utilities\";\nexport var ButtonDirection;\n\n(function (ButtonDirection) {\n  ButtonDirection[\"previous\"] = \"previous\";\n  ButtonDirection[\"next\"] = \"next\";\n})(ButtonDirection || (ButtonDirection = {}));\n\nvar HorizontalOverflow =\n/*#__PURE__*/\nfunction (_Foundation) {\n  _inherits(HorizontalOverflow, _Foundation);\n\n  /**\n   * Constructor\n   */\n  function HorizontalOverflow(props) {\n    var _this;\n\n    _classCallCheck(this, HorizontalOverflow);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HorizontalOverflow).call(this, props));\n    _this.handledProps = {\n      scrollDuration: void 0,\n      managedClasses: void 0,\n      onScrollChange: void 0,\n      onOverflowChange: void 0,\n      nextItemPeek: void 0\n    };\n    /**\n     * Stores pending animation frame requests\n     */\n\n    _this.openRequestAnimationFrame = null;\n    /**\n     * Flag indicates if a scroll animation is in progress\n     */\n\n    _this.isScrollAnimating = false;\n    /**\n     * Stores last scroll position from scroll events\n     */\n\n    _this.lastRecordedScroll = 0;\n    /**\n     * Track scroll position\n     */\n\n    _this.onScrollCapture = function (event) {\n      _this.lastRecordedScroll = _this.getScrollPosition();\n    };\n    /**\n     * A child item got focus make sure it is in view\n     */\n\n\n    _this.onItemFocus = function (event) {\n      if (!_this.isOverflow()) {\n        return;\n      }\n\n      var itemLeft = event.currentTarget.offsetLeft;\n      var itemWidth = event.currentTarget.clientWidth;\n      var itemRight = itemLeft + itemWidth;\n\n      var viewportWidth = _this.getAvailableWidth();\n\n      var peek = _this.getScrollPeek(itemWidth);\n\n      var scrollStart = _this.lastRecordedScroll;\n\n      if (_this.isScrollAnimating) {\n        var duration = _this.props.scrollDuration ? _this.props.scrollDuration : HorizontalOverflow.defaultScrollAnimationDuration;\n        var currentDate = new Date().getTime();\n        var currentTime = currentDate - _this.currentScrollAnimStartTime;\n        scrollStart = _this.getScrollAnimationPosition(currentTime, duration);\n      }\n\n      if (itemLeft - _this.lastRecordedScroll < 0) {\n        _this.scrollContent(scrollStart, itemLeft - peek);\n      } else if (itemRight - scrollStart > viewportWidth) {\n        _this.scrollContent(scrollStart, itemRight - viewportWidth + peek);\n      }\n    };\n    /**\n     *  Compares viewport width, item width and desired peek value to come up with\n     *  peek value to use. We don't want to clip focused item to get peek on next/previous item.\n     */\n\n\n    _this.getScrollPeek = function (itemWidth) {\n      var viewportWidth = _this.getAvailableWidth();\n\n      var maxPeek = viewportWidth - itemWidth;\n      maxPeek = maxPeek < 0 ? 0 : maxPeek;\n      var peek = _this.props.nextItemPeek > maxPeek ? maxPeek : _this.props.nextItemPeek;\n      return peek;\n    };\n    /**\n     * Callback for on scroll change\n     */\n\n\n    _this.onScrollChange = function () {\n      if (typeof _this.props.onScrollChange === \"function\") {\n        _this.props.onScrollChange(_this.getPositionData());\n      } // If the onOverflowChange callback exists, we want to update overflow\n      // based on scroll change\n\n\n      if (typeof _this.props.onOverflowChange === \"function\") {\n        var positionData = _this.getPositionData();\n\n        if (_this.overflowStart === !positionData.start || _this.overflowEnd === !positionData.end) {\n          _this.handleOverflowChange();\n        }\n      }\n    };\n    /**\n     * Get the scroll change data\n     */\n\n\n    _this.getPositionData = function () {\n      if (isNil(_this.horizontalOverflowItemsRef.current)) {\n        return {\n          start: true,\n          end: true\n        };\n      }\n\n      var scrollPosition = _this.getScrollPosition();\n\n      var isAtBeginning = scrollPosition === 0;\n      var isAtEnd = _this.horizontalOverflowItemsRef.current.scrollWidth - scrollPosition === _this.horizontalOverflowItemsRef.current.clientWidth;\n      return {\n        start: isAtBeginning,\n        end: isAtEnd\n      };\n    };\n    /**\n     * onLoad handler to make sure any children affecting height are accounted for\n     */\n\n\n    _this.itemsOnLoad = function () {\n      var itemsHeight = _this.getItemMaxHeight();\n\n      if (itemsHeight !== _this.state.itemsHeight) {\n        _this.setState({\n          itemsHeight: itemsHeight\n        });\n      }\n\n      if (_this.overflow !== _this.isOverflow()) {\n        _this.handleOverflowChange();\n      }\n    };\n    /**\n     * Handles the resize event\n     */\n\n\n    _this.onWindowResize = function () {\n      if (_this.overflow !== _this.isOverflow()) {\n        _this.handleOverflowChange();\n      }\n    };\n    /**\n     * Callback for the horizontal overflow change\n     */\n\n\n    _this.handleOverflowChange = function () {\n      _this.overflow = _this.isOverflow();\n\n      if (_this.overflow) {\n        var positionData = _this.getPositionData();\n\n        _this.overflowStart = !positionData.start;\n        _this.overflowEnd = !positionData.end;\n      } else {\n        _this.overflowStart = false;\n        _this.overflowEnd = false;\n      }\n\n      if (typeof _this.props.onOverflowChange === \"function\") {\n        _this.props.onOverflowChange({\n          overflowStart: _this.overflowStart,\n          overflowEnd: _this.overflowEnd\n        });\n      }\n    };\n    /**\n     * Handler for the previous click event\n     */\n\n\n    _this.handlePreviousClick = function () {\n      _this.handleClick(ButtonDirection.previous);\n    };\n    /**\n     * Handler for the next click event\n     */\n\n\n    _this.handleNextClick = function () {\n      _this.handleClick(ButtonDirection.next);\n    };\n    /**\n     * Request's an animation frame if there are currently no open animation frame requests\n     */\n\n\n    _this.requestFrame = function () {\n      if (_this.openRequestAnimationFrame === null) {\n        _this.openRequestAnimationFrame = window.requestAnimationFrame(_this.updateScrollAnimation);\n      }\n    };\n    /**\n     *  Animate one frame of scrolling\n     */\n\n\n    _this.updateScrollAnimation = function () {\n      _this.openRequestAnimationFrame = null;\n      var duration = _this.props.scrollDuration ? _this.props.scrollDuration : HorizontalOverflow.defaultScrollAnimationDuration;\n      var currentDate = new Date().getTime();\n      var currentTime = currentDate - _this.currentScrollAnimStartTime;\n\n      _this.setScrollPosition(_this.getScrollAnimationPosition(currentTime, duration));\n\n      if (currentTime < duration) {\n        _this.requestFrame();\n      } else {\n        _this.isScrollAnimating = false;\n      }\n    };\n    /**\n     *  get scroll animation position for the provided time\n     */\n\n\n    _this.getScrollAnimationPosition = function (currentTime, duration) {\n      if (currentTime < duration) {\n        return _this.easeInOutQuad(currentTime, _this.currentScrollAnimStartPosition, _this.currentScrollAnimEndPosition - _this.currentScrollAnimStartPosition, duration);\n      } else {\n        return _this.currentScrollAnimEndPosition;\n      }\n    };\n    /**\n     *  Gets the scroll position and accounts for direction\n     */\n\n\n    _this.getScrollPosition = function () {\n      if (isNil(_this.horizontalOverflowItemsRef.current)) {\n        return 0;\n      }\n\n      var scrollLeft = RtlScrollConverter.getScrollLeft(_this.horizontalOverflowItemsRef.current, _this.state.direction);\n      return _this.state.direction === Direction.rtl ? -scrollLeft : scrollLeft;\n    };\n    /**\n     *  Sets the scroll position and accounts for direction\n     */\n\n\n    _this.setScrollPosition = function (scrollValue) {\n      if (!isNil(_this.horizontalOverflowItemsRef.current)) {\n        RtlScrollConverter.setScrollLeft(_this.horizontalOverflowItemsRef.current, _this.state.direction === Direction.rtl ? -scrollValue : scrollValue, _this.state.direction);\n      }\n    };\n    /**\n     *  updates the direction in state if necessary\n     */\n\n\n    _this.updateDirection = function () {\n      var newDirection = _this.getDirection();\n\n      if (newDirection !== _this.state.direction) {\n        _this.setState({\n          direction: newDirection\n        });\n      }\n    };\n    /**\n     *  gets the current direction\n     */\n\n\n    _this.getDirection = function () {\n      if (_this.horizontalOverflowItemsRef.current === null) {\n        return Direction.ltr;\n      }\n\n      var closest = _this.horizontalOverflowItemsRef.current.closest(\"[\".concat(HorizontalOverflow.DirectionAttributeName, \"]\"));\n\n      return closest === null || closest.getAttribute(HorizontalOverflow.DirectionAttributeName) === Direction.ltr ? Direction.ltr : Direction.rtl;\n    };\n\n    _this.horizontalOverflowItemsRef = React.createRef();\n    _this.throttledScroll = throttle(_this.onScrollChange);\n    _this.throttledResize = throttle(_this.onWindowResize);\n    _this.overflow = false;\n    _this.state = {\n      direction: Direction.ltr,\n      itemsHeight: null\n    };\n    return _this;\n  }\n  /**\n   * Renders the Horizontal Overflow markup\n   */\n\n\n  _createClass(HorizontalOverflow, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props$managedCl = this.props.managedClasses,\n          horizontalOverflow_contentRegion = _this$props$managedCl.horizontalOverflow_contentRegion,\n          horizontalOverflow_previous = _this$props$managedCl.horizontalOverflow_previous,\n          horizontalOverflow_next = _this$props$managedCl.horizontalOverflow_next;\n      return React.createElement(\"div\", Object.assign({}, this.unhandledProps(), {\n        className: this.generateClassNames(),\n        onLoad: this.itemsOnLoad\n      }), React.createElement(\"div\", {\n        style: {\n          height: this.state.itemsHeight !== null ? \"\".concat(this.state.itemsHeight, \"px\") : \"auto\",\n          position: \"relative\",\n          overflow: \"hidden\"\n        }\n      }, React.createElement(\"ul\", {\n        className: classNames(horizontalOverflow_contentRegion),\n        style: this.getListStyle(),\n        ref: this.horizontalOverflowItemsRef,\n        onScrollCapture: this.onScrollCapture\n      }, this.getItems())), React.createElement(\"div\", {\n        className: classNames(horizontalOverflow_previous),\n        onClick: this.handlePreviousClick\n      }, this.withSlot(ButtonDirection.previous)), React.createElement(\"div\", {\n        className: classNames(horizontalOverflow_next),\n        onClick: this.handleNextClick\n      }, this.withSlot(ButtonDirection.next)));\n    }\n    /**\n     * React life-cycle method\n     */\n\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      if (!this.props.children) {\n        return;\n      }\n\n      var itemsHeight = this.getItemMaxHeight();\n      this.setState({\n        itemsHeight: itemsHeight\n      });\n\n      if (canUseDOM() && this.horizontalOverflowItemsRef.current) {\n        this.updateDirection();\n        this.lastRecordedScroll = this.getScrollPosition();\n        this.horizontalOverflowItemsRef.current.addEventListener(\"scroll\", this.throttledScroll);\n        window.addEventListener(\"resize\", this.throttledResize); // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142\n        // Full browser support imminent\n        // Revisit usage once Safari and Firefox adapt\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409\n        // https://bugs.webkit.org/show_bug.cgi?id=157743\n\n        if (window.ResizeObserver) {\n          this.resizeObserver = new window.ResizeObserver(function (entries) {\n            if (_this2.overflow !== _this2.isOverflow()) {\n              _this2.handleOverflowChange();\n            }\n          });\n          this.resizeObserver.observe(this.horizontalOverflowItemsRef.current);\n        }\n      }\n    }\n    /**\n     * React life-cycle method\n     */\n\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (canUseDOM() && this.horizontalOverflowItemsRef.current) {\n        this.horizontalOverflowItemsRef.current.removeEventListener(\"scroll\", this.throttledScroll);\n        window.removeEventListener(\"resize\", this.throttledResize); // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142\n        // Full browser support imminent\n        // Revisit usage once Safari and Firefox adapt\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409\n        // https://bugs.webkit.org/show_bug.cgi?id=157743\n\n        if (this.resizeObserver && typeof this.resizeObserver.disconnect === \"function\") {\n          this.resizeObserver.disconnect();\n          this.resizeObserver = null;\n        } // Cancel any pending calls\n\n\n        this.throttledResize.cancel();\n        this.throttledScroll.cancel();\n      }\n    }\n    /**\n     * React life-cycle method\n     */\n\n  }, {\n    key: \"getSnapshotBeforeUpdate\",\n    value: function getSnapshotBeforeUpdate(prevProps) {\n      if (React.Children.toArray(prevProps.children).length < React.Children.toArray(this.props.children).length) {\n        return true;\n      }\n\n      return null;\n    }\n    /**\n     * React life-cycle method\n     */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState, snapshot) {\n      if (snapshot !== null) {\n        this.handleOverflowChange();\n      }\n\n      this.updateDirection();\n    }\n    /**\n     * Generates class names\n     */\n\n  }, {\n    key: \"generateClassNames\",\n    value: function generateClassNames() {\n      return _get(_getPrototypeOf(HorizontalOverflow.prototype), \"generateClassNames\", this).call(this, classNames(this.props.managedClasses.horizontalOverflow));\n    }\n    /**\n     * Gets the style for the `ul` element containing the items\n     */\n\n  }, {\n    key: \"getListStyle\",\n    value: function getListStyle() {\n      return {\n        position: \"relative\",\n        whiteSpace: \"nowrap\",\n        overflowX: \"scroll\",\n        padding: 0,\n        margin: 0\n      };\n    }\n    /**\n     * Checks if overflow is occuring\n     */\n\n  }, {\n    key: \"isOverflow\",\n    value: function isOverflow() {\n      var availableWidth = this.getAvailableWidth();\n      var itemWidths = this.getItemWidths();\n      var totalItemWidth = itemWidths.reduce(function (a, b) {\n        return a + b;\n      });\n      return totalItemWidth > availableWidth;\n    }\n    /**\n     * Identifies and returns the tallest child height\n     */\n\n  }, {\n    key: \"getItemMaxHeight\",\n    value: function getItemMaxHeight() {\n      var itemMaxHeight = 0;\n      var children = get(this.horizontalOverflowItemsRef, \"current.childNodes\");\n\n      if (!canUseDOM() || !children) {\n        return itemMaxHeight;\n      }\n\n      var childNodes = Array.prototype.slice.call(children);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = childNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var childNode = _step.value;\n          var childNodeHeight = getClientRectWithMargin(childNode).height;\n\n          if (childNodeHeight > itemMaxHeight) {\n            itemMaxHeight = childNodeHeight;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return itemMaxHeight;\n    }\n    /**\n     * Gets the children displayed as items to be scrolled\n     */\n\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      var _this3 = this;\n\n      return React.Children.map(this.withoutSlot([ButtonDirection.previous, ButtonDirection.next]), function (child, index) {\n        return React.createElement(\"li\", {\n          onFocusCapture: _this3.onItemFocus,\n          className: classNames(_this3.props.managedClasses.horizontalOverflow_item),\n          style: {\n            display: \"inline-block\"\n          }\n        }, child);\n      });\n    }\n    /**\n     * Gets the distance to scroll based on the direction\n     */\n\n  }, {\n    key: \"getScrollDistanceFromButtonDirection\",\n    value: function getScrollDistanceFromButtonDirection(buttonDirection, itemWidths, scrollPosition) {\n      if (itemWidths.length === 0 || !canUseDOM()) {\n        return 0;\n      }\n\n      var distance = 0;\n\n      if (buttonDirection === ButtonDirection.next) {\n        distance = this.getWithinMaxDistance(scrollPosition, itemWidths);\n      } else {\n        distance = this.getWithinMinDistance(scrollPosition, itemWidths);\n      }\n\n      return Math.ceil(distance);\n    }\n    /**\n     * Gets the distance unless it is over the maximum distance, then use maximum distance instead\n     */\n\n  }, {\n    key: \"getWithinMaxDistance\",\n    value: function getWithinMaxDistance(scrollPosition, itemWidths) {\n      var maxDistance = this.getMaxScrollDistance();\n\n      if (scrollPosition === maxDistance) {\n        return maxDistance;\n      }\n\n      var distance = this.getNextDistance(itemWidths, scrollPosition);\n      return distance >= maxDistance ? maxDistance : distance;\n    }\n    /**\n     * Gets the distance unless it is under the minimum distance, then use minimum distance instead\n     */\n\n  }, {\n    key: \"getWithinMinDistance\",\n    value: function getWithinMinDistance(scrollPosition, itemWidths) {\n      if (scrollPosition === 0) {\n        return 0;\n      }\n\n      var distance = this.getPreviousDistance(itemWidths, scrollPosition);\n      return distance <= 0 ? 0 : distance;\n    }\n    /**\n     * Gets the distance to scroll if the next button has been clicked\n     */\n\n  }, {\n    key: \"getNextDistance\",\n    value: function getNextDistance(itemWidths, scrollPosition) {\n      var distance = 0;\n\n      for (var i = 0, itemWidthsLength = itemWidths.length; i < itemWidthsLength; i++) {\n        if (distance + itemWidths[i] > scrollPosition + this.getAvailableWidth() && distance !== scrollPosition) {\n          return distance + this.getScrollPeek(itemWidths[i]);\n        }\n\n        distance += itemWidths[i];\n      }\n\n      return distance;\n    }\n    /**\n     * Gets the distance to scroll if the previous button has been clicked\n     */\n\n  }, {\n    key: \"getPreviousDistance\",\n    value: function getPreviousDistance(itemWidths, scrollPosition) {\n      var availableWidth = this.getAvailableWidth();\n      var distance = this.getMaxScrollDistance() + availableWidth;\n\n      for (var i = itemWidths.length - 1; i >= 0; i--) {\n        if (distance - itemWidths[i] < scrollPosition - availableWidth && distance !== scrollPosition) {\n          return distance - this.getScrollPeek(itemWidths[i]);\n        }\n\n        distance -= itemWidths[i];\n      }\n\n      return distance;\n    }\n    /**\n     * Gets the maximum distance that can be scrolled\n     */\n\n  }, {\n    key: \"getMaxScrollDistance\",\n    value: function getMaxScrollDistance() {\n      if (isNil(this.horizontalOverflowItemsRef.current)) {\n        return 0;\n      }\n\n      return this.horizontalOverflowItemsRef.current.scrollWidth - this.getAvailableWidth();\n    }\n    /**\n     * Handler for the click event fired after next or previous has been clicked\n     */\n\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(buttonDirection) {\n      this.scrollContent(this.getScrollPosition(), this.getScrollDistanceFromButtonDirection(buttonDirection, this.getItemWidths(), this.getScrollPosition()));\n    }\n    /**\n     * Returns the available content region width\n     */\n\n  }, {\n    key: \"getAvailableWidth\",\n    value: function getAvailableWidth() {\n      if (isNil(this.horizontalOverflowItemsRef.current)) {\n        return 0;\n      }\n\n      return this.horizontalOverflowItemsRef.current.clientWidth;\n    }\n    /**\n     * Returns the items widths\n     */\n\n  }, {\n    key: \"getItemWidths\",\n    value: function getItemWidths() {\n      if (isNil(this.horizontalOverflowItemsRef.current)) {\n        return null;\n      }\n\n      var items = Array.prototype.slice.call(this.horizontalOverflowItemsRef.current.childNodes);\n      var itemWidths = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var item = _step2.value;\n          itemWidths.push(getClientRectWithMargin(item).width);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return itemWidths;\n    }\n    /**\n     * Easing animation\n     * Inspired by the github gist contribution: https://gist.github.com/andjosh/6764939\n     */\n\n  }, {\n    key: \"easeInOutQuad\",\n    value: function easeInOutQuad(currentTime, startValue, changeInValue, duration) {\n      currentTime /= duration / 2;\n\n      if (currentTime < 1) {\n        return changeInValue / 2 * currentTime * currentTime + startValue;\n      }\n\n      currentTime--;\n      return -changeInValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;\n    }\n    /**\n     * Scrolls the container for the items list\n     */\n\n  }, {\n    key: \"scrollContent\",\n    value: function scrollContent(startScrollPosition, targetScrollPosition) {\n      var newScrollPosition = Math.max(0, Math.min(targetScrollPosition, this.getMaxScrollDistance()));\n      this.isScrollAnimating = true;\n      this.currentScrollAnimStartPosition = startScrollPosition;\n      this.currentScrollAnimEndPosition = newScrollPosition;\n      this.currentScrollAnimStartTime = new Date().getTime();\n      this.requestFrame();\n    }\n  }]);\n\n  return HorizontalOverflow;\n}(Foundation);\n\nHorizontalOverflow.displayName = \"\".concat(DisplayNamePrefix, \"HorizontalOverflow\");\nHorizontalOverflow.defaultProps = {\n  managedClasses: {},\n  nextItemPeek: 50\n};\nHorizontalOverflow.DirectionAttributeName = \"dir\";\nHorizontalOverflow.defaultScrollAnimationDuration = 500;\nexport default HorizontalOverflow;","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-react-base/dist/horizontal-overflow/horizontal-overflow.js"],"names":["Foundation","classNames","Direction","getClientRectWithMargin","RtlScrollConverter","canUseDOM","get","isNil","throttle","React","DisplayNamePrefix","ButtonDirection","HorizontalOverflow","props","handledProps","scrollDuration","managedClasses","onScrollChange","onOverflowChange","nextItemPeek","openRequestAnimationFrame","isScrollAnimating","lastRecordedScroll","onScrollCapture","event","getScrollPosition","onItemFocus","isOverflow","itemLeft","currentTarget","offsetLeft","itemWidth","clientWidth","itemRight","viewportWidth","getAvailableWidth","peek","getScrollPeek","scrollStart","duration","defaultScrollAnimationDuration","currentDate","Date","getTime","currentTime","currentScrollAnimStartTime","getScrollAnimationPosition","scrollContent","maxPeek","getPositionData","positionData","overflowStart","start","overflowEnd","end","handleOverflowChange","horizontalOverflowItemsRef","current","scrollPosition","isAtBeginning","isAtEnd","scrollWidth","itemsOnLoad","itemsHeight","getItemMaxHeight","state","setState","overflow","onWindowResize","handlePreviousClick","handleClick","previous","handleNextClick","next","requestFrame","window","requestAnimationFrame","updateScrollAnimation","setScrollPosition","easeInOutQuad","currentScrollAnimStartPosition","currentScrollAnimEndPosition","scrollLeft","getScrollLeft","direction","rtl","scrollValue","setScrollLeft","updateDirection","newDirection","getDirection","ltr","closest","DirectionAttributeName","getAttribute","createRef","throttledScroll","throttledResize","horizontalOverflow_contentRegion","horizontalOverflow_previous","horizontalOverflow_next","createElement","Object","assign","unhandledProps","className","generateClassNames","onLoad","style","height","position","getListStyle","ref","getItems","onClick","withSlot","children","addEventListener","ResizeObserver","resizeObserver","entries","observe","removeEventListener","disconnect","cancel","prevProps","Children","toArray","length","prevState","snapshot","horizontalOverflow","whiteSpace","overflowX","padding","margin","availableWidth","itemWidths","getItemWidths","totalItemWidth","reduce","a","b","itemMaxHeight","childNodes","Array","prototype","slice","call","childNode","childNodeHeight","map","withoutSlot","child","index","onFocusCapture","horizontalOverflow_item","display","buttonDirection","distance","getWithinMaxDistance","getWithinMinDistance","Math","ceil","maxDistance","getMaxScrollDistance","getNextDistance","getPreviousDistance","i","itemWidthsLength","getScrollDistanceFromButtonDirection","items","item","push","width","startValue","changeInValue","startScrollPosition","targetScrollPosition","newScrollPosition","max","min","displayName","defaultProps"],"mappings":"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","sourcesContent":["import Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames, Direction, getClientRectWithMargin, RtlScrollConverter, } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isNil } from \"lodash-es\";\nimport throttle from \"raf-throttle\";\nimport React from \"react\";\nimport { DisplayNamePrefix, } from \"../utilities\";\nexport var ButtonDirection;\n(function (ButtonDirection) {\n    ButtonDirection[\"previous\"] = \"previous\";\n    ButtonDirection[\"next\"] = \"next\";\n})(ButtonDirection || (ButtonDirection = {}));\nclass HorizontalOverflow extends Foundation {\n    /**\n     * Constructor\n     */\n    constructor(props) {\n        super(props);\n        this.handledProps = {\n            scrollDuration: void 0,\n            managedClasses: void 0,\n            onScrollChange: void 0,\n            onOverflowChange: void 0,\n            nextItemPeek: void 0,\n        };\n        /**\n         * Stores pending animation frame requests\n         */\n        this.openRequestAnimationFrame = null;\n        /**\n         * Flag indicates if a scroll animation is in progress\n         */\n        this.isScrollAnimating = false;\n        /**\n         * Stores last scroll position from scroll events\n         */\n        this.lastRecordedScroll = 0;\n        /**\n         * Track scroll position\n         */\n        this.onScrollCapture = (event) => {\n            this.lastRecordedScroll = this.getScrollPosition();\n        };\n        /**\n         * A child item got focus make sure it is in view\n         */\n        this.onItemFocus = (event) => {\n            if (!this.isOverflow()) {\n                return;\n            }\n            const itemLeft = event.currentTarget.offsetLeft;\n            const itemWidth = event.currentTarget.clientWidth;\n            const itemRight = itemLeft + itemWidth;\n            const viewportWidth = this.getAvailableWidth();\n            const peek = this.getScrollPeek(itemWidth);\n            let scrollStart = this.lastRecordedScroll;\n            if (this.isScrollAnimating) {\n                const duration = this.props.scrollDuration\n                    ? this.props.scrollDuration\n                    : HorizontalOverflow.defaultScrollAnimationDuration;\n                const currentDate = new Date().getTime();\n                const currentTime = currentDate - this.currentScrollAnimStartTime;\n                scrollStart = this.getScrollAnimationPosition(currentTime, duration);\n            }\n            if (itemLeft - this.lastRecordedScroll < 0) {\n                this.scrollContent(scrollStart, itemLeft - peek);\n            }\n            else if (itemRight - scrollStart > viewportWidth) {\n                this.scrollContent(scrollStart, itemRight - viewportWidth + peek);\n            }\n        };\n        /**\n         *  Compares viewport width, item width and desired peek value to come up with\n         *  peek value to use. We don't want to clip focused item to get peek on next/previous item.\n         */\n        this.getScrollPeek = (itemWidth) => {\n            const viewportWidth = this.getAvailableWidth();\n            let maxPeek = viewportWidth - itemWidth;\n            maxPeek = maxPeek < 0 ? 0 : maxPeek;\n            const peek = this.props.nextItemPeek > maxPeek ? maxPeek : this.props.nextItemPeek;\n            return peek;\n        };\n        /**\n         * Callback for on scroll change\n         */\n        this.onScrollChange = () => {\n            if (typeof this.props.onScrollChange === \"function\") {\n                this.props.onScrollChange(this.getPositionData());\n            }\n            // If the onOverflowChange callback exists, we want to update overflow\n            // based on scroll change\n            if (typeof this.props.onOverflowChange === \"function\") {\n                const positionData = this.getPositionData();\n                if (this.overflowStart === !positionData.start ||\n                    this.overflowEnd === !positionData.end) {\n                    this.handleOverflowChange();\n                }\n            }\n        };\n        /**\n         * Get the scroll change data\n         */\n        this.getPositionData = () => {\n            if (isNil(this.horizontalOverflowItemsRef.current)) {\n                return { start: true, end: true };\n            }\n            const scrollPosition = this.getScrollPosition();\n            const isAtBeginning = scrollPosition === 0;\n            const isAtEnd = this.horizontalOverflowItemsRef.current.scrollWidth - scrollPosition ===\n                this.horizontalOverflowItemsRef.current.clientWidth;\n            return { start: isAtBeginning, end: isAtEnd };\n        };\n        /**\n         * onLoad handler to make sure any children affecting height are accounted for\n         */\n        this.itemsOnLoad = () => {\n            const itemsHeight = this.getItemMaxHeight();\n            if (itemsHeight !== this.state.itemsHeight) {\n                this.setState({\n                    itemsHeight,\n                });\n            }\n            if (this.overflow !== this.isOverflow()) {\n                this.handleOverflowChange();\n            }\n        };\n        /**\n         * Handles the resize event\n         */\n        this.onWindowResize = () => {\n            if (this.overflow !== this.isOverflow()) {\n                this.handleOverflowChange();\n            }\n        };\n        /**\n         * Callback for the horizontal overflow change\n         */\n        this.handleOverflowChange = () => {\n            this.overflow = this.isOverflow();\n            if (this.overflow) {\n                const positionData = this.getPositionData();\n                this.overflowStart = !positionData.start;\n                this.overflowEnd = !positionData.end;\n            }\n            else {\n                this.overflowStart = false;\n                this.overflowEnd = false;\n            }\n            if (typeof this.props.onOverflowChange === \"function\") {\n                this.props.onOverflowChange({\n                    overflowStart: this.overflowStart,\n                    overflowEnd: this.overflowEnd,\n                });\n            }\n        };\n        /**\n         * Handler for the previous click event\n         */\n        this.handlePreviousClick = () => {\n            this.handleClick(ButtonDirection.previous);\n        };\n        /**\n         * Handler for the next click event\n         */\n        this.handleNextClick = () => {\n            this.handleClick(ButtonDirection.next);\n        };\n        /**\n         * Request's an animation frame if there are currently no open animation frame requests\n         */\n        this.requestFrame = () => {\n            if (this.openRequestAnimationFrame === null) {\n                this.openRequestAnimationFrame = window.requestAnimationFrame(this.updateScrollAnimation);\n            }\n        };\n        /**\n         *  Animate one frame of scrolling\n         */\n        this.updateScrollAnimation = () => {\n            this.openRequestAnimationFrame = null;\n            const duration = this.props.scrollDuration\n                ? this.props.scrollDuration\n                : HorizontalOverflow.defaultScrollAnimationDuration;\n            const currentDate = new Date().getTime();\n            const currentTime = currentDate - this.currentScrollAnimStartTime;\n            this.setScrollPosition(this.getScrollAnimationPosition(currentTime, duration));\n            if (currentTime < duration) {\n                this.requestFrame();\n            }\n            else {\n                this.isScrollAnimating = false;\n            }\n        };\n        /**\n         *  get scroll animation position for the provided time\n         */\n        this.getScrollAnimationPosition = (currentTime, duration) => {\n            if (currentTime < duration) {\n                return this.easeInOutQuad(currentTime, this.currentScrollAnimStartPosition, this.currentScrollAnimEndPosition - this.currentScrollAnimStartPosition, duration);\n            }\n            else {\n                return this.currentScrollAnimEndPosition;\n            }\n        };\n        /**\n         *  Gets the scroll position and accounts for direction\n         */\n        this.getScrollPosition = () => {\n            if (isNil(this.horizontalOverflowItemsRef.current)) {\n                return 0;\n            }\n            const scrollLeft = RtlScrollConverter.getScrollLeft(this.horizontalOverflowItemsRef.current, this.state.direction);\n            return this.state.direction === Direction.rtl ? -scrollLeft : scrollLeft;\n        };\n        /**\n         *  Sets the scroll position and accounts for direction\n         */\n        this.setScrollPosition = (scrollValue) => {\n            if (!isNil(this.horizontalOverflowItemsRef.current)) {\n                RtlScrollConverter.setScrollLeft(this.horizontalOverflowItemsRef.current, this.state.direction === Direction.rtl ? -scrollValue : scrollValue, this.state.direction);\n            }\n        };\n        /**\n         *  updates the direction in state if necessary\n         */\n        this.updateDirection = () => {\n            const newDirection = this.getDirection();\n            if (newDirection !== this.state.direction) {\n                this.setState({\n                    direction: newDirection,\n                });\n            }\n        };\n        /**\n         *  gets the current direction\n         */\n        this.getDirection = () => {\n            if (this.horizontalOverflowItemsRef.current === null) {\n                return Direction.ltr;\n            }\n            const closest = this.horizontalOverflowItemsRef.current.closest(`[${HorizontalOverflow.DirectionAttributeName}]`);\n            return closest === null ||\n                closest.getAttribute(HorizontalOverflow.DirectionAttributeName) ===\n                    Direction.ltr\n                ? Direction.ltr\n                : Direction.rtl;\n        };\n        this.horizontalOverflowItemsRef = React.createRef();\n        this.throttledScroll = throttle(this.onScrollChange);\n        this.throttledResize = throttle(this.onWindowResize);\n        this.overflow = false;\n        this.state = {\n            direction: Direction.ltr,\n            itemsHeight: null,\n        };\n    }\n    /**\n     * Renders the Horizontal Overflow markup\n     */\n    render() {\n        const { horizontalOverflow_contentRegion, horizontalOverflow_previous, horizontalOverflow_next, } = this.props.managedClasses;\n        return (React.createElement(\"div\", Object.assign({}, this.unhandledProps(), { className: this.generateClassNames(), onLoad: this.itemsOnLoad }),\n            React.createElement(\"div\", { style: {\n                    height: this.state.itemsHeight !== null\n                        ? `${this.state.itemsHeight}px`\n                        : \"auto\",\n                    position: \"relative\",\n                    overflow: \"hidden\",\n                } },\n                React.createElement(\"ul\", { className: classNames(horizontalOverflow_contentRegion), style: this.getListStyle(), ref: this.horizontalOverflowItemsRef, onScrollCapture: this.onScrollCapture }, this.getItems())),\n            React.createElement(\"div\", { className: classNames(horizontalOverflow_previous), onClick: this.handlePreviousClick }, this.withSlot(ButtonDirection.previous)),\n            React.createElement(\"div\", { className: classNames(horizontalOverflow_next), onClick: this.handleNextClick }, this.withSlot(ButtonDirection.next))));\n    }\n    /**\n     * React life-cycle method\n     */\n    componentDidMount() {\n        if (!this.props.children) {\n            return;\n        }\n        const itemsHeight = this.getItemMaxHeight();\n        this.setState({\n            itemsHeight,\n        });\n        if (canUseDOM() && this.horizontalOverflowItemsRef.current) {\n            this.updateDirection();\n            this.lastRecordedScroll = this.getScrollPosition();\n            this.horizontalOverflowItemsRef.current.addEventListener(\"scroll\", this.throttledScroll);\n            window.addEventListener(\"resize\", this.throttledResize);\n            // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142\n            // Full browser support imminent\n            // Revisit usage once Safari and Firefox adapt\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409\n            // https://bugs.webkit.org/show_bug.cgi?id=157743\n            if (window.ResizeObserver) {\n                this.resizeObserver = new window.ResizeObserver((entries) => {\n                    if (this.overflow !== this.isOverflow()) {\n                        this.handleOverflowChange();\n                    }\n                });\n                this.resizeObserver.observe(this.horizontalOverflowItemsRef.current);\n            }\n        }\n    }\n    /**\n     * React life-cycle method\n     */\n    componentWillUnmount() {\n        if (canUseDOM() && this.horizontalOverflowItemsRef.current) {\n            this.horizontalOverflowItemsRef.current.removeEventListener(\"scroll\", this.throttledScroll);\n            window.removeEventListener(\"resize\", this.throttledResize);\n            // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142\n            // Full browser support imminent\n            // Revisit usage once Safari and Firefox adapt\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409\n            // https://bugs.webkit.org/show_bug.cgi?id=157743\n            if (this.resizeObserver &&\n                typeof this.resizeObserver.disconnect === \"function\") {\n                this.resizeObserver.disconnect();\n                this.resizeObserver = null;\n            }\n            // Cancel any pending calls\n            this.throttledResize.cancel();\n            this.throttledScroll.cancel();\n        }\n    }\n    /**\n     * React life-cycle method\n     */\n    getSnapshotBeforeUpdate(prevProps) {\n        if (React.Children.toArray(prevProps.children).length <\n            React.Children.toArray(this.props.children).length) {\n            return true;\n        }\n        return null;\n    }\n    /**\n     * React life-cycle method\n     */\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        if (snapshot !== null) {\n            this.handleOverflowChange();\n        }\n        this.updateDirection();\n    }\n    /**\n     * Generates class names\n     */\n    generateClassNames() {\n        return super.generateClassNames(classNames(this.props.managedClasses.horizontalOverflow));\n    }\n    /**\n     * Gets the style for the `ul` element containing the items\n     */\n    getListStyle() {\n        return {\n            position: \"relative\",\n            whiteSpace: \"nowrap\",\n            overflowX: \"scroll\",\n            padding: 0,\n            margin: 0,\n        };\n    }\n    /**\n     * Checks if overflow is occuring\n     */\n    isOverflow() {\n        const availableWidth = this.getAvailableWidth();\n        const itemWidths = this.getItemWidths();\n        const totalItemWidth = itemWidths.reduce((a, b) => a + b);\n        return totalItemWidth > availableWidth;\n    }\n    /**\n     * Identifies and returns the tallest child height\n     */\n    getItemMaxHeight() {\n        let itemMaxHeight = 0;\n        const children = get(this.horizontalOverflowItemsRef, \"current.childNodes\");\n        if (!canUseDOM() || !children) {\n            return itemMaxHeight;\n        }\n        const childNodes = Array.prototype.slice.call(children);\n        for (const childNode of childNodes) {\n            const childNodeHeight = getClientRectWithMargin(childNode).height;\n            if (childNodeHeight > itemMaxHeight) {\n                itemMaxHeight = childNodeHeight;\n            }\n        }\n        return itemMaxHeight;\n    }\n    /**\n     * Gets the children displayed as items to be scrolled\n     */\n    getItems() {\n        return React.Children.map(this.withoutSlot([ButtonDirection.previous, ButtonDirection.next]), (child, index) => {\n            return (React.createElement(\"li\", { onFocusCapture: this.onItemFocus, className: classNames(this.props.managedClasses.horizontalOverflow_item), style: { display: \"inline-block\" } }, child));\n        });\n    }\n    /**\n     * Gets the distance to scroll based on the direction\n     */\n    getScrollDistanceFromButtonDirection(buttonDirection, itemWidths, scrollPosition) {\n        if (itemWidths.length === 0 || !canUseDOM()) {\n            return 0;\n        }\n        let distance = 0;\n        if (buttonDirection === ButtonDirection.next) {\n            distance = this.getWithinMaxDistance(scrollPosition, itemWidths);\n        }\n        else {\n            distance = this.getWithinMinDistance(scrollPosition, itemWidths);\n        }\n        return Math.ceil(distance);\n    }\n    /**\n     * Gets the distance unless it is over the maximum distance, then use maximum distance instead\n     */\n    getWithinMaxDistance(scrollPosition, itemWidths) {\n        const maxDistance = this.getMaxScrollDistance();\n        if (scrollPosition === maxDistance) {\n            return maxDistance;\n        }\n        const distance = this.getNextDistance(itemWidths, scrollPosition);\n        return distance >= maxDistance ? maxDistance : distance;\n    }\n    /**\n     * Gets the distance unless it is under the minimum distance, then use minimum distance instead\n     */\n    getWithinMinDistance(scrollPosition, itemWidths) {\n        if (scrollPosition === 0) {\n            return 0;\n        }\n        const distance = this.getPreviousDistance(itemWidths, scrollPosition);\n        return distance <= 0 ? 0 : distance;\n    }\n    /**\n     * Gets the distance to scroll if the next button has been clicked\n     */\n    getNextDistance(itemWidths, scrollPosition) {\n        let distance = 0;\n        for (let i = 0, itemWidthsLength = itemWidths.length; i < itemWidthsLength; i++) {\n            if (distance + itemWidths[i] > scrollPosition + this.getAvailableWidth() &&\n                distance !== scrollPosition) {\n                return distance + this.getScrollPeek(itemWidths[i]);\n            }\n            distance += itemWidths[i];\n        }\n        return distance;\n    }\n    /**\n     * Gets the distance to scroll if the previous button has been clicked\n     */\n    getPreviousDistance(itemWidths, scrollPosition) {\n        const availableWidth = this.getAvailableWidth();\n        let distance = this.getMaxScrollDistance() + availableWidth;\n        for (let i = itemWidths.length - 1; i >= 0; i--) {\n            if (distance - itemWidths[i] < scrollPosition - availableWidth &&\n                distance !== scrollPosition) {\n                return distance - this.getScrollPeek(itemWidths[i]);\n            }\n            distance -= itemWidths[i];\n        }\n        return distance;\n    }\n    /**\n     * Gets the maximum distance that can be scrolled\n     */\n    getMaxScrollDistance() {\n        if (isNil(this.horizontalOverflowItemsRef.current)) {\n            return 0;\n        }\n        return (this.horizontalOverflowItemsRef.current.scrollWidth - this.getAvailableWidth());\n    }\n    /**\n     * Handler for the click event fired after next or previous has been clicked\n     */\n    handleClick(buttonDirection) {\n        this.scrollContent(this.getScrollPosition(), this.getScrollDistanceFromButtonDirection(buttonDirection, this.getItemWidths(), this.getScrollPosition()));\n    }\n    /**\n     * Returns the available content region width\n     */\n    getAvailableWidth() {\n        if (isNil(this.horizontalOverflowItemsRef.current)) {\n            return 0;\n        }\n        return this.horizontalOverflowItemsRef.current.clientWidth;\n    }\n    /**\n     * Returns the items widths\n     */\n    getItemWidths() {\n        if (isNil(this.horizontalOverflowItemsRef.current)) {\n            return null;\n        }\n        const items = Array.prototype.slice.call(this.horizontalOverflowItemsRef.current.childNodes);\n        const itemWidths = [];\n        for (const item of items) {\n            itemWidths.push(getClientRectWithMargin(item).width);\n        }\n        return itemWidths;\n    }\n    /**\n     * Easing animation\n     * Inspired by the github gist contribution: https://gist.github.com/andjosh/6764939\n     */\n    easeInOutQuad(currentTime, startValue, changeInValue, duration) {\n        currentTime /= duration / 2;\n        if (currentTime < 1) {\n            return (changeInValue / 2) * currentTime * currentTime + startValue;\n        }\n        currentTime--;\n        return (-changeInValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;\n    }\n    /**\n     * Scrolls the container for the items list\n     */\n    scrollContent(startScrollPosition, targetScrollPosition) {\n        const newScrollPosition = Math.max(0, Math.min(targetScrollPosition, this.getMaxScrollDistance()));\n        this.isScrollAnimating = true;\n        this.currentScrollAnimStartPosition = startScrollPosition;\n        this.currentScrollAnimEndPosition = newScrollPosition;\n        this.currentScrollAnimStartTime = new Date().getTime();\n        this.requestFrame();\n    }\n}\nHorizontalOverflow.displayName = `${DisplayNamePrefix}HorizontalOverflow`;\nHorizontalOverflow.defaultProps = {\n    managedClasses: {},\n    nextItemPeek: 50,\n};\nHorizontalOverflow.DirectionAttributeName = \"dir\";\nHorizontalOverflow.defaultScrollAnimationDuration = 500;\nexport default HorizontalOverflow;\n"]},"metadata":{},"sourceType":"module"}