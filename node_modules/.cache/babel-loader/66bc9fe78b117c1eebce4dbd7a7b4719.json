{"ast":null,"code":"/**\n * For each possible color, this counts how many pixels in the source image match that color.\n * If signifigantBits is less tahn 8, each channel (eg: red, green, blue) in each color is reduced to fit in significantBits. So for the default value of 5 significantBits colors are reduced from 8 bits per channel (0-255) to 5 (0-31). Colors that were previously distinct get combined together.\n * If the image source has more than 2^32 pixels (eg: a square image 65536x65536 in size) of the same color this code will break.\n */\nexport class Histogram {\n  /**\n   * @param source\n   * @param significantBits The memory needed for the histogram increases dramaticially if significantBits is increased. It needs a buffer which is 4*2^(3*significantBits) in size. EG: for 5 significant bits the histogram is 128K while for 8 it is 64 megs.\n   * @param pixelSkipping CPU time increases linearly as pixelSkipping is reduced.\n   * @param isHistogramPixelValid isHistogramPixelValid is an optional predicate which can screen out unwanted pixels from the source data. EG: ignoring transparent pixels.\n   */\n  constructor(source, significantBits = 5, pixelSkipping = 5, isHistogramPixelValid = null) {\n    this.getHistogramIndex = (r, g, b) => {\n      const index = (r << 2 * this.significantBits) + (g << this.significantBits) + b;\n\n      if (index >= this.data.length) {\n        throw new Error(\"RGB value is outside the bounds of the histogram\");\n      }\n\n      return index;\n    };\n\n    this.getHistogramValue = (r, g, b) => {\n      return this.data[this.getHistogramIndex(r, g, b)];\n    };\n\n    this.setHistogramValue = (value, r, g, b) => {\n      this.data[this.getHistogramIndex(r, g, b)] = value;\n    };\n\n    if (significantBits < 1 || significantBits > 8) {\n      throw new Error(\"significantBits must be in the range [1,8]\");\n    }\n\n    if (pixelSkipping < 0) {\n      throw new Error(\"pixelSkipping must be >= 0\");\n    }\n\n    this.significantBits = significantBits;\n    const sigShift = 8 - this.significantBits;\n    this.minRed = 255 >>> sigShift;\n    this.maxRed = 0;\n    this.minGreen = 255 >>> sigShift;\n    this.maxGreen = 0;\n    this.minBlue = 255 >>> sigShift;\n    this.maxBlue = 0;\n    const histoSize = 1 << significantBits * 3;\n    this.data = new Uint32Array(histoSize);\n    this.data.fill(0);\n    this.total = 0;\n    let pixelIndex = 0;\n\n    for (let y = 0; y < source.height; y++) {\n      for (let x = 0; x < source.width; x++) {\n        if (pixelSkipping > 0 && pixelIndex++ % pixelSkipping !== 0) {\n          continue;\n        }\n\n        const rgba = source.getPixelRGBA(x, y);\n\n        if (isHistogramPixelValid !== null) {\n          if (!isHistogramPixelValid(rgba)) {\n            continue;\n          }\n        } // Shift the pixel data into the range determined by significantBits\n        // after checking minAlpha the alpha data is no longer needed\n\n\n        rgba[0] = rgba[0] >>> sigShift;\n        rgba[1] = rgba[1] >>> sigShift;\n        rgba[2] = rgba[2] >>> sigShift;\n        this.minRed = Math.min(rgba[0], this.minRed);\n        this.maxRed = Math.max(rgba[0], this.maxRed);\n        this.minGreen = Math.min(rgba[1], this.minGreen);\n        this.maxGreen = Math.max(rgba[1], this.maxGreen);\n        this.minBlue = Math.min(rgba[2], this.minBlue);\n        this.maxBlue = Math.max(rgba[2], this.maxBlue);\n        const histoIndex = this.getHistogramIndex(rgba[0], rgba[1], rgba[2]);\n        this.data[histoIndex] += 1;\n        this.total++;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-colors/dist/histogram.js"],"names":["Histogram","constructor","source","significantBits","pixelSkipping","isHistogramPixelValid","getHistogramIndex","r","g","b","index","data","length","Error","getHistogramValue","setHistogramValue","value","sigShift","minRed","maxRed","minGreen","maxGreen","minBlue","maxBlue","histoSize","Uint32Array","fill","total","pixelIndex","y","height","x","width","rgba","getPixelRGBA","Math","min","max","histoIndex"],"mappings":"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","sourcesContent":["/**\n * For each possible color, this counts how many pixels in the source image match that color.\n * If signifigantBits is less tahn 8, each channel (eg: red, green, blue) in each color is reduced to fit in significantBits. So for the default value of 5 significantBits colors are reduced from 8 bits per channel (0-255) to 5 (0-31). Colors that were previously distinct get combined together.\n * If the image source has more than 2^32 pixels (eg: a square image 65536x65536 in size) of the same color this code will break.\n */\nexport class Histogram {\n    /**\n     * @param source\n     * @param significantBits The memory needed for the histogram increases dramaticially if significantBits is increased. It needs a buffer which is 4*2^(3*significantBits) in size. EG: for 5 significant bits the histogram is 128K while for 8 it is 64 megs.\n     * @param pixelSkipping CPU time increases linearly as pixelSkipping is reduced.\n     * @param isHistogramPixelValid isHistogramPixelValid is an optional predicate which can screen out unwanted pixels from the source data. EG: ignoring transparent pixels.\n     */\n    constructor(source, significantBits = 5, pixelSkipping = 5, isHistogramPixelValid = null) {\n        this.getHistogramIndex = (r, g, b) => {\n            const index = (r << (2 * this.significantBits)) + (g << this.significantBits) + b;\n            if (index >= this.data.length) {\n                throw new Error(\"RGB value is outside the bounds of the histogram\");\n            }\n            return index;\n        };\n        this.getHistogramValue = (r, g, b) => {\n            return this.data[this.getHistogramIndex(r, g, b)];\n        };\n        this.setHistogramValue = (value, r, g, b) => {\n            this.data[this.getHistogramIndex(r, g, b)] = value;\n        };\n        if (significantBits < 1 || significantBits > 8) {\n            throw new Error(\"significantBits must be in the range [1,8]\");\n        }\n        if (pixelSkipping < 0) {\n            throw new Error(\"pixelSkipping must be >= 0\");\n        }\n        this.significantBits = significantBits;\n        const sigShift = 8 - this.significantBits;\n        this.minRed = 255 >>> sigShift;\n        this.maxRed = 0;\n        this.minGreen = 255 >>> sigShift;\n        this.maxGreen = 0;\n        this.minBlue = 255 >>> sigShift;\n        this.maxBlue = 0;\n        const histoSize = 1 << (significantBits * 3);\n        this.data = new Uint32Array(histoSize);\n        this.data.fill(0);\n        this.total = 0;\n        let pixelIndex = 0;\n        for (let y = 0; y < source.height; y++) {\n            for (let x = 0; x < source.width; x++) {\n                if (pixelSkipping > 0 && pixelIndex++ % pixelSkipping !== 0) {\n                    continue;\n                }\n                const rgba = source.getPixelRGBA(x, y);\n                if (isHistogramPixelValid !== null) {\n                    if (!isHistogramPixelValid(rgba)) {\n                        continue;\n                    }\n                }\n                // Shift the pixel data into the range determined by significantBits\n                // after checking minAlpha the alpha data is no longer needed\n                rgba[0] = rgba[0] >>> sigShift;\n                rgba[1] = rgba[1] >>> sigShift;\n                rgba[2] = rgba[2] >>> sigShift;\n                this.minRed = Math.min(rgba[0], this.minRed);\n                this.maxRed = Math.max(rgba[0], this.maxRed);\n                this.minGreen = Math.min(rgba[1], this.minGreen);\n                this.maxGreen = Math.max(rgba[1], this.maxGreen);\n                this.minBlue = Math.min(rgba[2], this.minBlue);\n                this.maxBlue = Math.max(rgba[2], this.maxBlue);\n                const histoIndex = this.getHistogramIndex(rgba[0], rgba[1], rgba[2]);\n                this.data[histoIndex] += 1;\n                this.total++;\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}