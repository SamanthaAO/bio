{"ast":null,"code":"import Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames, Direction, getClientRectWithMargin, RtlScrollConverter } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isNil } from \"lodash-es\";\nimport throttle from \"raf-throttle\";\nimport React from \"react\";\nimport { DisplayNamePrefix } from \"../utilities\";\nexport var ButtonDirection;\n\n(function (ButtonDirection) {\n  ButtonDirection[\"previous\"] = \"previous\";\n  ButtonDirection[\"next\"] = \"next\";\n})(ButtonDirection || (ButtonDirection = {}));\n\nclass HorizontalOverflow extends Foundation {\n  /**\n   * Constructor\n   */\n  constructor(props) {\n    super(props);\n    this.handledProps = {\n      scrollDuration: void 0,\n      managedClasses: void 0,\n      onScrollChange: void 0,\n      onOverflowChange: void 0,\n      nextItemPeek: void 0\n    };\n    /**\n     * Stores pending animation frame requests\n     */\n\n    this.openRequestAnimationFrame = null;\n    /**\n     * Flag indicates if a scroll animation is in progress\n     */\n\n    this.isScrollAnimating = false;\n    /**\n     * Stores last scroll position from scroll events\n     */\n\n    this.lastRecordedScroll = 0;\n    /**\n     * Track scroll position\n     */\n\n    this.onScrollCapture = event => {\n      this.lastRecordedScroll = this.getScrollPosition();\n    };\n    /**\n     * A child item got focus make sure it is in view\n     */\n\n\n    this.onItemFocus = event => {\n      if (!this.isOverflow()) {\n        return;\n      }\n\n      const itemLeft = event.currentTarget.offsetLeft;\n      const itemWidth = event.currentTarget.clientWidth;\n      const itemRight = itemLeft + itemWidth;\n      const viewportWidth = this.getAvailableWidth();\n      const peek = this.getScrollPeek(itemWidth);\n      let scrollStart = this.lastRecordedScroll;\n\n      if (this.isScrollAnimating) {\n        const duration = this.props.scrollDuration ? this.props.scrollDuration : HorizontalOverflow.defaultScrollAnimationDuration;\n        const currentDate = new Date().getTime();\n        const currentTime = currentDate - this.currentScrollAnimStartTime;\n        scrollStart = this.getScrollAnimationPosition(currentTime, duration);\n      }\n\n      if (itemLeft - this.lastRecordedScroll < 0) {\n        this.scrollContent(scrollStart, itemLeft - peek);\n      } else if (itemRight - scrollStart > viewportWidth) {\n        this.scrollContent(scrollStart, itemRight - viewportWidth + peek);\n      }\n    };\n    /**\n     *  Compares viewport width, item width and desired peek value to come up with\n     *  peek value to use. We don't want to clip focused item to get peek on next/previous item.\n     */\n\n\n    this.getScrollPeek = itemWidth => {\n      const viewportWidth = this.getAvailableWidth();\n      let maxPeek = viewportWidth - itemWidth;\n      maxPeek = maxPeek < 0 ? 0 : maxPeek;\n      const peek = this.props.nextItemPeek > maxPeek ? maxPeek : this.props.nextItemPeek;\n      return peek;\n    };\n    /**\n     * Callback for on scroll change\n     */\n\n\n    this.onScrollChange = () => {\n      if (typeof this.props.onScrollChange === \"function\") {\n        this.props.onScrollChange(this.getPositionData());\n      } // If the onOverflowChange callback exists, we want to update overflow\n      // based on scroll change\n\n\n      if (typeof this.props.onOverflowChange === \"function\") {\n        const positionData = this.getPositionData();\n\n        if (this.overflowStart === !positionData.start || this.overflowEnd === !positionData.end) {\n          this.handleOverflowChange();\n        }\n      }\n    };\n    /**\n     * Get the scroll change data\n     */\n\n\n    this.getPositionData = () => {\n      if (isNil(this.horizontalOverflowItemsRef.current)) {\n        return {\n          start: true,\n          end: true\n        };\n      }\n\n      const scrollPosition = this.getScrollPosition();\n      const isAtBeginning = scrollPosition === 0;\n      const isAtEnd = this.horizontalOverflowItemsRef.current.scrollWidth - scrollPosition === this.horizontalOverflowItemsRef.current.clientWidth;\n      return {\n        start: isAtBeginning,\n        end: isAtEnd\n      };\n    };\n    /**\n     * onLoad handler to make sure any children affecting height are accounted for\n     */\n\n\n    this.itemsOnLoad = () => {\n      const itemsHeight = this.getItemMaxHeight();\n\n      if (itemsHeight !== this.state.itemsHeight) {\n        this.setState({\n          itemsHeight\n        });\n      }\n\n      if (this.overflow !== this.isOverflow()) {\n        this.handleOverflowChange();\n      }\n    };\n    /**\n     * Handles the resize event\n     */\n\n\n    this.onWindowResize = () => {\n      if (this.overflow !== this.isOverflow()) {\n        this.handleOverflowChange();\n      }\n    };\n    /**\n     * Callback for the horizontal overflow change\n     */\n\n\n    this.handleOverflowChange = () => {\n      this.overflow = this.isOverflow();\n\n      if (this.overflow) {\n        const positionData = this.getPositionData();\n        this.overflowStart = !positionData.start;\n        this.overflowEnd = !positionData.end;\n      } else {\n        this.overflowStart = false;\n        this.overflowEnd = false;\n      }\n\n      if (typeof this.props.onOverflowChange === \"function\") {\n        this.props.onOverflowChange({\n          overflowStart: this.overflowStart,\n          overflowEnd: this.overflowEnd\n        });\n      }\n    };\n    /**\n     * Handler for the previous click event\n     */\n\n\n    this.handlePreviousClick = () => {\n      this.handleClick(ButtonDirection.previous);\n    };\n    /**\n     * Handler for the next click event\n     */\n\n\n    this.handleNextClick = () => {\n      this.handleClick(ButtonDirection.next);\n    };\n    /**\n     * Request's an animation frame if there are currently no open animation frame requests\n     */\n\n\n    this.requestFrame = () => {\n      if (this.openRequestAnimationFrame === null) {\n        this.openRequestAnimationFrame = window.requestAnimationFrame(this.updateScrollAnimation);\n      }\n    };\n    /**\n     *  Animate one frame of scrolling\n     */\n\n\n    this.updateScrollAnimation = () => {\n      this.openRequestAnimationFrame = null;\n      const duration = this.props.scrollDuration ? this.props.scrollDuration : HorizontalOverflow.defaultScrollAnimationDuration;\n      const currentDate = new Date().getTime();\n      const currentTime = currentDate - this.currentScrollAnimStartTime;\n      this.setScrollPosition(this.getScrollAnimationPosition(currentTime, duration));\n\n      if (currentTime < duration) {\n        this.requestFrame();\n      } else {\n        this.isScrollAnimating = false;\n      }\n    };\n    /**\n     *  get scroll animation position for the provided time\n     */\n\n\n    this.getScrollAnimationPosition = (currentTime, duration) => {\n      if (currentTime < duration) {\n        return this.easeInOutQuad(currentTime, this.currentScrollAnimStartPosition, this.currentScrollAnimEndPosition - this.currentScrollAnimStartPosition, duration);\n      } else {\n        return this.currentScrollAnimEndPosition;\n      }\n    };\n    /**\n     *  Gets the scroll position and accounts for direction\n     */\n\n\n    this.getScrollPosition = () => {\n      if (isNil(this.horizontalOverflowItemsRef.current)) {\n        return 0;\n      }\n\n      const scrollLeft = RtlScrollConverter.getScrollLeft(this.horizontalOverflowItemsRef.current, this.state.direction);\n      return this.state.direction === Direction.rtl ? -scrollLeft : scrollLeft;\n    };\n    /**\n     *  Sets the scroll position and accounts for direction\n     */\n\n\n    this.setScrollPosition = scrollValue => {\n      if (!isNil(this.horizontalOverflowItemsRef.current)) {\n        RtlScrollConverter.setScrollLeft(this.horizontalOverflowItemsRef.current, this.state.direction === Direction.rtl ? -scrollValue : scrollValue, this.state.direction);\n      }\n    };\n    /**\n     *  updates the direction in state if necessary\n     */\n\n\n    this.updateDirection = () => {\n      const newDirection = this.getDirection();\n\n      if (newDirection !== this.state.direction) {\n        this.setState({\n          direction: newDirection\n        });\n      }\n    };\n    /**\n     *  gets the current direction\n     */\n\n\n    this.getDirection = () => {\n      if (this.horizontalOverflowItemsRef.current === null) {\n        return Direction.ltr;\n      }\n\n      const closest = this.horizontalOverflowItemsRef.current.closest(`[${HorizontalOverflow.DirectionAttributeName}]`);\n      return closest === null || closest.getAttribute(HorizontalOverflow.DirectionAttributeName) === Direction.ltr ? Direction.ltr : Direction.rtl;\n    };\n\n    this.horizontalOverflowItemsRef = React.createRef();\n    this.throttledScroll = throttle(this.onScrollChange);\n    this.throttledResize = throttle(this.onWindowResize);\n    this.overflow = false;\n    this.state = {\n      direction: Direction.ltr,\n      itemsHeight: null\n    };\n  }\n  /**\n   * Renders the Horizontal Overflow markup\n   */\n\n\n  render() {\n    const _this$props$managedCl = this.props.managedClasses,\n          horizontalOverflow_contentRegion = _this$props$managedCl.horizontalOverflow_contentRegion,\n          horizontalOverflow_previous = _this$props$managedCl.horizontalOverflow_previous,\n          horizontalOverflow_next = _this$props$managedCl.horizontalOverflow_next;\n    return React.createElement(\"div\", Object.assign({}, this.unhandledProps(), {\n      className: this.generateClassNames(),\n      onLoad: this.itemsOnLoad\n    }), React.createElement(\"div\", {\n      style: {\n        height: this.state.itemsHeight !== null ? `${this.state.itemsHeight}px` : \"auto\",\n        position: \"relative\",\n        overflow: \"hidden\"\n      }\n    }, React.createElement(\"ul\", {\n      className: classNames(horizontalOverflow_contentRegion),\n      style: this.getListStyle(),\n      ref: this.horizontalOverflowItemsRef,\n      onScrollCapture: this.onScrollCapture\n    }, this.getItems())), React.createElement(\"div\", {\n      className: classNames(horizontalOverflow_previous),\n      onClick: this.handlePreviousClick\n    }, this.withSlot(ButtonDirection.previous)), React.createElement(\"div\", {\n      className: classNames(horizontalOverflow_next),\n      onClick: this.handleNextClick\n    }, this.withSlot(ButtonDirection.next)));\n  }\n  /**\n   * React life-cycle method\n   */\n\n\n  componentDidMount() {\n    if (!this.props.children) {\n      return;\n    }\n\n    const itemsHeight = this.getItemMaxHeight();\n    this.setState({\n      itemsHeight\n    });\n\n    if (canUseDOM() && this.horizontalOverflowItemsRef.current) {\n      this.updateDirection();\n      this.lastRecordedScroll = this.getScrollPosition();\n      this.horizontalOverflowItemsRef.current.addEventListener(\"scroll\", this.throttledScroll);\n      window.addEventListener(\"resize\", this.throttledResize); // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142\n      // Full browser support imminent\n      // Revisit usage once Safari and Firefox adapt\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409\n      // https://bugs.webkit.org/show_bug.cgi?id=157743\n\n      if (window.ResizeObserver) {\n        this.resizeObserver = new window.ResizeObserver(entries => {\n          if (this.overflow !== this.isOverflow()) {\n            this.handleOverflowChange();\n          }\n        });\n        this.resizeObserver.observe(this.horizontalOverflowItemsRef.current);\n      }\n    }\n  }\n  /**\n   * React life-cycle method\n   */\n\n\n  componentWillUnmount() {\n    if (canUseDOM() && this.horizontalOverflowItemsRef.current) {\n      this.horizontalOverflowItemsRef.current.removeEventListener(\"scroll\", this.throttledScroll);\n      window.removeEventListener(\"resize\", this.throttledResize); // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142\n      // Full browser support imminent\n      // Revisit usage once Safari and Firefox adapt\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409\n      // https://bugs.webkit.org/show_bug.cgi?id=157743\n\n      if (this.resizeObserver && typeof this.resizeObserver.disconnect === \"function\") {\n        this.resizeObserver.disconnect();\n        this.resizeObserver = null;\n      } // Cancel any pending calls\n\n\n      this.throttledResize.cancel();\n      this.throttledScroll.cancel();\n    }\n  }\n  /**\n   * React life-cycle method\n   */\n\n\n  getSnapshotBeforeUpdate(prevProps) {\n    if (React.Children.toArray(prevProps.children).length < React.Children.toArray(this.props.children).length) {\n      return true;\n    }\n\n    return null;\n  }\n  /**\n   * React life-cycle method\n   */\n\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    if (snapshot !== null) {\n      this.handleOverflowChange();\n    }\n\n    this.updateDirection();\n  }\n  /**\n   * Generates class names\n   */\n\n\n  generateClassNames() {\n    return super.generateClassNames(classNames(this.props.managedClasses.horizontalOverflow));\n  }\n  /**\n   * Gets the style for the `ul` element containing the items\n   */\n\n\n  getListStyle() {\n    return {\n      position: \"relative\",\n      whiteSpace: \"nowrap\",\n      overflowX: \"scroll\",\n      padding: 0,\n      margin: 0\n    };\n  }\n  /**\n   * Checks if overflow is occuring\n   */\n\n\n  isOverflow() {\n    const availableWidth = this.getAvailableWidth();\n    const itemWidths = this.getItemWidths();\n    const totalItemWidth = itemWidths.reduce((a, b) => a + b);\n    return totalItemWidth > availableWidth;\n  }\n  /**\n   * Identifies and returns the tallest child height\n   */\n\n\n  getItemMaxHeight() {\n    let itemMaxHeight = 0;\n    const children = get(this.horizontalOverflowItemsRef, \"current.childNodes\");\n\n    if (!canUseDOM() || !children) {\n      return itemMaxHeight;\n    }\n\n    const childNodes = Array.prototype.slice.call(children);\n\n    for (const childNode of childNodes) {\n      const childNodeHeight = getClientRectWithMargin(childNode).height;\n\n      if (childNodeHeight > itemMaxHeight) {\n        itemMaxHeight = childNodeHeight;\n      }\n    }\n\n    return itemMaxHeight;\n  }\n  /**\n   * Gets the children displayed as items to be scrolled\n   */\n\n\n  getItems() {\n    return React.Children.map(this.withoutSlot([ButtonDirection.previous, ButtonDirection.next]), (child, index) => {\n      return React.createElement(\"li\", {\n        onFocusCapture: this.onItemFocus,\n        className: classNames(this.props.managedClasses.horizontalOverflow_item),\n        style: {\n          display: \"inline-block\"\n        }\n      }, child);\n    });\n  }\n  /**\n   * Gets the distance to scroll based on the direction\n   */\n\n\n  getScrollDistanceFromButtonDirection(buttonDirection, itemWidths, scrollPosition) {\n    if (itemWidths.length === 0 || !canUseDOM()) {\n      return 0;\n    }\n\n    let distance = 0;\n\n    if (buttonDirection === ButtonDirection.next) {\n      distance = this.getWithinMaxDistance(scrollPosition, itemWidths);\n    } else {\n      distance = this.getWithinMinDistance(scrollPosition, itemWidths);\n    }\n\n    return Math.ceil(distance);\n  }\n  /**\n   * Gets the distance unless it is over the maximum distance, then use maximum distance instead\n   */\n\n\n  getWithinMaxDistance(scrollPosition, itemWidths) {\n    const maxDistance = this.getMaxScrollDistance();\n\n    if (scrollPosition === maxDistance) {\n      return maxDistance;\n    }\n\n    const distance = this.getNextDistance(itemWidths, scrollPosition);\n    return distance >= maxDistance ? maxDistance : distance;\n  }\n  /**\n   * Gets the distance unless it is under the minimum distance, then use minimum distance instead\n   */\n\n\n  getWithinMinDistance(scrollPosition, itemWidths) {\n    if (scrollPosition === 0) {\n      return 0;\n    }\n\n    const distance = this.getPreviousDistance(itemWidths, scrollPosition);\n    return distance <= 0 ? 0 : distance;\n  }\n  /**\n   * Gets the distance to scroll if the next button has been clicked\n   */\n\n\n  getNextDistance(itemWidths, scrollPosition) {\n    let distance = 0;\n\n    for (let i = 0, itemWidthsLength = itemWidths.length; i < itemWidthsLength; i++) {\n      if (distance + itemWidths[i] > scrollPosition + this.getAvailableWidth() && distance !== scrollPosition) {\n        return distance + this.getScrollPeek(itemWidths[i]);\n      }\n\n      distance += itemWidths[i];\n    }\n\n    return distance;\n  }\n  /**\n   * Gets the distance to scroll if the previous button has been clicked\n   */\n\n\n  getPreviousDistance(itemWidths, scrollPosition) {\n    const availableWidth = this.getAvailableWidth();\n    let distance = this.getMaxScrollDistance() + availableWidth;\n\n    for (let i = itemWidths.length - 1; i >= 0; i--) {\n      if (distance - itemWidths[i] < scrollPosition - availableWidth && distance !== scrollPosition) {\n        return distance - this.getScrollPeek(itemWidths[i]);\n      }\n\n      distance -= itemWidths[i];\n    }\n\n    return distance;\n  }\n  /**\n   * Gets the maximum distance that can be scrolled\n   */\n\n\n  getMaxScrollDistance() {\n    if (isNil(this.horizontalOverflowItemsRef.current)) {\n      return 0;\n    }\n\n    return this.horizontalOverflowItemsRef.current.scrollWidth - this.getAvailableWidth();\n  }\n  /**\n   * Handler for the click event fired after next or previous has been clicked\n   */\n\n\n  handleClick(buttonDirection) {\n    this.scrollContent(this.getScrollPosition(), this.getScrollDistanceFromButtonDirection(buttonDirection, this.getItemWidths(), this.getScrollPosition()));\n  }\n  /**\n   * Returns the available content region width\n   */\n\n\n  getAvailableWidth() {\n    if (isNil(this.horizontalOverflowItemsRef.current)) {\n      return 0;\n    }\n\n    return this.horizontalOverflowItemsRef.current.clientWidth;\n  }\n  /**\n   * Returns the items widths\n   */\n\n\n  getItemWidths() {\n    if (isNil(this.horizontalOverflowItemsRef.current)) {\n      return null;\n    }\n\n    const items = Array.prototype.slice.call(this.horizontalOverflowItemsRef.current.childNodes);\n    const itemWidths = [];\n\n    for (const item of items) {\n      itemWidths.push(getClientRectWithMargin(item).width);\n    }\n\n    return itemWidths;\n  }\n  /**\n   * Easing animation\n   * Inspired by the github gist contribution: https://gist.github.com/andjosh/6764939\n   */\n\n\n  easeInOutQuad(currentTime, startValue, changeInValue, duration) {\n    currentTime /= duration / 2;\n\n    if (currentTime < 1) {\n      return changeInValue / 2 * currentTime * currentTime + startValue;\n    }\n\n    currentTime--;\n    return -changeInValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;\n  }\n  /**\n   * Scrolls the container for the items list\n   */\n\n\n  scrollContent(startScrollPosition, targetScrollPosition) {\n    const newScrollPosition = Math.max(0, Math.min(targetScrollPosition, this.getMaxScrollDistance()));\n    this.isScrollAnimating = true;\n    this.currentScrollAnimStartPosition = startScrollPosition;\n    this.currentScrollAnimEndPosition = newScrollPosition;\n    this.currentScrollAnimStartTime = new Date().getTime();\n    this.requestFrame();\n  }\n\n}\n\nHorizontalOverflow.displayName = `${DisplayNamePrefix}HorizontalOverflow`;\nHorizontalOverflow.defaultProps = {\n  managedClasses: {},\n  nextItemPeek: 50\n};\nHorizontalOverflow.DirectionAttributeName = \"dir\";\nHorizontalOverflow.defaultScrollAnimationDuration = 500;\nexport default HorizontalOverflow;","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-react-base/dist/horizontal-overflow/horizontal-overflow.js"],"names":["Foundation","classNames","Direction","getClientRectWithMargin","RtlScrollConverter","canUseDOM","get","isNil","throttle","React","DisplayNamePrefix","ButtonDirection","HorizontalOverflow","constructor","props","handledProps","scrollDuration","managedClasses","onScrollChange","onOverflowChange","nextItemPeek","openRequestAnimationFrame","isScrollAnimating","lastRecordedScroll","onScrollCapture","event","getScrollPosition","onItemFocus","isOverflow","itemLeft","currentTarget","offsetLeft","itemWidth","clientWidth","itemRight","viewportWidth","getAvailableWidth","peek","getScrollPeek","scrollStart","duration","defaultScrollAnimationDuration","currentDate","Date","getTime","currentTime","currentScrollAnimStartTime","getScrollAnimationPosition","scrollContent","maxPeek","getPositionData","positionData","overflowStart","start","overflowEnd","end","handleOverflowChange","horizontalOverflowItemsRef","current","scrollPosition","isAtBeginning","isAtEnd","scrollWidth","itemsOnLoad","itemsHeight","getItemMaxHeight","state","setState","overflow","onWindowResize","handlePreviousClick","handleClick","previous","handleNextClick","next","requestFrame","window","requestAnimationFrame","updateScrollAnimation","setScrollPosition","easeInOutQuad","currentScrollAnimStartPosition","currentScrollAnimEndPosition","scrollLeft","getScrollLeft","direction","rtl","scrollValue","setScrollLeft","updateDirection","newDirection","getDirection","ltr","closest","DirectionAttributeName","getAttribute","createRef","throttledScroll","throttledResize","render","horizontalOverflow_contentRegion","horizontalOverflow_previous","horizontalOverflow_next","createElement","Object","assign","unhandledProps","className","generateClassNames","onLoad","style","height","position","getListStyle","ref","getItems","onClick","withSlot","componentDidMount","children","addEventListener","ResizeObserver","resizeObserver","entries","observe","componentWillUnmount","removeEventListener","disconnect","cancel","getSnapshotBeforeUpdate","prevProps","Children","toArray","length","componentDidUpdate","prevState","snapshot","horizontalOverflow","whiteSpace","overflowX","padding","margin","availableWidth","itemWidths","getItemWidths","totalItemWidth","reduce","a","b","itemMaxHeight","childNodes","Array","prototype","slice","call","childNode","childNodeHeight","map","withoutSlot","child","index","onFocusCapture","horizontalOverflow_item","display","getScrollDistanceFromButtonDirection","buttonDirection","distance","getWithinMaxDistance","getWithinMinDistance","Math","ceil","maxDistance","getMaxScrollDistance","getNextDistance","getPreviousDistance","i","itemWidthsLength","items","item","push","width","startValue","changeInValue","startScrollPosition","targetScrollPosition","newScrollPosition","max","min","displayName","defaultProps"],"mappings":"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","sourcesContent":["import Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { classNames, Direction, getClientRectWithMargin, RtlScrollConverter, } from \"@microsoft/fast-web-utilities\";\nimport { canUseDOM } from \"exenv-es6\";\nimport { get, isNil } from \"lodash-es\";\nimport throttle from \"raf-throttle\";\nimport React from \"react\";\nimport { DisplayNamePrefix, } from \"../utilities\";\nexport var ButtonDirection;\n(function (ButtonDirection) {\n    ButtonDirection[\"previous\"] = \"previous\";\n    ButtonDirection[\"next\"] = \"next\";\n})(ButtonDirection || (ButtonDirection = {}));\nclass HorizontalOverflow extends Foundation {\n    /**\n     * Constructor\n     */\n    constructor(props) {\n        super(props);\n        this.handledProps = {\n            scrollDuration: void 0,\n            managedClasses: void 0,\n            onScrollChange: void 0,\n            onOverflowChange: void 0,\n            nextItemPeek: void 0,\n        };\n        /**\n         * Stores pending animation frame requests\n         */\n        this.openRequestAnimationFrame = null;\n        /**\n         * Flag indicates if a scroll animation is in progress\n         */\n        this.isScrollAnimating = false;\n        /**\n         * Stores last scroll position from scroll events\n         */\n        this.lastRecordedScroll = 0;\n        /**\n         * Track scroll position\n         */\n        this.onScrollCapture = (event) => {\n            this.lastRecordedScroll = this.getScrollPosition();\n        };\n        /**\n         * A child item got focus make sure it is in view\n         */\n        this.onItemFocus = (event) => {\n            if (!this.isOverflow()) {\n                return;\n            }\n            const itemLeft = event.currentTarget.offsetLeft;\n            const itemWidth = event.currentTarget.clientWidth;\n            const itemRight = itemLeft + itemWidth;\n            const viewportWidth = this.getAvailableWidth();\n            const peek = this.getScrollPeek(itemWidth);\n            let scrollStart = this.lastRecordedScroll;\n            if (this.isScrollAnimating) {\n                const duration = this.props.scrollDuration\n                    ? this.props.scrollDuration\n                    : HorizontalOverflow.defaultScrollAnimationDuration;\n                const currentDate = new Date().getTime();\n                const currentTime = currentDate - this.currentScrollAnimStartTime;\n                scrollStart = this.getScrollAnimationPosition(currentTime, duration);\n            }\n            if (itemLeft - this.lastRecordedScroll < 0) {\n                this.scrollContent(scrollStart, itemLeft - peek);\n            }\n            else if (itemRight - scrollStart > viewportWidth) {\n                this.scrollContent(scrollStart, itemRight - viewportWidth + peek);\n            }\n        };\n        /**\n         *  Compares viewport width, item width and desired peek value to come up with\n         *  peek value to use. We don't want to clip focused item to get peek on next/previous item.\n         */\n        this.getScrollPeek = (itemWidth) => {\n            const viewportWidth = this.getAvailableWidth();\n            let maxPeek = viewportWidth - itemWidth;\n            maxPeek = maxPeek < 0 ? 0 : maxPeek;\n            const peek = this.props.nextItemPeek > maxPeek ? maxPeek : this.props.nextItemPeek;\n            return peek;\n        };\n        /**\n         * Callback for on scroll change\n         */\n        this.onScrollChange = () => {\n            if (typeof this.props.onScrollChange === \"function\") {\n                this.props.onScrollChange(this.getPositionData());\n            }\n            // If the onOverflowChange callback exists, we want to update overflow\n            // based on scroll change\n            if (typeof this.props.onOverflowChange === \"function\") {\n                const positionData = this.getPositionData();\n                if (this.overflowStart === !positionData.start ||\n                    this.overflowEnd === !positionData.end) {\n                    this.handleOverflowChange();\n                }\n            }\n        };\n        /**\n         * Get the scroll change data\n         */\n        this.getPositionData = () => {\n            if (isNil(this.horizontalOverflowItemsRef.current)) {\n                return { start: true, end: true };\n            }\n            const scrollPosition = this.getScrollPosition();\n            const isAtBeginning = scrollPosition === 0;\n            const isAtEnd = this.horizontalOverflowItemsRef.current.scrollWidth - scrollPosition ===\n                this.horizontalOverflowItemsRef.current.clientWidth;\n            return { start: isAtBeginning, end: isAtEnd };\n        };\n        /**\n         * onLoad handler to make sure any children affecting height are accounted for\n         */\n        this.itemsOnLoad = () => {\n            const itemsHeight = this.getItemMaxHeight();\n            if (itemsHeight !== this.state.itemsHeight) {\n                this.setState({\n                    itemsHeight,\n                });\n            }\n            if (this.overflow !== this.isOverflow()) {\n                this.handleOverflowChange();\n            }\n        };\n        /**\n         * Handles the resize event\n         */\n        this.onWindowResize = () => {\n            if (this.overflow !== this.isOverflow()) {\n                this.handleOverflowChange();\n            }\n        };\n        /**\n         * Callback for the horizontal overflow change\n         */\n        this.handleOverflowChange = () => {\n            this.overflow = this.isOverflow();\n            if (this.overflow) {\n                const positionData = this.getPositionData();\n                this.overflowStart = !positionData.start;\n                this.overflowEnd = !positionData.end;\n            }\n            else {\n                this.overflowStart = false;\n                this.overflowEnd = false;\n            }\n            if (typeof this.props.onOverflowChange === \"function\") {\n                this.props.onOverflowChange({\n                    overflowStart: this.overflowStart,\n                    overflowEnd: this.overflowEnd,\n                });\n            }\n        };\n        /**\n         * Handler for the previous click event\n         */\n        this.handlePreviousClick = () => {\n            this.handleClick(ButtonDirection.previous);\n        };\n        /**\n         * Handler for the next click event\n         */\n        this.handleNextClick = () => {\n            this.handleClick(ButtonDirection.next);\n        };\n        /**\n         * Request's an animation frame if there are currently no open animation frame requests\n         */\n        this.requestFrame = () => {\n            if (this.openRequestAnimationFrame === null) {\n                this.openRequestAnimationFrame = window.requestAnimationFrame(this.updateScrollAnimation);\n            }\n        };\n        /**\n         *  Animate one frame of scrolling\n         */\n        this.updateScrollAnimation = () => {\n            this.openRequestAnimationFrame = null;\n            const duration = this.props.scrollDuration\n                ? this.props.scrollDuration\n                : HorizontalOverflow.defaultScrollAnimationDuration;\n            const currentDate = new Date().getTime();\n            const currentTime = currentDate - this.currentScrollAnimStartTime;\n            this.setScrollPosition(this.getScrollAnimationPosition(currentTime, duration));\n            if (currentTime < duration) {\n                this.requestFrame();\n            }\n            else {\n                this.isScrollAnimating = false;\n            }\n        };\n        /**\n         *  get scroll animation position for the provided time\n         */\n        this.getScrollAnimationPosition = (currentTime, duration) => {\n            if (currentTime < duration) {\n                return this.easeInOutQuad(currentTime, this.currentScrollAnimStartPosition, this.currentScrollAnimEndPosition - this.currentScrollAnimStartPosition, duration);\n            }\n            else {\n                return this.currentScrollAnimEndPosition;\n            }\n        };\n        /**\n         *  Gets the scroll position and accounts for direction\n         */\n        this.getScrollPosition = () => {\n            if (isNil(this.horizontalOverflowItemsRef.current)) {\n                return 0;\n            }\n            const scrollLeft = RtlScrollConverter.getScrollLeft(this.horizontalOverflowItemsRef.current, this.state.direction);\n            return this.state.direction === Direction.rtl ? -scrollLeft : scrollLeft;\n        };\n        /**\n         *  Sets the scroll position and accounts for direction\n         */\n        this.setScrollPosition = (scrollValue) => {\n            if (!isNil(this.horizontalOverflowItemsRef.current)) {\n                RtlScrollConverter.setScrollLeft(this.horizontalOverflowItemsRef.current, this.state.direction === Direction.rtl ? -scrollValue : scrollValue, this.state.direction);\n            }\n        };\n        /**\n         *  updates the direction in state if necessary\n         */\n        this.updateDirection = () => {\n            const newDirection = this.getDirection();\n            if (newDirection !== this.state.direction) {\n                this.setState({\n                    direction: newDirection,\n                });\n            }\n        };\n        /**\n         *  gets the current direction\n         */\n        this.getDirection = () => {\n            if (this.horizontalOverflowItemsRef.current === null) {\n                return Direction.ltr;\n            }\n            const closest = this.horizontalOverflowItemsRef.current.closest(`[${HorizontalOverflow.DirectionAttributeName}]`);\n            return closest === null ||\n                closest.getAttribute(HorizontalOverflow.DirectionAttributeName) ===\n                    Direction.ltr\n                ? Direction.ltr\n                : Direction.rtl;\n        };\n        this.horizontalOverflowItemsRef = React.createRef();\n        this.throttledScroll = throttle(this.onScrollChange);\n        this.throttledResize = throttle(this.onWindowResize);\n        this.overflow = false;\n        this.state = {\n            direction: Direction.ltr,\n            itemsHeight: null,\n        };\n    }\n    /**\n     * Renders the Horizontal Overflow markup\n     */\n    render() {\n        const { horizontalOverflow_contentRegion, horizontalOverflow_previous, horizontalOverflow_next, } = this.props.managedClasses;\n        return (React.createElement(\"div\", Object.assign({}, this.unhandledProps(), { className: this.generateClassNames(), onLoad: this.itemsOnLoad }),\n            React.createElement(\"div\", { style: {\n                    height: this.state.itemsHeight !== null\n                        ? `${this.state.itemsHeight}px`\n                        : \"auto\",\n                    position: \"relative\",\n                    overflow: \"hidden\",\n                } },\n                React.createElement(\"ul\", { className: classNames(horizontalOverflow_contentRegion), style: this.getListStyle(), ref: this.horizontalOverflowItemsRef, onScrollCapture: this.onScrollCapture }, this.getItems())),\n            React.createElement(\"div\", { className: classNames(horizontalOverflow_previous), onClick: this.handlePreviousClick }, this.withSlot(ButtonDirection.previous)),\n            React.createElement(\"div\", { className: classNames(horizontalOverflow_next), onClick: this.handleNextClick }, this.withSlot(ButtonDirection.next))));\n    }\n    /**\n     * React life-cycle method\n     */\n    componentDidMount() {\n        if (!this.props.children) {\n            return;\n        }\n        const itemsHeight = this.getItemMaxHeight();\n        this.setState({\n            itemsHeight,\n        });\n        if (canUseDOM() && this.horizontalOverflowItemsRef.current) {\n            this.updateDirection();\n            this.lastRecordedScroll = this.getScrollPosition();\n            this.horizontalOverflowItemsRef.current.addEventListener(\"scroll\", this.throttledScroll);\n            window.addEventListener(\"resize\", this.throttledResize);\n            // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142\n            // Full browser support imminent\n            // Revisit usage once Safari and Firefox adapt\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409\n            // https://bugs.webkit.org/show_bug.cgi?id=157743\n            if (window.ResizeObserver) {\n                this.resizeObserver = new window.ResizeObserver((entries) => {\n                    if (this.overflow !== this.isOverflow()) {\n                        this.handleOverflowChange();\n                    }\n                });\n                this.resizeObserver.observe(this.horizontalOverflowItemsRef.current);\n            }\n        }\n    }\n    /**\n     * React life-cycle method\n     */\n    componentWillUnmount() {\n        if (canUseDOM() && this.horizontalOverflowItemsRef.current) {\n            this.horizontalOverflowItemsRef.current.removeEventListener(\"scroll\", this.throttledScroll);\n            window.removeEventListener(\"resize\", this.throttledResize);\n            // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142\n            // Full browser support imminent\n            // Revisit usage once Safari and Firefox adapt\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409\n            // https://bugs.webkit.org/show_bug.cgi?id=157743\n            if (this.resizeObserver &&\n                typeof this.resizeObserver.disconnect === \"function\") {\n                this.resizeObserver.disconnect();\n                this.resizeObserver = null;\n            }\n            // Cancel any pending calls\n            this.throttledResize.cancel();\n            this.throttledScroll.cancel();\n        }\n    }\n    /**\n     * React life-cycle method\n     */\n    getSnapshotBeforeUpdate(prevProps) {\n        if (React.Children.toArray(prevProps.children).length <\n            React.Children.toArray(this.props.children).length) {\n            return true;\n        }\n        return null;\n    }\n    /**\n     * React life-cycle method\n     */\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        if (snapshot !== null) {\n            this.handleOverflowChange();\n        }\n        this.updateDirection();\n    }\n    /**\n     * Generates class names\n     */\n    generateClassNames() {\n        return super.generateClassNames(classNames(this.props.managedClasses.horizontalOverflow));\n    }\n    /**\n     * Gets the style for the `ul` element containing the items\n     */\n    getListStyle() {\n        return {\n            position: \"relative\",\n            whiteSpace: \"nowrap\",\n            overflowX: \"scroll\",\n            padding: 0,\n            margin: 0,\n        };\n    }\n    /**\n     * Checks if overflow is occuring\n     */\n    isOverflow() {\n        const availableWidth = this.getAvailableWidth();\n        const itemWidths = this.getItemWidths();\n        const totalItemWidth = itemWidths.reduce((a, b) => a + b);\n        return totalItemWidth > availableWidth;\n    }\n    /**\n     * Identifies and returns the tallest child height\n     */\n    getItemMaxHeight() {\n        let itemMaxHeight = 0;\n        const children = get(this.horizontalOverflowItemsRef, \"current.childNodes\");\n        if (!canUseDOM() || !children) {\n            return itemMaxHeight;\n        }\n        const childNodes = Array.prototype.slice.call(children);\n        for (const childNode of childNodes) {\n            const childNodeHeight = getClientRectWithMargin(childNode).height;\n            if (childNodeHeight > itemMaxHeight) {\n                itemMaxHeight = childNodeHeight;\n            }\n        }\n        return itemMaxHeight;\n    }\n    /**\n     * Gets the children displayed as items to be scrolled\n     */\n    getItems() {\n        return React.Children.map(this.withoutSlot([ButtonDirection.previous, ButtonDirection.next]), (child, index) => {\n            return (React.createElement(\"li\", { onFocusCapture: this.onItemFocus, className: classNames(this.props.managedClasses.horizontalOverflow_item), style: { display: \"inline-block\" } }, child));\n        });\n    }\n    /**\n     * Gets the distance to scroll based on the direction\n     */\n    getScrollDistanceFromButtonDirection(buttonDirection, itemWidths, scrollPosition) {\n        if (itemWidths.length === 0 || !canUseDOM()) {\n            return 0;\n        }\n        let distance = 0;\n        if (buttonDirection === ButtonDirection.next) {\n            distance = this.getWithinMaxDistance(scrollPosition, itemWidths);\n        }\n        else {\n            distance = this.getWithinMinDistance(scrollPosition, itemWidths);\n        }\n        return Math.ceil(distance);\n    }\n    /**\n     * Gets the distance unless it is over the maximum distance, then use maximum distance instead\n     */\n    getWithinMaxDistance(scrollPosition, itemWidths) {\n        const maxDistance = this.getMaxScrollDistance();\n        if (scrollPosition === maxDistance) {\n            return maxDistance;\n        }\n        const distance = this.getNextDistance(itemWidths, scrollPosition);\n        return distance >= maxDistance ? maxDistance : distance;\n    }\n    /**\n     * Gets the distance unless it is under the minimum distance, then use minimum distance instead\n     */\n    getWithinMinDistance(scrollPosition, itemWidths) {\n        if (scrollPosition === 0) {\n            return 0;\n        }\n        const distance = this.getPreviousDistance(itemWidths, scrollPosition);\n        return distance <= 0 ? 0 : distance;\n    }\n    /**\n     * Gets the distance to scroll if the next button has been clicked\n     */\n    getNextDistance(itemWidths, scrollPosition) {\n        let distance = 0;\n        for (let i = 0, itemWidthsLength = itemWidths.length; i < itemWidthsLength; i++) {\n            if (distance + itemWidths[i] > scrollPosition + this.getAvailableWidth() &&\n                distance !== scrollPosition) {\n                return distance + this.getScrollPeek(itemWidths[i]);\n            }\n            distance += itemWidths[i];\n        }\n        return distance;\n    }\n    /**\n     * Gets the distance to scroll if the previous button has been clicked\n     */\n    getPreviousDistance(itemWidths, scrollPosition) {\n        const availableWidth = this.getAvailableWidth();\n        let distance = this.getMaxScrollDistance() + availableWidth;\n        for (let i = itemWidths.length - 1; i >= 0; i--) {\n            if (distance - itemWidths[i] < scrollPosition - availableWidth &&\n                distance !== scrollPosition) {\n                return distance - this.getScrollPeek(itemWidths[i]);\n            }\n            distance -= itemWidths[i];\n        }\n        return distance;\n    }\n    /**\n     * Gets the maximum distance that can be scrolled\n     */\n    getMaxScrollDistance() {\n        if (isNil(this.horizontalOverflowItemsRef.current)) {\n            return 0;\n        }\n        return (this.horizontalOverflowItemsRef.current.scrollWidth - this.getAvailableWidth());\n    }\n    /**\n     * Handler for the click event fired after next or previous has been clicked\n     */\n    handleClick(buttonDirection) {\n        this.scrollContent(this.getScrollPosition(), this.getScrollDistanceFromButtonDirection(buttonDirection, this.getItemWidths(), this.getScrollPosition()));\n    }\n    /**\n     * Returns the available content region width\n     */\n    getAvailableWidth() {\n        if (isNil(this.horizontalOverflowItemsRef.current)) {\n            return 0;\n        }\n        return this.horizontalOverflowItemsRef.current.clientWidth;\n    }\n    /**\n     * Returns the items widths\n     */\n    getItemWidths() {\n        if (isNil(this.horizontalOverflowItemsRef.current)) {\n            return null;\n        }\n        const items = Array.prototype.slice.call(this.horizontalOverflowItemsRef.current.childNodes);\n        const itemWidths = [];\n        for (const item of items) {\n            itemWidths.push(getClientRectWithMargin(item).width);\n        }\n        return itemWidths;\n    }\n    /**\n     * Easing animation\n     * Inspired by the github gist contribution: https://gist.github.com/andjosh/6764939\n     */\n    easeInOutQuad(currentTime, startValue, changeInValue, duration) {\n        currentTime /= duration / 2;\n        if (currentTime < 1) {\n            return (changeInValue / 2) * currentTime * currentTime + startValue;\n        }\n        currentTime--;\n        return (-changeInValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;\n    }\n    /**\n     * Scrolls the container for the items list\n     */\n    scrollContent(startScrollPosition, targetScrollPosition) {\n        const newScrollPosition = Math.max(0, Math.min(targetScrollPosition, this.getMaxScrollDistance()));\n        this.isScrollAnimating = true;\n        this.currentScrollAnimStartPosition = startScrollPosition;\n        this.currentScrollAnimEndPosition = newScrollPosition;\n        this.currentScrollAnimStartTime = new Date().getTime();\n        this.requestFrame();\n    }\n}\nHorizontalOverflow.displayName = `${DisplayNamePrefix}HorizontalOverflow`;\nHorizontalOverflow.defaultProps = {\n    managedClasses: {},\n    nextItemPeek: 50,\n};\nHorizontalOverflow.DirectionAttributeName = \"dir\";\nHorizontalOverflow.defaultScrollAnimationDuration = 500;\nexport default HorizontalOverflow;\n"]},"metadata":{},"sourceType":"module"}