{"ast":null,"code":"import { SliderMode, SliderOrientation } from \"./slider.props\";\nimport React from \"react\";\nimport { get, isNil } from \"lodash-es\";\nimport Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnd, keyCodeHome, keyCodePageDown, keyCodePageUp } from \"@microsoft/fast-web-utilities\";\nimport { classNames, Direction } from \"@microsoft/fast-web-utilities\";\nimport { DisplayNamePrefix } from \"../utilities\";\nimport { SliderContext } from \"./slider-context\";\nimport SliderTrackItem, { SliderTrackItemAnchor } from \"../slider-track-item\";\nexport var SliderThumb;\n\n(function (SliderThumb) {\n  SliderThumb[\"upperThumb\"] = \"upperThumb\";\n  SliderThumb[\"lowerThumb\"] = \"lowerThumb\";\n})(SliderThumb || (SliderThumb = {}));\n\nclass Slider extends Foundation {\n  /**\n   * constructor\n   */\n  constructor(props) {\n    super(props);\n    this.handledProps = {\n      disabled: void 0,\n      managedClasses: void 0,\n      orientation: void 0,\n      mode: void 0,\n      initialValue: void 0,\n      range: void 0,\n      pageStep: void 0,\n      step: void 0,\n      value: void 0,\n      constrainedRange: void 0,\n      onValueChange: void 0,\n      name: void 0,\n      form: void 0,\n      thumb: void 0,\n      minThumbLabel: void 0,\n      maxThumbLabel: void 0,\n      valuetextStringFormatter: void 0,\n      displayValueConverter: void 0\n    };\n    this.rootElement = React.createRef();\n    this.sliderTrackElement = React.createRef();\n    this.rangeInPixels = 1;\n    this.barMinPixel = 0;\n    this.lastIncrementDelay = Slider.baseIncrementDelay;\n    /**\n     * Renders the internals of the component but skips the\n     * first render so we can determine direction before doing layout\n     * (avoids transition animations to get the layout right to begin with)\n     */\n\n    this.renderSliderInternals = () => {\n      if (this.state.direction === null) {\n        return null;\n      }\n\n      return React.createElement(SliderContext.Provider, {\n        value: {\n          sliderOrientation: this.props.orientation,\n          sliderMode: this.props.mode,\n          sliderState: this.state,\n          sliderConstrainedRange: this.props.constrainedRange,\n          sliderValueAsPercent: this.valueAsPercent,\n          sliderDirection: this.state.direction\n        }\n      }, React.createElement(\"div\", {\n        className: classNames(this.props.managedClasses.slider_layoutRegion),\n        style: {\n          position: \"relative\"\n        }\n      }, React.createElement(\"div\", {\n        className: classNames(this.props.managedClasses.slider_backgroundTrack),\n        style: {\n          position: \"absolute\"\n        }\n      }), React.createElement(SliderTrackItem, {\n        className: this.props.managedClasses.slider_foregroundTrack,\n        maxValuePositionBinding: SliderTrackItemAnchor.selectedRangeMax,\n        minValuePositionBinding: SliderTrackItemAnchor.selectedRangeMin\n      }), React.createElement(\"div\", {\n        ref: this.sliderTrackElement,\n        onMouseDown: this.handleTrackMouseDown,\n        className: classNames(this.props.managedClasses.slider_track),\n        style: {\n          position: \"absolute\"\n        }\n      }), this.props.children, this.renderThumb(SliderThumb.upperThumb), this.renderThumb(SliderThumb.lowerThumb)), this.renderHiddenInputElement());\n    };\n    /**\n     * Updates values when mode is switched in props\n     */\n\n\n    this.updateValuesForModeSwitch = () => {\n      switch (this.props.mode) {\n        case SliderMode.adjustBoth:\n          break;\n\n        case SliderMode.adustLowerValue:\n          this.updateValues(this.state.lowerValue, this.props.range.maxValue);\n          break;\n\n        case SliderMode.adustUpperValue:\n          this.updateValues(this.props.range.minValue, this.state.upperValue);\n          break;\n\n        case SliderMode.singleValue:\n          this.updateValues(this.state.upperValue, this.state.upperValue);\n          break;\n      }\n    };\n    /**\n     *  Constrains a value to be within the provided constraint range and step\n     */\n\n\n    this.getConstrainedValue = (baseValue, constraint, step) => {\n      if (constraint === null || constraint === undefined) {\n        constraint = this.props.range;\n      }\n\n      const constrainedRange = {\n        minValue: this.constrainToRange(this.constrainToStep(this.valueAsRange(baseValue).minValue, step), constraint),\n        maxValue: this.constrainToRange(this.constrainToStep(this.valueAsRange(baseValue).maxValue, step), constraint)\n      };\n      return constrainedRange;\n    };\n    /**\n     *  Maps the default thumb managed classes to the appropriate slider managed classes\n     */\n\n\n    this.getThumbManagedClasses = thumb => {\n      const thumbBaseClass = get(this.props, \"managedClasses.slider_thumb\", \"\");\n      return {\n        managedClasses: {\n          sliderTrackItem: thumb === SliderThumb.upperThumb ? get(this.props, \"managedClasses.slider_thumb__upperValue\", \"\").concat(\" \", thumbBaseClass) : get(this.props, \"managedClasses.slider_thumb__lowerValue\", \"\").concat(\" \", thumbBaseClass),\n          sliderTrackItem_horizontal: get(this.props, \"managedClasses.slider_thumb__horizontal\", \"\"),\n          sliderTrackItem_vertical: get(this.props, \"managedClasses.slider_thumb__vertical\", \"\")\n        }\n      };\n    };\n    /**\n     * This exists only to suppress a build warning\n     */\n\n\n    this.onInputValueChange = event => {\n      return null;\n    };\n    /**\n     *  Determines whether a particular thumb should render in the current mode\n     */\n\n\n    this.shouldRenderThumb = thumb => {\n      if (this.props.mode === SliderMode.adustLowerValue && thumb === SliderThumb.upperThumb || this.props.mode === SliderMode.adustUpperValue && thumb === SliderThumb.lowerThumb || this.props.mode === SliderMode.singleValue && thumb === SliderThumb.lowerThumb) {\n        return false;\n      }\n\n      return true;\n    };\n    /**\n     * Handles track clicks\n     */\n\n\n    this.handleTrackMouseDown = event => {\n      if (event.defaultPrevented || this.isBusyOrDisabled()) {\n        return;\n      }\n\n      event.preventDefault();\n      this.updateSliderDimensions();\n      const pixelCoordinate = this.props.orientation === SliderOrientation.vertical ? event.pageY : event.pageX;\n      const newValue = (this.props.range.maxValue - this.props.range.minValue) * this.convertPixelToPercent(pixelCoordinate) + this.props.range.minValue;\n\n      switch (this.props.mode) {\n        case SliderMode.singleValue:\n          this.updateValues(newValue, newValue);\n          break;\n\n        case SliderMode.adjustBoth:\n          this.handleMultiThumbTrackClick(newValue);\n          break;\n\n        case SliderMode.adustLowerValue:\n          this.updateValues(newValue, null);\n          break;\n\n        case SliderMode.adustUpperValue:\n          this.updateValues(null, newValue);\n          break;\n      }\n    };\n    /**\n     *  Handles track clicks when there are multiple thumbs\n     */\n\n\n    this.handleMultiThumbTrackClick = value => {\n      if (value <= this.state.lowerValue) {\n        this.updateValues(value, null);\n      } else if (value >= this.state.upperValue) {\n        this.updateValues(null, value);\n      } else {\n        // between values move the closest thumb to the click\n        if (value - this.state.lowerValue < this.state.upperValue - value) {\n          this.updateValues(value, null);\n        } else {\n          this.updateValues(null, value);\n        }\n      }\n    };\n    /**\n     *  updates the direction in state if necessary\n     */\n\n\n    this.updateDirection = () => {\n      const newDirection = this.getDirection();\n\n      if (newDirection !== this.state.direction) {\n        this.suspendActiveOperations();\n        this.setState({\n          direction: newDirection\n        });\n      }\n    };\n    /**\n     *  gets the current direction\n     */\n\n\n    this.getDirection = () => {\n      if (this.rootElement.current === null) {\n        return Direction.ltr;\n      }\n\n      const closest = this.rootElement.current.closest(`[${Slider.DirectionAttributeName}]`);\n      return closest === null || closest.getAttribute(Slider.DirectionAttributeName) === Direction.ltr ? Direction.ltr : Direction.rtl;\n    };\n    /**\n     * Measures the slider dimensions and stores them\n     */\n\n\n    this.updateSliderDimensions = () => {\n      if (this.sliderTrackElement.current === null) {\n        return;\n      }\n\n      this.rangeInPixels = this.props.orientation === SliderOrientation.vertical ? this.sliderTrackElement.current.clientHeight : this.sliderTrackElement.current.clientWidth;\n\n      if (this.rangeInPixels === 0) {\n        this.rangeInPixels = 1;\n      }\n\n      this.barMinPixel = this.props.orientation === SliderOrientation.vertical ? this.sliderTrackElement.current.getBoundingClientRect().bottom : this.sliderTrackElement.current.getBoundingClientRect().left;\n    };\n    /**\n     * Start timed incrementing from\n     */\n\n\n    this.startIncrementing = (incrementDirection, usePageStep, thumb, event) => {\n      event.preventDefault();\n\n      if (this.state.isIncrementing) {\n        return;\n      }\n\n      this.updateSliderDimensions();\n      window.addEventListener(\"keyup\", this.handleWindowKeyUp);\n      this.setState({\n        usePageStep,\n        activeThumb: thumb,\n        isIncrementing: true,\n        incrementDirection\n      });\n      this.lastIncrementDelay = Slider.baseIncrementDelay;\n      this.incrementTimer = setTimeout(() => {\n        this.incrementTimerExpired();\n      }, 50);\n    };\n    /**\n     * Increments the value by one step (or pageStep)\n     * when step is set to 0 we increment based on the current pixel width\n     * of the component\n     */\n\n\n    this.incrementValue = () => {\n      const step = this.state.usePageStep ? this.props.pageStep : this.props.step !== 0 ? this.props.step : (this.props.range.maxValue - this.props.range.minValue) / this.rangeInPixels;\n      let newValue = this.state.activeThumb === SliderThumb.upperThumb ? this.state.upperValue + step * this.state.incrementDirection : this.state.lowerValue + step * this.state.incrementDirection;\n\n      if (this.props.mode === SliderMode.adjustBoth && newValue > this.state.upperValue && this.state.activeThumb !== SliderThumb.upperThumb) {\n        newValue = this.state.upperValue;\n      } else if (this.props.mode === SliderMode.adjustBoth && newValue < this.state.lowerValue && this.state.activeThumb !== SliderThumb.lowerThumb) {\n        newValue = this.state.lowerValue;\n      }\n\n      if (this.state.activeThumb === SliderThumb.upperThumb) {\n        this.updateValues(null, newValue);\n      } else {\n        this.updateValues(newValue, null);\n      }\n    };\n    /**\n     *  Increment timer tick\n     */\n\n\n    this.incrementTimerExpired = () => {\n      clearTimeout(this.incrementTimer);\n      this.incrementValue();\n      this.lastIncrementDelay = this.lastIncrementDelay - Slider.incrementAcceleration;\n\n      if (this.lastIncrementDelay < Slider.minIncrementDelay) {\n        this.lastIncrementDelay = Slider.minIncrementDelay;\n      }\n\n      this.incrementTimer = setTimeout(() => {\n        this.incrementTimerExpired();\n      }, this.lastIncrementDelay);\n    };\n    /**\n     *  Stop incrementing\n     */\n\n\n    this.stopIncrementing = () => {\n      if (!this.state.isIncrementing) {\n        return;\n      }\n\n      window.removeEventListener(\"keyup\", this.handleWindowKeyUp);\n      this.setState({\n        usePageStep: false,\n        isIncrementing: false\n      });\n      clearTimeout(this.incrementTimer);\n    };\n    /**\n     * Converts a pixel coordinate on the track to a percent of the track's range\n     */\n\n\n    this.convertPixelToPercent = pixelPos => {\n      let pct = 0;\n\n      if (this.props.orientation === SliderOrientation.vertical) {\n        pct = (this.barMinPixel - pixelPos) / this.rangeInPixels;\n      } else {\n        pct = (pixelPos - this.barMinPixel) / this.rangeInPixels;\n      }\n\n      if (pct < 0) {\n        pct = 0;\n      } else if (pct > 1) {\n        pct = 1;\n      }\n\n      if (this.state.direction === Direction.rtl && this.props.orientation !== SliderOrientation.vertical) {\n        pct = 1 - pct;\n      }\n\n      return pct;\n    };\n    /**\n     * Handles thumb key events\n     */\n\n\n    this.handleUpperThumbKeyDown = event => {\n      this.handleThumbKeydown(event, SliderThumb.upperThumb);\n    };\n\n    this.handleLowerThumbKeyDown = event => {\n      this.handleThumbKeydown(event, SliderThumb.lowerThumb);\n    };\n\n    this.handleThumbKeydown = (event, thumb) => {\n      if (event.defaultPrevented || this.isBusyOrDisabled()) {\n        event.preventDefault();\n        return;\n      }\n\n      switch (event.keyCode) {\n        case keyCodeArrowDown:\n          this.startIncrementing(-1, false, thumb, event);\n          break;\n\n        case keyCodeArrowRight:\n          this.startIncrementing(this.state.direction === Direction.ltr ? 1 : -1, false, thumb, event);\n          break;\n\n        case keyCodeArrowUp:\n          this.startIncrementing(1, false, thumb, event);\n          break;\n\n        case keyCodeArrowLeft:\n          this.startIncrementing(this.state.direction === Direction.ltr ? -1 : 1, false, thumb, event);\n          break;\n\n        case keyCodePageDown:\n          if (this.props.pageStep !== undefined) {\n            this.startIncrementing(-1, true, thumb, event);\n          }\n\n          break;\n\n        case keyCodePageUp:\n          if (this.props.pageStep !== undefined) {\n            this.startIncrementing(1, true, thumb, event);\n          }\n\n          break;\n\n        case keyCodeHome:\n          this.setMinValue(thumb);\n          break;\n\n        case keyCodeEnd:\n          this.setMaxValue(thumb);\n          break;\n      }\n    };\n    /**\n     * sets the active thumb to its minimum value\n     */\n\n\n    this.setMinValue = thumb => {\n      const thumbRange = this.getConstrainedRange(true);\n\n      if (thumb === SliderThumb.upperThumb) {\n        this.updateValues(null, thumbRange.minValue);\n      } else {\n        this.updateValues(thumbRange.minValue, null);\n      }\n    };\n    /**\n     * sets the active thumb to it's maximum value\n     */\n\n\n    this.setMaxValue = thumb => {\n      const thumbRange = this.getConstrainedRange(true);\n\n      if (thumb === SliderThumb.upperThumb) {\n        this.updateValues(null, thumbRange.maxValue);\n      } else {\n        this.updateValues(thumbRange.maxValue, null);\n      }\n    };\n    /**\n     * Handles thumb clicks\n     */\n\n\n    this.handleUpperThumbMouseDown = e => {\n      this.handleThumbMouseDown(e, SliderThumb.upperThumb);\n    };\n\n    this.handleLowerThumbMouseDown = e => {\n      this.handleThumbMouseDown(e, SliderThumb.lowerThumb);\n    };\n\n    this.handleThumbMouseDown = (e, thumb) => {\n      if (e.defaultPrevented || this.isBusyOrDisabled()) {\n        return;\n      }\n\n      e.preventDefault();\n      e.target.focus();\n      window.addEventListener(\"mouseup\", this.handleWindowMouseUp);\n      window.addEventListener(\"mousemove\", this.handleMouseMove);\n      this.setState({\n        isMouseDragging: true,\n        activeThumb: thumb\n      });\n      this.updateDragValue(this.getDragValue(e.nativeEvent, thumb), thumb);\n    };\n    /**\n     *  Handle mouse moves during a thumb drag operation\n     */\n\n\n    this.handleMouseMove = event => {\n      if (this.props.disabled || event.defaultPrevented) {\n        return;\n      }\n\n      this.updateDragValue(this.getDragValue(event, this.state.activeThumb), this.state.activeThumb);\n    };\n    /**\n     *  Get dragvalue from mouse event or touch\n     */\n\n\n    this.getDragValue = (event, thumb) => {\n      this.updateSliderDimensions();\n      const pixelCoordinate = this.props.orientation === SliderOrientation.vertical ? event.clientY : event.clientX;\n      const dragValue = (this.props.range.maxValue - this.props.range.minValue) * this.convertPixelToPercent(pixelCoordinate) + this.props.range.minValue;\n      return dragValue;\n    };\n    /**\n     * Handles touch dragging\n     */\n\n\n    this.handleUpperThumbTouchStart = e => {\n      this.handleThumbTouchStart(e, SliderThumb.upperThumb);\n    };\n\n    this.handleLowerThumbTouchStart = e => {\n      this.handleThumbTouchStart(e, SliderThumb.lowerThumb);\n    };\n\n    this.handleThumbTouchStart = (e, thumb) => {\n      if (e.defaultPrevented || this.isBusyOrDisabled()) {\n        return;\n      }\n\n      e.preventDefault();\n      e.target.focus();\n      window.addEventListener(\"touchend\", this.handleTouchEnd);\n      window.addEventListener(\"touchcancel\", this.handleTouchEnd);\n      window.addEventListener(\"touchmove\", this.handleTouchMove);\n      this.setState({\n        isTouchDragging: true,\n        activeThumb: thumb\n      });\n      const thisTouch = e.nativeEvent.touches.item(0);\n      this.updateDragValue(this.getDragValue(thisTouch, thumb), thumb);\n    };\n    /**\n     *  Returns first valid touch found in a touch event\n     */\n\n\n    this.getValidTouch = event => {\n      if (isNil(this.rootElement.current)) {\n        return null;\n      }\n\n      const touchCount = event.touches.length;\n\n      for (let i = 0; i < touchCount; i++) {\n        const thisTouch = event.touches.item(i);\n        const touchElement = thisTouch.target;\n\n        if (touchElement.attributes[Slider.rolePropName].value === \"slider\" && touchElement.tabIndex === 0 && this.rootElement.current.contains(touchElement)) {\n          return thisTouch;\n        }\n      }\n\n      return null;\n    };\n    /**\n     *  Handle touch moves during a thumb drag operation\n     */\n\n\n    this.handleTouchMove = event => {\n      if (this.props.disabled || event.defaultPrevented) {\n        return;\n      }\n\n      const validTouch = this.getValidTouch(event);\n\n      if (validTouch === null) {\n        this.stopTouchDragging();\n        return;\n      }\n\n      this.updateDragValue(this.getDragValue(validTouch, this.state.activeThumb), this.state.activeThumb);\n    };\n    /**\n     * Handle touch end\n     */\n\n\n    this.handleTouchEnd = event => {\n      event.preventDefault();\n      this.stopTouchDragging();\n    };\n    /**\n     *  Updates the current drag value\n     */\n\n\n    this.updateDragValue = (dragValue, thumb) => {\n      const constrainedRange = this.getConstrainedRange(true);\n      const newDragValue = this.constrainToRange(dragValue, constrainedRange);\n      this.setState({\n        dragValue: newDragValue\n      });\n\n      if (thumb === SliderThumb.lowerThumb) {\n        this.updateValues(newDragValue, null);\n      } else {\n        this.updateValues(null, newDragValue);\n      }\n    };\n    /**\n     *  Gets the range of values the active thumb is actually allowed to traverse\n     */\n\n\n    this.getConstrainedRange = constrainToOppositeEndOfSelection => {\n      let rangeMin = this.props.range.minValue;\n      let rangeMax = this.props.range.maxValue;\n\n      if (this.props.constrainedRange !== undefined) {\n        rangeMin = this.props.constrainedRange.minValue > rangeMin ? this.props.constrainedRange.minValue : rangeMin;\n        rangeMax = this.props.constrainedRange.maxValue < rangeMax ? this.props.constrainedRange.maxValue : rangeMin;\n      }\n\n      if (this.props.mode !== SliderMode.singleValue && constrainToOppositeEndOfSelection) {\n        if (this.state.activeThumb === SliderThumb.lowerThumb) {\n          rangeMax = this.state.upperValue;\n        } else {\n          rangeMin = this.state.lowerValue;\n        }\n      }\n\n      return {\n        minValue: rangeMin,\n        maxValue: rangeMax\n      };\n    };\n    /**\n     *  Converts a single number value to a SliderRange based on current mode\n     */\n\n\n    this.valueAsRange = value => {\n      if (typeof value === \"number\") {\n        switch (this.props.mode) {\n          case SliderMode.adjustBoth:\n          case SliderMode.singleValue:\n            return {\n              minValue: value,\n              maxValue: value\n            };\n\n          case SliderMode.adustLowerValue:\n            return {\n              minValue: value,\n              maxValue: this.props.range.maxValue\n            };\n\n          case SliderMode.adustUpperValue:\n            return {\n              minValue: this.props.range.minValue,\n              maxValue: value\n            };\n        }\n      } else if (typeof value === \"object\") {\n        return value;\n      }\n    };\n    /**\n     *  Apply value changes to state, only place this should happen outside of constructor and ComponentDidUpdate\n     */\n\n\n    this.updateValues = (lowerValue, upperValue) => {\n      let newLowerValue = this.state.lowerValue;\n      let newUpperValue = this.state.upperValue;\n\n      if (lowerValue !== null) {\n        newLowerValue = this.constrainToRange(this.constrainToStep(lowerValue, this.props.step), this.props.range);\n      }\n\n      if (upperValue !== null) {\n        newUpperValue = this.constrainToRange(this.constrainToStep(upperValue, this.props.step), this.props.range);\n      }\n\n      if (this.state.upperValue === newUpperValue && this.state.lowerValue === newLowerValue) {\n        return;\n      }\n\n      this.invokeValueChange(newLowerValue, newUpperValue);\n\n      if (this.props.value === undefined) {\n        this.setState({\n          lowerValue: this.props.mode === SliderMode.singleValue ? newUpperValue : newLowerValue,\n          upperValue: newUpperValue\n        });\n      }\n    };\n    /**\n     *  Invokes the value change event and formats params based on current mode\n     */\n\n\n    this.invokeValueChange = (lowerValue, upperValue) => {\n      if (typeof this.props.onValueChange === \"function\") {\n        switch (this.props.mode) {\n          case SliderMode.adjustBoth:\n            this.props.onValueChange({\n              minValue: lowerValue,\n              maxValue: upperValue\n            });\n            break;\n\n          case SliderMode.adustUpperValue:\n          case SliderMode.singleValue:\n            this.props.onValueChange(upperValue);\n            break;\n\n          case SliderMode.adustLowerValue:\n            this.props.onValueChange(lowerValue);\n            break;\n        }\n      }\n    };\n    /**\n     * Handle a window mouse up during a drag operation\n     */\n\n\n    this.handleWindowMouseUp = event => {\n      this.stopDragging();\n    };\n    /**\n     *  Handle window key up during an incrementing operation\n     */\n\n\n    this.handleWindowKeyUp = event => {\n      switch (event.keyCode) {\n        case keyCodeArrowDown:\n        case keyCodeArrowRight:\n        case keyCodeArrowUp:\n        case keyCodeArrowLeft:\n        case keyCodePageDown:\n        case keyCodePageUp:\n          this.stopIncrementing();\n          break;\n      }\n    };\n    /**\n     *  Ends a thumb drag operation\n     */\n\n\n    this.stopDragging = () => {\n      if (!this.state.isMouseDragging) {\n        return;\n      }\n\n      window.removeEventListener(\"mouseup\", this.handleWindowMouseUp);\n      window.removeEventListener(\"mousemove\", this.handleMouseMove);\n      this.setState({\n        isMouseDragging: false\n      });\n    };\n    /**\n     *  Ends a thumb touch drag operation\n     */\n\n\n    this.stopTouchDragging = () => {\n      if (!this.state.isTouchDragging) {\n        return;\n      }\n\n      window.removeEventListener(\"touchend\", this.handleTouchEnd);\n      window.removeEventListener(\"touchcancel\", this.handleTouchEnd);\n      window.removeEventListener(\"touchmove\", this.handleTouchMove);\n      this.setState({\n        isTouchDragging: false\n      });\n    };\n    /**\n     *  Ends active drag/increment operations\n     */\n\n\n    this.suspendActiveOperations = () => {\n      this.stopDragging();\n      this.stopTouchDragging();\n      this.stopIncrementing();\n    };\n    /**\n     * Ensures a value falls within the provided range\n     */\n\n\n    this.constrainToRange = (value, range) => {\n      let newValue = value;\n\n      if (newValue > range.maxValue) {\n        newValue = range.maxValue;\n      } else if (newValue < range.minValue) {\n        newValue = range.minValue;\n      }\n\n      return newValue;\n    };\n    /**\n     * Ensures a value is an even multiple of the slider step increment\n     */\n\n\n    this.constrainToStep = (value, step) => {\n      // we remove then restore the slider range min value to\n      // ensure that the remainder calculates correctly in case the minValue\n      // is not based off 0, eg. range minValue 7.5, step 2.  Slider steps increment off\n      // of the min value of the slider's range, not 0.\n      let constrainedValue = value - this.props.range.minValue;\n      const remainder = constrainedValue % step;\n      constrainedValue = remainder >= step / 2 // check to see if this is over half a single step\n      ? constrainedValue - remainder + step // if so add a step\n      : constrainedValue - remainder;\n      return constrainedValue + this.props.range.minValue;\n    };\n    /**\n     * Converts value to a percent of slider range\n     */\n\n\n    this.valueAsPercent = value => {\n      return (value - this.props.range.minValue) / (this.props.range.maxValue - this.props.range.minValue) * 100;\n    };\n    /**\n     *  Converts a percent value to the equivalent value on the bar range\n     */\n\n\n    this.percentAsValue = value => {\n      return (this.props.range.maxValue - this.props.range.minValue) / 100 * value + this.props.range.minValue;\n    };\n    /**\n     *  Checks if the component is busy with an active operation or disabled\n     */\n\n\n    this.isBusyOrDisabled = () => {\n      if (this.props.disabled || this.state.isMouseDragging || this.state.isIncrementing || this.state.isTouchDragging) {\n        return true;\n      }\n\n      return false;\n    };\n\n    let initialValue = {\n      minValue: this.props.range.minValue,\n      maxValue: this.props.range.maxValue\n    };\n\n    if (this.props.value !== undefined) {\n      initialValue = this.getConstrainedValue(this.props.value, this.props.constrainedRange, this.props.step);\n    } else if (this.props.initialValue !== undefined) {\n      initialValue = this.getConstrainedValue(this.props.initialValue, this.props.constrainedRange, this.props.step);\n    } else {\n      let defaultValue = {\n        minValue: 0,\n        maxValue: 0\n      };\n\n      switch (this.props.mode) {\n        case SliderMode.singleValue:\n          defaultValue = {\n            minValue: this.percentAsValue(50),\n            maxValue: this.percentAsValue(50)\n          };\n          break;\n\n        case SliderMode.adjustBoth:\n          defaultValue = {\n            minValue: this.percentAsValue(40),\n            maxValue: this.percentAsValue(60)\n          };\n          break;\n\n        case SliderMode.adustLowerValue:\n          defaultValue = {\n            minValue: this.percentAsValue(50),\n            maxValue: this.props.range.maxValue\n          };\n          break;\n\n        case SliderMode.adustUpperValue:\n          defaultValue = {\n            minValue: this.props.range.minValue,\n            maxValue: this.percentAsValue(50)\n          };\n          break;\n      }\n\n      initialValue = this.getConstrainedValue(defaultValue, this.props.constrainedRange, this.props.step);\n    }\n\n    this.state = {\n      dragValue: -1,\n      upperValue: initialValue.maxValue,\n      lowerValue: initialValue.minValue,\n      activeThumb: null,\n      isMouseDragging: false,\n      isTouchDragging: false,\n      isIncrementing: false,\n      incrementDirection: 1,\n      usePageStep: false,\n      direction: null\n    };\n  }\n  /**\n   * React lifecycle methods\n   */\n\n\n  componentDidMount() {\n    this.updateDirection();\n  }\n\n  componentWillUnmount() {\n    this.suspendActiveOperations();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.disabled !== this.props.disabled && this.props.disabled) {\n      this.suspendActiveOperations();\n    }\n\n    if (prevProps.value !== this.props.value && this.props.value !== undefined) {\n      const newValue = this.getConstrainedValue(this.props.value, this.props.constrainedRange, this.props.step);\n      this.setState({\n        lowerValue: newValue.minValue,\n        upperValue: newValue.maxValue\n      });\n    } else if (prevProps.constrainedRange !== this.props.constrainedRange || prevProps.step !== this.props.step) {\n      this.suspendActiveOperations();\n      this.updateValues(this.state.lowerValue, this.state.upperValue);\n    }\n\n    if (prevProps.mode !== this.props.mode) {\n      this.suspendActiveOperations();\n      this.updateValuesForModeSwitch();\n    }\n\n    this.updateDirection();\n  }\n  /**\n   * Renders the component\n   */\n\n\n  render() {\n    return React.createElement(\"div\", Object.assign({}, this.unhandledProps(), {\n      ref: this.rootElement,\n      className: this.generateClassNames()\n    }), this.renderSliderInternals());\n  }\n  /**\n   * Generates class names\n   */\n\n\n  generateClassNames() {\n    const _this$props$managedCl = this.props.managedClasses,\n          slider = _this$props$managedCl.slider,\n          slider__disabled = _this$props$managedCl.slider__disabled,\n          slider__dragging = _this$props$managedCl.slider__dragging,\n          slider__touchDragging = _this$props$managedCl.slider__touchDragging,\n          slider__incrementing = _this$props$managedCl.slider__incrementing,\n          slider__vertical = _this$props$managedCl.slider__vertical,\n          slider__horizontal = _this$props$managedCl.slider__horizontal,\n          slider__rtl = _this$props$managedCl.slider__rtl,\n          slider__modeSingle = _this$props$managedCl.slider__modeSingle,\n          slider__modeAdjustUpper = _this$props$managedCl.slider__modeAdjustUpper,\n          slider__modeAdjustLower = _this$props$managedCl.slider__modeAdjustLower,\n          slider__modeAdjustBoth = _this$props$managedCl.slider__modeAdjustBoth;\n    const isVertical = this.props.orientation === SliderOrientation.vertical;\n    return super.generateClassNames(classNames(slider, [slider__disabled, this.props.disabled], [slider__dragging, this.state.isMouseDragging || this.state.isTouchDragging], [slider__touchDragging, this.state.isTouchDragging], [slider__incrementing, this.state.isIncrementing], [slider__vertical, isVertical], [slider__horizontal, !isVertical], [slider__rtl, this.state.direction === Direction.rtl], [slider__modeSingle, this.props.mode === SliderMode.singleValue], [slider__modeAdjustUpper, this.props.mode === SliderMode.adustUpperValue], [slider__modeAdjustLower, this.props.mode === SliderMode.adustLowerValue], [slider__modeAdjustBoth, this.props.mode === SliderMode.adjustBoth]));\n  }\n  /**\n   *  Renders the appropriate thumb\n   */\n\n\n  renderThumb(thumb) {\n    if (!this.shouldRenderThumb(thumb)) {\n      return;\n    }\n\n    const mouseDownCallback = thumb === SliderThumb.upperThumb ? this.handleUpperThumbMouseDown : this.handleLowerThumbMouseDown;\n    const keyDownCallback = thumb === SliderThumb.upperThumb ? this.handleUpperThumbKeyDown : this.handleLowerThumbKeyDown;\n    const touchStartCallback = thumb === SliderThumb.upperThumb ? this.handleUpperThumbTouchStart : this.handleLowerThumbTouchStart;\n\n    if (typeof this.props.thumb === \"function\") {\n      return this.props.thumb(this.props, this.state, mouseDownCallback, keyDownCallback, thumb, touchStartCallback);\n    } else {\n      return this.renderDefaultThumb(this.props, this.state, mouseDownCallback, keyDownCallback, thumb, touchStartCallback);\n    }\n  }\n  /**\n   *  Renders the default thumb\n   */\n\n\n  renderDefaultThumb(props, state, mouseDownCallback, keyDownCallback, thumb, touchStartCallback) {\n    return React.createElement(SliderTrackItem, Object.assign({}, this.getThumbManagedClasses(thumb), {\n      minValuePositionBinding: thumb === SliderThumb.lowerThumb ? SliderTrackItemAnchor.selectedRangeMin : undefined,\n      maxValuePositionBinding: thumb === SliderThumb.upperThumb ? SliderTrackItemAnchor.selectedRangeMax : undefined,\n      draggable: false,\n      role: \"slider\",\n      tabIndex: props.disabled === true ? null : 0,\n      onKeyDown: keyDownCallback,\n      onMouseDown: mouseDownCallback,\n      onTouchStart: touchStartCallback,\n      \"aria-valuemin\": typeof props.displayValueConverter === \"function\" ? props.displayValueConverter(props.range.minValue) : props.range.minValue,\n      \"aria-valuemax\": typeof props.displayValueConverter === \"function\" ? props.displayValueConverter(props.range.maxValue) : props.range.maxValue,\n      \"aria-valuenow\": typeof props.displayValueConverter === \"function\" ? props.displayValueConverter(thumb === SliderThumb.lowerThumb ? state.lowerValue : state.upperValue) : thumb === SliderThumb.lowerThumb ? state.lowerValue : state.upperValue,\n      \"aria-valuetext\": typeof props.valuetextStringFormatter === \"function\" ? props.valuetextStringFormatter(props, state, thumb) : null,\n      \"aria-label\": thumb === SliderThumb.upperThumb ? props.maxThumbLabel || null : props.minThumbLabel || null\n    }));\n  }\n  /**\n   * Renders a hidden input element which can interact with a\n   * form hosting this component\n   */\n\n\n  renderHiddenInputElement() {\n    let formattedValue = \"\";\n\n    switch (this.props.mode) {\n      case SliderMode.adjustBoth:\n        formattedValue = `[${this.state.lowerValue},${this.state.upperValue}]`;\n        break;\n\n      case SliderMode.adustUpperValue:\n      case SliderMode.singleValue:\n        formattedValue = `${this.state.upperValue}`;\n        break;\n\n      case SliderMode.adustLowerValue:\n        formattedValue = `${this.state.lowerValue}`;\n        break;\n    }\n\n    return React.createElement(\"input\", {\n      type: \"range\",\n      name: this.props.name || null,\n      form: this.props.form || null,\n      value: formattedValue,\n      onChange: this.onInputValueChange,\n      disabled: this.props.disabled || null,\n      style: {\n        display: \"none\"\n      }\n    });\n  }\n\n}\n\nSlider.displayName = `${DisplayNamePrefix}Slider`;\nSlider.defaultProps = {\n  disabled: false,\n  orientation: SliderOrientation.horizontal,\n  mode: SliderMode.singleValue,\n  range: {\n    minValue: 0,\n    maxValue: 100\n  },\n  step: 1,\n  managedClasses: {}\n};\nSlider.baseIncrementDelay = 300;\nSlider.minIncrementDelay = 100;\nSlider.incrementAcceleration = 50;\nSlider.rolePropName = \"role\";\nSlider.DirectionAttributeName = \"dir\";\nexport default Slider;\nexport * from \"./slider.props\";\nexport { SliderContext };","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-react-base/dist/slider/slider.js"],"names":["SliderMode","SliderOrientation","React","get","isNil","Foundation","keyCodeArrowDown","keyCodeArrowLeft","keyCodeArrowRight","keyCodeArrowUp","keyCodeEnd","keyCodeHome","keyCodePageDown","keyCodePageUp","classNames","Direction","DisplayNamePrefix","SliderContext","SliderTrackItem","SliderTrackItemAnchor","SliderThumb","Slider","constructor","props","handledProps","disabled","managedClasses","orientation","mode","initialValue","range","pageStep","step","value","constrainedRange","onValueChange","name","form","thumb","minThumbLabel","maxThumbLabel","valuetextStringFormatter","displayValueConverter","rootElement","createRef","sliderTrackElement","rangeInPixels","barMinPixel","lastIncrementDelay","baseIncrementDelay","renderSliderInternals","state","direction","createElement","Provider","sliderOrientation","sliderMode","sliderState","sliderConstrainedRange","sliderValueAsPercent","valueAsPercent","sliderDirection","className","slider_layoutRegion","style","position","slider_backgroundTrack","slider_foregroundTrack","maxValuePositionBinding","selectedRangeMax","minValuePositionBinding","selectedRangeMin","ref","onMouseDown","handleTrackMouseDown","slider_track","children","renderThumb","upperThumb","lowerThumb","renderHiddenInputElement","updateValuesForModeSwitch","adjustBoth","adustLowerValue","updateValues","lowerValue","maxValue","adustUpperValue","minValue","upperValue","singleValue","getConstrainedValue","baseValue","constraint","undefined","constrainToRange","constrainToStep","valueAsRange","getThumbManagedClasses","thumbBaseClass","sliderTrackItem","concat","sliderTrackItem_horizontal","sliderTrackItem_vertical","onInputValueChange","event","shouldRenderThumb","defaultPrevented","isBusyOrDisabled","preventDefault","updateSliderDimensions","pixelCoordinate","vertical","pageY","pageX","newValue","convertPixelToPercent","handleMultiThumbTrackClick","updateDirection","newDirection","getDirection","suspendActiveOperations","setState","current","ltr","closest","DirectionAttributeName","getAttribute","rtl","clientHeight","clientWidth","getBoundingClientRect","bottom","left","startIncrementing","incrementDirection","usePageStep","isIncrementing","window","addEventListener","handleWindowKeyUp","activeThumb","incrementTimer","setTimeout","incrementTimerExpired","incrementValue","clearTimeout","incrementAcceleration","minIncrementDelay","stopIncrementing","removeEventListener","pixelPos","pct","handleUpperThumbKeyDown","handleThumbKeydown","handleLowerThumbKeyDown","keyCode","setMinValue","setMaxValue","thumbRange","getConstrainedRange","handleUpperThumbMouseDown","e","handleThumbMouseDown","handleLowerThumbMouseDown","target","focus","handleWindowMouseUp","handleMouseMove","isMouseDragging","updateDragValue","getDragValue","nativeEvent","clientY","clientX","dragValue","handleUpperThumbTouchStart","handleThumbTouchStart","handleLowerThumbTouchStart","handleTouchEnd","handleTouchMove","isTouchDragging","thisTouch","touches","item","getValidTouch","touchCount","length","i","touchElement","attributes","rolePropName","tabIndex","contains","validTouch","stopTouchDragging","newDragValue","constrainToOppositeEndOfSelection","rangeMin","rangeMax","newLowerValue","newUpperValue","invokeValueChange","stopDragging","constrainedValue","remainder","percentAsValue","defaultValue","componentDidMount","componentWillUnmount","componentDidUpdate","prevProps","render","Object","assign","unhandledProps","generateClassNames","slider","slider__disabled","slider__dragging","slider__touchDragging","slider__incrementing","slider__vertical","slider__horizontal","slider__rtl","slider__modeSingle","slider__modeAdjustUpper","slider__modeAdjustLower","slider__modeAdjustBoth","isVertical","mouseDownCallback","keyDownCallback","touchStartCallback","renderDefaultThumb","draggable","role","onKeyDown","onTouchStart","formattedValue","type","onChange","display","displayName","defaultProps","horizontal"],"mappings":"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","sourcesContent":["import { SliderMode, SliderOrientation, } from \"./slider.props\";\nimport React from \"react\";\nimport { get, isNil } from \"lodash-es\";\nimport Foundation from \"@microsoft/fast-components-foundation-react\";\nimport { keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnd, keyCodeHome, keyCodePageDown, keyCodePageUp, } from \"@microsoft/fast-web-utilities\";\nimport { classNames, Direction } from \"@microsoft/fast-web-utilities\";\nimport { DisplayNamePrefix } from \"../utilities\";\nimport { SliderContext } from \"./slider-context\";\nimport SliderTrackItem, { SliderTrackItemAnchor, } from \"../slider-track-item\";\nexport var SliderThumb;\n(function (SliderThumb) {\n    SliderThumb[\"upperThumb\"] = \"upperThumb\";\n    SliderThumb[\"lowerThumb\"] = \"lowerThumb\";\n})(SliderThumb || (SliderThumb = {}));\nclass Slider extends Foundation {\n    /**\n     * constructor\n     */\n    constructor(props) {\n        super(props);\n        this.handledProps = {\n            disabled: void 0,\n            managedClasses: void 0,\n            orientation: void 0,\n            mode: void 0,\n            initialValue: void 0,\n            range: void 0,\n            pageStep: void 0,\n            step: void 0,\n            value: void 0,\n            constrainedRange: void 0,\n            onValueChange: void 0,\n            name: void 0,\n            form: void 0,\n            thumb: void 0,\n            minThumbLabel: void 0,\n            maxThumbLabel: void 0,\n            valuetextStringFormatter: void 0,\n            displayValueConverter: void 0,\n        };\n        this.rootElement = React.createRef();\n        this.sliderTrackElement = React.createRef();\n        this.rangeInPixels = 1;\n        this.barMinPixel = 0;\n        this.lastIncrementDelay = Slider.baseIncrementDelay;\n        /**\n         * Renders the internals of the component but skips the\n         * first render so we can determine direction before doing layout\n         * (avoids transition animations to get the layout right to begin with)\n         */\n        this.renderSliderInternals = () => {\n            if (this.state.direction === null) {\n                return null;\n            }\n            return (React.createElement(SliderContext.Provider, { value: {\n                    sliderOrientation: this.props.orientation,\n                    sliderMode: this.props.mode,\n                    sliderState: this.state,\n                    sliderConstrainedRange: this.props.constrainedRange,\n                    sliderValueAsPercent: this.valueAsPercent,\n                    sliderDirection: this.state.direction,\n                } },\n                React.createElement(\"div\", { className: classNames(this.props.managedClasses.slider_layoutRegion), style: {\n                        position: \"relative\",\n                    } },\n                    React.createElement(\"div\", { className: classNames(this.props.managedClasses.slider_backgroundTrack), style: {\n                            position: \"absolute\",\n                        } }),\n                    React.createElement(SliderTrackItem, { className: this.props.managedClasses.slider_foregroundTrack, maxValuePositionBinding: SliderTrackItemAnchor.selectedRangeMax, minValuePositionBinding: SliderTrackItemAnchor.selectedRangeMin }),\n                    React.createElement(\"div\", { ref: this.sliderTrackElement, onMouseDown: this.handleTrackMouseDown, className: classNames(this.props.managedClasses.slider_track), style: {\n                            position: \"absolute\",\n                        } }),\n                    this.props.children,\n                    this.renderThumb(SliderThumb.upperThumb),\n                    this.renderThumb(SliderThumb.lowerThumb)),\n                this.renderHiddenInputElement()));\n        };\n        /**\n         * Updates values when mode is switched in props\n         */\n        this.updateValuesForModeSwitch = () => {\n            switch (this.props.mode) {\n                case SliderMode.adjustBoth:\n                    break;\n                case SliderMode.adustLowerValue:\n                    this.updateValues(this.state.lowerValue, this.props.range.maxValue);\n                    break;\n                case SliderMode.adustUpperValue:\n                    this.updateValues(this.props.range.minValue, this.state.upperValue);\n                    break;\n                case SliderMode.singleValue:\n                    this.updateValues(this.state.upperValue, this.state.upperValue);\n                    break;\n            }\n        };\n        /**\n         *  Constrains a value to be within the provided constraint range and step\n         */\n        this.getConstrainedValue = (baseValue, constraint, step) => {\n            if (constraint === null || constraint === undefined) {\n                constraint = this.props.range;\n            }\n            const constrainedRange = {\n                minValue: this.constrainToRange(this.constrainToStep(this.valueAsRange(baseValue).minValue, step), constraint),\n                maxValue: this.constrainToRange(this.constrainToStep(this.valueAsRange(baseValue).maxValue, step), constraint),\n            };\n            return constrainedRange;\n        };\n        /**\n         *  Maps the default thumb managed classes to the appropriate slider managed classes\n         */\n        this.getThumbManagedClasses = (thumb) => {\n            const thumbBaseClass = get(this.props, \"managedClasses.slider_thumb\", \"\");\n            return {\n                managedClasses: {\n                    sliderTrackItem: thumb === SliderThumb.upperThumb\n                        ? get(this.props, \"managedClasses.slider_thumb__upperValue\", \"\").concat(\" \", thumbBaseClass)\n                        : get(this.props, \"managedClasses.slider_thumb__lowerValue\", \"\").concat(\" \", thumbBaseClass),\n                    sliderTrackItem_horizontal: get(this.props, \"managedClasses.slider_thumb__horizontal\", \"\"),\n                    sliderTrackItem_vertical: get(this.props, \"managedClasses.slider_thumb__vertical\", \"\"),\n                },\n            };\n        };\n        /**\n         * This exists only to suppress a build warning\n         */\n        this.onInputValueChange = (event) => {\n            return null;\n        };\n        /**\n         *  Determines whether a particular thumb should render in the current mode\n         */\n        this.shouldRenderThumb = (thumb) => {\n            if ((this.props.mode === SliderMode.adustLowerValue &&\n                thumb === SliderThumb.upperThumb) ||\n                (this.props.mode === SliderMode.adustUpperValue &&\n                    thumb === SliderThumb.lowerThumb) ||\n                (this.props.mode === SliderMode.singleValue &&\n                    thumb === SliderThumb.lowerThumb)) {\n                return false;\n            }\n            return true;\n        };\n        /**\n         * Handles track clicks\n         */\n        this.handleTrackMouseDown = (event) => {\n            if (event.defaultPrevented || this.isBusyOrDisabled()) {\n                return;\n            }\n            event.preventDefault();\n            this.updateSliderDimensions();\n            const pixelCoordinate = this.props.orientation === SliderOrientation.vertical\n                ? event.pageY\n                : event.pageX;\n            const newValue = (this.props.range.maxValue - this.props.range.minValue) *\n                this.convertPixelToPercent(pixelCoordinate) +\n                this.props.range.minValue;\n            switch (this.props.mode) {\n                case SliderMode.singleValue:\n                    this.updateValues(newValue, newValue);\n                    break;\n                case SliderMode.adjustBoth:\n                    this.handleMultiThumbTrackClick(newValue);\n                    break;\n                case SliderMode.adustLowerValue:\n                    this.updateValues(newValue, null);\n                    break;\n                case SliderMode.adustUpperValue:\n                    this.updateValues(null, newValue);\n                    break;\n            }\n        };\n        /**\n         *  Handles track clicks when there are multiple thumbs\n         */\n        this.handleMultiThumbTrackClick = (value) => {\n            if (value <= this.state.lowerValue) {\n                this.updateValues(value, null);\n            }\n            else if (value >= this.state.upperValue) {\n                this.updateValues(null, value);\n            }\n            else {\n                // between values move the closest thumb to the click\n                if (value - this.state.lowerValue < this.state.upperValue - value) {\n                    this.updateValues(value, null);\n                }\n                else {\n                    this.updateValues(null, value);\n                }\n            }\n        };\n        /**\n         *  updates the direction in state if necessary\n         */\n        this.updateDirection = () => {\n            const newDirection = this.getDirection();\n            if (newDirection !== this.state.direction) {\n                this.suspendActiveOperations();\n                this.setState({\n                    direction: newDirection,\n                });\n            }\n        };\n        /**\n         *  gets the current direction\n         */\n        this.getDirection = () => {\n            if (this.rootElement.current === null) {\n                return Direction.ltr;\n            }\n            const closest = this.rootElement.current.closest(`[${Slider.DirectionAttributeName}]`);\n            return closest === null ||\n                closest.getAttribute(Slider.DirectionAttributeName) === Direction.ltr\n                ? Direction.ltr\n                : Direction.rtl;\n        };\n        /**\n         * Measures the slider dimensions and stores them\n         */\n        this.updateSliderDimensions = () => {\n            if (this.sliderTrackElement.current === null) {\n                return;\n            }\n            this.rangeInPixels =\n                this.props.orientation === SliderOrientation.vertical\n                    ? this.sliderTrackElement.current.clientHeight\n                    : this.sliderTrackElement.current.clientWidth;\n            if (this.rangeInPixels === 0) {\n                this.rangeInPixels = 1;\n            }\n            this.barMinPixel =\n                this.props.orientation === SliderOrientation.vertical\n                    ? this.sliderTrackElement.current.getBoundingClientRect().bottom\n                    : this.sliderTrackElement.current.getBoundingClientRect().left;\n        };\n        /**\n         * Start timed incrementing from\n         */\n        this.startIncrementing = (incrementDirection, usePageStep, thumb, event) => {\n            event.preventDefault();\n            if (this.state.isIncrementing) {\n                return;\n            }\n            this.updateSliderDimensions();\n            window.addEventListener(\"keyup\", this.handleWindowKeyUp);\n            this.setState({\n                usePageStep,\n                activeThumb: thumb,\n                isIncrementing: true,\n                incrementDirection,\n            });\n            this.lastIncrementDelay = Slider.baseIncrementDelay;\n            this.incrementTimer = setTimeout(() => {\n                this.incrementTimerExpired();\n            }, 50);\n        };\n        /**\n         * Increments the value by one step (or pageStep)\n         * when step is set to 0 we increment based on the current pixel width\n         * of the component\n         */\n        this.incrementValue = () => {\n            const step = this.state.usePageStep\n                ? this.props.pageStep\n                : this.props.step !== 0\n                    ? this.props.step\n                    : (this.props.range.maxValue - this.props.range.minValue) /\n                        this.rangeInPixels;\n            let newValue = this.state.activeThumb === SliderThumb.upperThumb\n                ? this.state.upperValue + step * this.state.incrementDirection\n                : this.state.lowerValue + step * this.state.incrementDirection;\n            if (this.props.mode === SliderMode.adjustBoth &&\n                newValue > this.state.upperValue &&\n                this.state.activeThumb !== SliderThumb.upperThumb) {\n                newValue = this.state.upperValue;\n            }\n            else if (this.props.mode === SliderMode.adjustBoth &&\n                newValue < this.state.lowerValue &&\n                this.state.activeThumb !== SliderThumb.lowerThumb) {\n                newValue = this.state.lowerValue;\n            }\n            if (this.state.activeThumb === SliderThumb.upperThumb) {\n                this.updateValues(null, newValue);\n            }\n            else {\n                this.updateValues(newValue, null);\n            }\n        };\n        /**\n         *  Increment timer tick\n         */\n        this.incrementTimerExpired = () => {\n            clearTimeout(this.incrementTimer);\n            this.incrementValue();\n            this.lastIncrementDelay = this.lastIncrementDelay - Slider.incrementAcceleration;\n            if (this.lastIncrementDelay < Slider.minIncrementDelay) {\n                this.lastIncrementDelay = Slider.minIncrementDelay;\n            }\n            this.incrementTimer = setTimeout(() => {\n                this.incrementTimerExpired();\n            }, this.lastIncrementDelay);\n        };\n        /**\n         *  Stop incrementing\n         */\n        this.stopIncrementing = () => {\n            if (!this.state.isIncrementing) {\n                return;\n            }\n            window.removeEventListener(\"keyup\", this.handleWindowKeyUp);\n            this.setState({\n                usePageStep: false,\n                isIncrementing: false,\n            });\n            clearTimeout(this.incrementTimer);\n        };\n        /**\n         * Converts a pixel coordinate on the track to a percent of the track's range\n         */\n        this.convertPixelToPercent = (pixelPos) => {\n            let pct = 0;\n            if (this.props.orientation === SliderOrientation.vertical) {\n                pct = (this.barMinPixel - pixelPos) / this.rangeInPixels;\n            }\n            else {\n                pct = (pixelPos - this.barMinPixel) / this.rangeInPixels;\n            }\n            if (pct < 0) {\n                pct = 0;\n            }\n            else if (pct > 1) {\n                pct = 1;\n            }\n            if (this.state.direction === Direction.rtl &&\n                this.props.orientation !== SliderOrientation.vertical) {\n                pct = 1 - pct;\n            }\n            return pct;\n        };\n        /**\n         * Handles thumb key events\n         */\n        this.handleUpperThumbKeyDown = (event) => {\n            this.handleThumbKeydown(event, SliderThumb.upperThumb);\n        };\n        this.handleLowerThumbKeyDown = (event) => {\n            this.handleThumbKeydown(event, SliderThumb.lowerThumb);\n        };\n        this.handleThumbKeydown = (event, thumb) => {\n            if (event.defaultPrevented || this.isBusyOrDisabled()) {\n                event.preventDefault();\n                return;\n            }\n            switch (event.keyCode) {\n                case keyCodeArrowDown:\n                    this.startIncrementing(-1, false, thumb, event);\n                    break;\n                case keyCodeArrowRight:\n                    this.startIncrementing(this.state.direction === Direction.ltr ? 1 : -1, false, thumb, event);\n                    break;\n                case keyCodeArrowUp:\n                    this.startIncrementing(1, false, thumb, event);\n                    break;\n                case keyCodeArrowLeft:\n                    this.startIncrementing(this.state.direction === Direction.ltr ? -1 : 1, false, thumb, event);\n                    break;\n                case keyCodePageDown:\n                    if (this.props.pageStep !== undefined) {\n                        this.startIncrementing(-1, true, thumb, event);\n                    }\n                    break;\n                case keyCodePageUp:\n                    if (this.props.pageStep !== undefined) {\n                        this.startIncrementing(1, true, thumb, event);\n                    }\n                    break;\n                case keyCodeHome:\n                    this.setMinValue(thumb);\n                    break;\n                case keyCodeEnd:\n                    this.setMaxValue(thumb);\n                    break;\n            }\n        };\n        /**\n         * sets the active thumb to its minimum value\n         */\n        this.setMinValue = (thumb) => {\n            const thumbRange = this.getConstrainedRange(true);\n            if (thumb === SliderThumb.upperThumb) {\n                this.updateValues(null, thumbRange.minValue);\n            }\n            else {\n                this.updateValues(thumbRange.minValue, null);\n            }\n        };\n        /**\n         * sets the active thumb to it's maximum value\n         */\n        this.setMaxValue = (thumb) => {\n            const thumbRange = this.getConstrainedRange(true);\n            if (thumb === SliderThumb.upperThumb) {\n                this.updateValues(null, thumbRange.maxValue);\n            }\n            else {\n                this.updateValues(thumbRange.maxValue, null);\n            }\n        };\n        /**\n         * Handles thumb clicks\n         */\n        this.handleUpperThumbMouseDown = (e) => {\n            this.handleThumbMouseDown(e, SliderThumb.upperThumb);\n        };\n        this.handleLowerThumbMouseDown = (e) => {\n            this.handleThumbMouseDown(e, SliderThumb.lowerThumb);\n        };\n        this.handleThumbMouseDown = (e, thumb) => {\n            if (e.defaultPrevented || this.isBusyOrDisabled()) {\n                return;\n            }\n            e.preventDefault();\n            e.target.focus();\n            window.addEventListener(\"mouseup\", this.handleWindowMouseUp);\n            window.addEventListener(\"mousemove\", this.handleMouseMove);\n            this.setState({\n                isMouseDragging: true,\n                activeThumb: thumb,\n            });\n            this.updateDragValue(this.getDragValue(e.nativeEvent, thumb), thumb);\n        };\n        /**\n         *  Handle mouse moves during a thumb drag operation\n         */\n        this.handleMouseMove = (event) => {\n            if (this.props.disabled || event.defaultPrevented) {\n                return;\n            }\n            this.updateDragValue(this.getDragValue(event, this.state.activeThumb), this.state.activeThumb);\n        };\n        /**\n         *  Get dragvalue from mouse event or touch\n         */\n        this.getDragValue = (event, thumb) => {\n            this.updateSliderDimensions();\n            const pixelCoordinate = this.props.orientation === SliderOrientation.vertical\n                ? event.clientY\n                : event.clientX;\n            const dragValue = (this.props.range.maxValue - this.props.range.minValue) *\n                this.convertPixelToPercent(pixelCoordinate) +\n                this.props.range.minValue;\n            return dragValue;\n        };\n        /**\n         * Handles touch dragging\n         */\n        this.handleUpperThumbTouchStart = (e) => {\n            this.handleThumbTouchStart(e, SliderThumb.upperThumb);\n        };\n        this.handleLowerThumbTouchStart = (e) => {\n            this.handleThumbTouchStart(e, SliderThumb.lowerThumb);\n        };\n        this.handleThumbTouchStart = (e, thumb) => {\n            if (e.defaultPrevented || this.isBusyOrDisabled()) {\n                return;\n            }\n            e.preventDefault();\n            e.target.focus();\n            window.addEventListener(\"touchend\", this.handleTouchEnd);\n            window.addEventListener(\"touchcancel\", this.handleTouchEnd);\n            window.addEventListener(\"touchmove\", this.handleTouchMove);\n            this.setState({\n                isTouchDragging: true,\n                activeThumb: thumb,\n            });\n            const thisTouch = e.nativeEvent.touches.item(0);\n            this.updateDragValue(this.getDragValue(thisTouch, thumb), thumb);\n        };\n        /**\n         *  Returns first valid touch found in a touch event\n         */\n        this.getValidTouch = (event) => {\n            if (isNil(this.rootElement.current)) {\n                return null;\n            }\n            const touchCount = event.touches.length;\n            for (let i = 0; i < touchCount; i++) {\n                const thisTouch = event.touches.item(i);\n                const touchElement = thisTouch.target;\n                if (touchElement.attributes[Slider.rolePropName].value === \"slider\" &&\n                    touchElement.tabIndex === 0 &&\n                    this.rootElement.current.contains(touchElement)) {\n                    return thisTouch;\n                }\n            }\n            return null;\n        };\n        /**\n         *  Handle touch moves during a thumb drag operation\n         */\n        this.handleTouchMove = (event) => {\n            if (this.props.disabled || event.defaultPrevented) {\n                return;\n            }\n            const validTouch = this.getValidTouch(event);\n            if (validTouch === null) {\n                this.stopTouchDragging();\n                return;\n            }\n            this.updateDragValue(this.getDragValue(validTouch, this.state.activeThumb), this.state.activeThumb);\n        };\n        /**\n         * Handle touch end\n         */\n        this.handleTouchEnd = (event) => {\n            event.preventDefault();\n            this.stopTouchDragging();\n        };\n        /**\n         *  Updates the current drag value\n         */\n        this.updateDragValue = (dragValue, thumb) => {\n            const constrainedRange = this.getConstrainedRange(true);\n            const newDragValue = this.constrainToRange(dragValue, constrainedRange);\n            this.setState({\n                dragValue: newDragValue,\n            });\n            if (thumb === SliderThumb.lowerThumb) {\n                this.updateValues(newDragValue, null);\n            }\n            else {\n                this.updateValues(null, newDragValue);\n            }\n        };\n        /**\n         *  Gets the range of values the active thumb is actually allowed to traverse\n         */\n        this.getConstrainedRange = (constrainToOppositeEndOfSelection) => {\n            let rangeMin = this.props.range.minValue;\n            let rangeMax = this.props.range.maxValue;\n            if (this.props.constrainedRange !== undefined) {\n                rangeMin =\n                    this.props.constrainedRange.minValue > rangeMin\n                        ? this.props.constrainedRange.minValue\n                        : rangeMin;\n                rangeMax =\n                    this.props.constrainedRange.maxValue < rangeMax\n                        ? this.props.constrainedRange.maxValue\n                        : rangeMin;\n            }\n            if (this.props.mode !== SliderMode.singleValue &&\n                constrainToOppositeEndOfSelection) {\n                if (this.state.activeThumb === SliderThumb.lowerThumb) {\n                    rangeMax = this.state.upperValue;\n                }\n                else {\n                    rangeMin = this.state.lowerValue;\n                }\n            }\n            return {\n                minValue: rangeMin,\n                maxValue: rangeMax,\n            };\n        };\n        /**\n         *  Converts a single number value to a SliderRange based on current mode\n         */\n        this.valueAsRange = (value) => {\n            if (typeof value === \"number\") {\n                switch (this.props.mode) {\n                    case SliderMode.adjustBoth:\n                    case SliderMode.singleValue:\n                        return {\n                            minValue: value,\n                            maxValue: value,\n                        };\n                    case SliderMode.adustLowerValue:\n                        return {\n                            minValue: value,\n                            maxValue: this.props.range.maxValue,\n                        };\n                    case SliderMode.adustUpperValue:\n                        return {\n                            minValue: this.props.range.minValue,\n                            maxValue: value,\n                        };\n                }\n            }\n            else if (typeof value === \"object\") {\n                return value;\n            }\n        };\n        /**\n         *  Apply value changes to state, only place this should happen outside of constructor and ComponentDidUpdate\n         */\n        this.updateValues = (lowerValue, upperValue) => {\n            let newLowerValue = this.state.lowerValue;\n            let newUpperValue = this.state.upperValue;\n            if (lowerValue !== null) {\n                newLowerValue = this.constrainToRange(this.constrainToStep(lowerValue, this.props.step), this.props.range);\n            }\n            if (upperValue !== null) {\n                newUpperValue = this.constrainToRange(this.constrainToStep(upperValue, this.props.step), this.props.range);\n            }\n            if (this.state.upperValue === newUpperValue &&\n                this.state.lowerValue === newLowerValue) {\n                return;\n            }\n            this.invokeValueChange(newLowerValue, newUpperValue);\n            if (this.props.value === undefined) {\n                this.setState({\n                    lowerValue: this.props.mode === SliderMode.singleValue\n                        ? newUpperValue\n                        : newLowerValue,\n                    upperValue: newUpperValue,\n                });\n            }\n        };\n        /**\n         *  Invokes the value change event and formats params based on current mode\n         */\n        this.invokeValueChange = (lowerValue, upperValue) => {\n            if (typeof this.props.onValueChange === \"function\") {\n                switch (this.props.mode) {\n                    case SliderMode.adjustBoth:\n                        this.props.onValueChange({\n                            minValue: lowerValue,\n                            maxValue: upperValue,\n                        });\n                        break;\n                    case SliderMode.adustUpperValue:\n                    case SliderMode.singleValue:\n                        this.props.onValueChange(upperValue);\n                        break;\n                    case SliderMode.adustLowerValue:\n                        this.props.onValueChange(lowerValue);\n                        break;\n                }\n            }\n        };\n        /**\n         * Handle a window mouse up during a drag operation\n         */\n        this.handleWindowMouseUp = (event) => {\n            this.stopDragging();\n        };\n        /**\n         *  Handle window key up during an incrementing operation\n         */\n        this.handleWindowKeyUp = (event) => {\n            switch (event.keyCode) {\n                case keyCodeArrowDown:\n                case keyCodeArrowRight:\n                case keyCodeArrowUp:\n                case keyCodeArrowLeft:\n                case keyCodePageDown:\n                case keyCodePageUp:\n                    this.stopIncrementing();\n                    break;\n            }\n        };\n        /**\n         *  Ends a thumb drag operation\n         */\n        this.stopDragging = () => {\n            if (!this.state.isMouseDragging) {\n                return;\n            }\n            window.removeEventListener(\"mouseup\", this.handleWindowMouseUp);\n            window.removeEventListener(\"mousemove\", this.handleMouseMove);\n            this.setState({\n                isMouseDragging: false,\n            });\n        };\n        /**\n         *  Ends a thumb touch drag operation\n         */\n        this.stopTouchDragging = () => {\n            if (!this.state.isTouchDragging) {\n                return;\n            }\n            window.removeEventListener(\"touchend\", this.handleTouchEnd);\n            window.removeEventListener(\"touchcancel\", this.handleTouchEnd);\n            window.removeEventListener(\"touchmove\", this.handleTouchMove);\n            this.setState({\n                isTouchDragging: false,\n            });\n        };\n        /**\n         *  Ends active drag/increment operations\n         */\n        this.suspendActiveOperations = () => {\n            this.stopDragging();\n            this.stopTouchDragging();\n            this.stopIncrementing();\n        };\n        /**\n         * Ensures a value falls within the provided range\n         */\n        this.constrainToRange = (value, range) => {\n            let newValue = value;\n            if (newValue > range.maxValue) {\n                newValue = range.maxValue;\n            }\n            else if (newValue < range.minValue) {\n                newValue = range.minValue;\n            }\n            return newValue;\n        };\n        /**\n         * Ensures a value is an even multiple of the slider step increment\n         */\n        this.constrainToStep = (value, step) => {\n            // we remove then restore the slider range min value to\n            // ensure that the remainder calculates correctly in case the minValue\n            // is not based off 0, eg. range minValue 7.5, step 2.  Slider steps increment off\n            // of the min value of the slider's range, not 0.\n            let constrainedValue = value - this.props.range.minValue;\n            const remainder = constrainedValue % step;\n            constrainedValue =\n                remainder >= step / 2 // check to see if this is over half a single step\n                    ? constrainedValue - remainder + step // if so add a step\n                    : constrainedValue - remainder;\n            return constrainedValue + this.props.range.minValue;\n        };\n        /**\n         * Converts value to a percent of slider range\n         */\n        this.valueAsPercent = (value) => {\n            return (((value - this.props.range.minValue) /\n                (this.props.range.maxValue - this.props.range.minValue)) *\n                100);\n        };\n        /**\n         *  Converts a percent value to the equivalent value on the bar range\n         */\n        this.percentAsValue = (value) => {\n            return (((this.props.range.maxValue - this.props.range.minValue) / 100) * value +\n                this.props.range.minValue);\n        };\n        /**\n         *  Checks if the component is busy with an active operation or disabled\n         */\n        this.isBusyOrDisabled = () => {\n            if (this.props.disabled ||\n                this.state.isMouseDragging ||\n                this.state.isIncrementing ||\n                this.state.isTouchDragging) {\n                return true;\n            }\n            return false;\n        };\n        let initialValue = {\n            minValue: this.props.range.minValue,\n            maxValue: this.props.range.maxValue,\n        };\n        if (this.props.value !== undefined) {\n            initialValue = this.getConstrainedValue(this.props.value, this.props.constrainedRange, this.props.step);\n        }\n        else if (this.props.initialValue !== undefined) {\n            initialValue = this.getConstrainedValue(this.props.initialValue, this.props.constrainedRange, this.props.step);\n        }\n        else {\n            let defaultValue = {\n                minValue: 0,\n                maxValue: 0,\n            };\n            switch (this.props.mode) {\n                case SliderMode.singleValue:\n                    defaultValue = {\n                        minValue: this.percentAsValue(50),\n                        maxValue: this.percentAsValue(50),\n                    };\n                    break;\n                case SliderMode.adjustBoth:\n                    defaultValue = {\n                        minValue: this.percentAsValue(40),\n                        maxValue: this.percentAsValue(60),\n                    };\n                    break;\n                case SliderMode.adustLowerValue:\n                    defaultValue = {\n                        minValue: this.percentAsValue(50),\n                        maxValue: this.props.range.maxValue,\n                    };\n                    break;\n                case SliderMode.adustUpperValue:\n                    defaultValue = {\n                        minValue: this.props.range.minValue,\n                        maxValue: this.percentAsValue(50),\n                    };\n                    break;\n            }\n            initialValue = this.getConstrainedValue(defaultValue, this.props.constrainedRange, this.props.step);\n        }\n        this.state = {\n            dragValue: -1,\n            upperValue: initialValue.maxValue,\n            lowerValue: initialValue.minValue,\n            activeThumb: null,\n            isMouseDragging: false,\n            isTouchDragging: false,\n            isIncrementing: false,\n            incrementDirection: 1,\n            usePageStep: false,\n            direction: null,\n        };\n    }\n    /**\n     * React lifecycle methods\n     */\n    componentDidMount() {\n        this.updateDirection();\n    }\n    componentWillUnmount() {\n        this.suspendActiveOperations();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.disabled !== this.props.disabled && this.props.disabled) {\n            this.suspendActiveOperations();\n        }\n        if (prevProps.value !== this.props.value && this.props.value !== undefined) {\n            const newValue = this.getConstrainedValue(this.props.value, this.props.constrainedRange, this.props.step);\n            this.setState({\n                lowerValue: newValue.minValue,\n                upperValue: newValue.maxValue,\n            });\n        }\n        else if (prevProps.constrainedRange !== this.props.constrainedRange ||\n            prevProps.step !== this.props.step) {\n            this.suspendActiveOperations();\n            this.updateValues(this.state.lowerValue, this.state.upperValue);\n        }\n        if (prevProps.mode !== this.props.mode) {\n            this.suspendActiveOperations();\n            this.updateValuesForModeSwitch();\n        }\n        this.updateDirection();\n    }\n    /**\n     * Renders the component\n     */\n    render() {\n        return (React.createElement(\"div\", Object.assign({}, this.unhandledProps(), { ref: this.rootElement, className: this.generateClassNames() }), this.renderSliderInternals()));\n    }\n    /**\n     * Generates class names\n     */\n    generateClassNames() {\n        const { slider, slider__disabled, slider__dragging, slider__touchDragging, slider__incrementing, slider__vertical, slider__horizontal, slider__rtl, slider__modeSingle, slider__modeAdjustUpper, slider__modeAdjustLower, slider__modeAdjustBoth, } = this.props.managedClasses;\n        const isVertical = this.props.orientation === SliderOrientation.vertical;\n        return super.generateClassNames(classNames(slider, [slider__disabled, this.props.disabled], [\n            slider__dragging,\n            this.state.isMouseDragging || this.state.isTouchDragging,\n        ], [slider__touchDragging, this.state.isTouchDragging], [slider__incrementing, this.state.isIncrementing], [slider__vertical, isVertical], [slider__horizontal, !isVertical], [slider__rtl, this.state.direction === Direction.rtl], [slider__modeSingle, this.props.mode === SliderMode.singleValue], [slider__modeAdjustUpper, this.props.mode === SliderMode.adustUpperValue], [slider__modeAdjustLower, this.props.mode === SliderMode.adustLowerValue], [slider__modeAdjustBoth, this.props.mode === SliderMode.adjustBoth]));\n    }\n    /**\n     *  Renders the appropriate thumb\n     */\n    renderThumb(thumb) {\n        if (!this.shouldRenderThumb(thumb)) {\n            return;\n        }\n        const mouseDownCallback = thumb === SliderThumb.upperThumb\n            ? this.handleUpperThumbMouseDown\n            : this.handleLowerThumbMouseDown;\n        const keyDownCallback = thumb === SliderThumb.upperThumb\n            ? this.handleUpperThumbKeyDown\n            : this.handleLowerThumbKeyDown;\n        const touchStartCallback = thumb === SliderThumb.upperThumb\n            ? this.handleUpperThumbTouchStart\n            : this.handleLowerThumbTouchStart;\n        if (typeof this.props.thumb === \"function\") {\n            return this.props.thumb(this.props, this.state, mouseDownCallback, keyDownCallback, thumb, touchStartCallback);\n        }\n        else {\n            return this.renderDefaultThumb(this.props, this.state, mouseDownCallback, keyDownCallback, thumb, touchStartCallback);\n        }\n    }\n    /**\n     *  Renders the default thumb\n     */\n    renderDefaultThumb(props, state, mouseDownCallback, keyDownCallback, thumb, touchStartCallback) {\n        return (React.createElement(SliderTrackItem, Object.assign({}, this.getThumbManagedClasses(thumb), { minValuePositionBinding: thumb === SliderThumb.lowerThumb\n                ? SliderTrackItemAnchor.selectedRangeMin\n                : undefined, maxValuePositionBinding: thumb === SliderThumb.upperThumb\n                ? SliderTrackItemAnchor.selectedRangeMax\n                : undefined, draggable: false, role: \"slider\", tabIndex: props.disabled === true ? null : 0, onKeyDown: keyDownCallback, onMouseDown: mouseDownCallback, onTouchStart: touchStartCallback, \"aria-valuemin\": typeof props.displayValueConverter === \"function\"\n                ? props.displayValueConverter(props.range.minValue)\n                : props.range.minValue, \"aria-valuemax\": typeof props.displayValueConverter === \"function\"\n                ? props.displayValueConverter(props.range.maxValue)\n                : props.range.maxValue, \"aria-valuenow\": typeof props.displayValueConverter === \"function\"\n                ? props.displayValueConverter(thumb === SliderThumb.lowerThumb\n                    ? state.lowerValue\n                    : state.upperValue)\n                : thumb === SliderThumb.lowerThumb\n                    ? state.lowerValue\n                    : state.upperValue, \"aria-valuetext\": typeof props.valuetextStringFormatter === \"function\"\n                ? props.valuetextStringFormatter(props, state, thumb)\n                : null, \"aria-label\": thumb === SliderThumb.upperThumb\n                ? props.maxThumbLabel || null\n                : props.minThumbLabel || null })));\n    }\n    /**\n     * Renders a hidden input element which can interact with a\n     * form hosting this component\n     */\n    renderHiddenInputElement() {\n        let formattedValue = \"\";\n        switch (this.props.mode) {\n            case SliderMode.adjustBoth:\n                formattedValue = `[${this.state.lowerValue},${this.state.upperValue}]`;\n                break;\n            case SliderMode.adustUpperValue:\n            case SliderMode.singleValue:\n                formattedValue = `${this.state.upperValue}`;\n                break;\n            case SliderMode.adustLowerValue:\n                formattedValue = `${this.state.lowerValue}`;\n                break;\n        }\n        return (React.createElement(\"input\", { type: \"range\", name: this.props.name || null, form: this.props.form || null, value: formattedValue, onChange: this.onInputValueChange, disabled: this.props.disabled || null, style: {\n                display: \"none\",\n            } }));\n    }\n}\nSlider.displayName = `${DisplayNamePrefix}Slider`;\nSlider.defaultProps = {\n    disabled: false,\n    orientation: SliderOrientation.horizontal,\n    mode: SliderMode.singleValue,\n    range: {\n        minValue: 0,\n        maxValue: 100,\n    },\n    step: 1,\n    managedClasses: {},\n};\nSlider.baseIncrementDelay = 300;\nSlider.minIncrementDelay = 100;\nSlider.incrementAcceleration = 50;\nSlider.rolePropName = \"role\";\nSlider.DirectionAttributeName = \"dir\";\nexport default Slider;\nexport * from \"./slider.props\";\nexport { SliderContext };\n"]},"metadata":{},"sourceType":"module"}