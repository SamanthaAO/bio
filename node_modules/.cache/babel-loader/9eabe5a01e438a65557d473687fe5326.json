{"ast":null,"code":"import _classCallCheck from \"/Users/samorcutt/Desktop/bio/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * For each possible color, this counts how many pixels in the source image match that color.\n * If signifigantBits is less tahn 8, each channel (eg: red, green, blue) in each color is reduced to fit in significantBits. So for the default value of 5 significantBits colors are reduced from 8 bits per channel (0-255) to 5 (0-31). Colors that were previously distinct get combined together.\n * If the image source has more than 2^32 pixels (eg: a square image 65536x65536 in size) of the same color this code will break.\n */\nexport var Histogram =\n/**\n * @param source\n * @param significantBits The memory needed for the histogram increases dramaticially if significantBits is increased. It needs a buffer which is 4*2^(3*significantBits) in size. EG: for 5 significant bits the histogram is 128K while for 8 it is 64 megs.\n * @param pixelSkipping CPU time increases linearly as pixelSkipping is reduced.\n * @param isHistogramPixelValid isHistogramPixelValid is an optional predicate which can screen out unwanted pixels from the source data. EG: ignoring transparent pixels.\n */\nfunction Histogram(source) {\n  var _this = this;\n\n  var significantBits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  var pixelSkipping = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n  var isHistogramPixelValid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  _classCallCheck(this, Histogram);\n\n  this.getHistogramIndex = function (r, g, b) {\n    var index = (r << 2 * _this.significantBits) + (g << _this.significantBits) + b;\n\n    if (index >= _this.data.length) {\n      throw new Error(\"RGB value is outside the bounds of the histogram\");\n    }\n\n    return index;\n  };\n\n  this.getHistogramValue = function (r, g, b) {\n    return _this.data[_this.getHistogramIndex(r, g, b)];\n  };\n\n  this.setHistogramValue = function (value, r, g, b) {\n    _this.data[_this.getHistogramIndex(r, g, b)] = value;\n  };\n\n  if (significantBits < 1 || significantBits > 8) {\n    throw new Error(\"significantBits must be in the range [1,8]\");\n  }\n\n  if (pixelSkipping < 0) {\n    throw new Error(\"pixelSkipping must be >= 0\");\n  }\n\n  this.significantBits = significantBits;\n  var sigShift = 8 - this.significantBits;\n  this.minRed = 255 >>> sigShift;\n  this.maxRed = 0;\n  this.minGreen = 255 >>> sigShift;\n  this.maxGreen = 0;\n  this.minBlue = 255 >>> sigShift;\n  this.maxBlue = 0;\n  var histoSize = 1 << significantBits * 3;\n  this.data = new Uint32Array(histoSize);\n  this.data.fill(0);\n  this.total = 0;\n  var pixelIndex = 0;\n\n  for (var y = 0; y < source.height; y++) {\n    for (var x = 0; x < source.width; x++) {\n      if (pixelSkipping > 0 && pixelIndex++ % pixelSkipping !== 0) {\n        continue;\n      }\n\n      var rgba = source.getPixelRGBA(x, y);\n\n      if (isHistogramPixelValid !== null) {\n        if (!isHistogramPixelValid(rgba)) {\n          continue;\n        }\n      } // Shift the pixel data into the range determined by significantBits\n      // after checking minAlpha the alpha data is no longer needed\n\n\n      rgba[0] = rgba[0] >>> sigShift;\n      rgba[1] = rgba[1] >>> sigShift;\n      rgba[2] = rgba[2] >>> sigShift;\n      this.minRed = Math.min(rgba[0], this.minRed);\n      this.maxRed = Math.max(rgba[0], this.maxRed);\n      this.minGreen = Math.min(rgba[1], this.minGreen);\n      this.maxGreen = Math.max(rgba[1], this.maxGreen);\n      this.minBlue = Math.min(rgba[2], this.minBlue);\n      this.maxBlue = Math.max(rgba[2], this.maxBlue);\n      var histoIndex = this.getHistogramIndex(rgba[0], rgba[1], rgba[2]);\n      this.data[histoIndex] += 1;\n      this.total++;\n    }\n  }\n};","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-colors/dist/histogram.js"],"names":["Histogram","source","significantBits","pixelSkipping","isHistogramPixelValid","getHistogramIndex","r","g","b","index","data","length","Error","getHistogramValue","setHistogramValue","value","sigShift","minRed","maxRed","minGreen","maxGreen","minBlue","maxBlue","histoSize","Uint32Array","fill","total","pixelIndex","y","height","x","width","rgba","getPixelRGBA","Math","min","max","histoIndex"],"mappings":"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","sourcesContent":["/**\n * For each possible color, this counts how many pixels in the source image match that color.\n * If signifigantBits is less tahn 8, each channel (eg: red, green, blue) in each color is reduced to fit in significantBits. So for the default value of 5 significantBits colors are reduced from 8 bits per channel (0-255) to 5 (0-31). Colors that were previously distinct get combined together.\n * If the image source has more than 2^32 pixels (eg: a square image 65536x65536 in size) of the same color this code will break.\n */\nexport class Histogram {\n    /**\n     * @param source\n     * @param significantBits The memory needed for the histogram increases dramaticially if significantBits is increased. It needs a buffer which is 4*2^(3*significantBits) in size. EG: for 5 significant bits the histogram is 128K while for 8 it is 64 megs.\n     * @param pixelSkipping CPU time increases linearly as pixelSkipping is reduced.\n     * @param isHistogramPixelValid isHistogramPixelValid is an optional predicate which can screen out unwanted pixels from the source data. EG: ignoring transparent pixels.\n     */\n    constructor(source, significantBits = 5, pixelSkipping = 5, isHistogramPixelValid = null) {\n        this.getHistogramIndex = (r, g, b) => {\n            const index = (r << (2 * this.significantBits)) + (g << this.significantBits) + b;\n            if (index >= this.data.length) {\n                throw new Error(\"RGB value is outside the bounds of the histogram\");\n            }\n            return index;\n        };\n        this.getHistogramValue = (r, g, b) => {\n            return this.data[this.getHistogramIndex(r, g, b)];\n        };\n        this.setHistogramValue = (value, r, g, b) => {\n            this.data[this.getHistogramIndex(r, g, b)] = value;\n        };\n        if (significantBits < 1 || significantBits > 8) {\n            throw new Error(\"significantBits must be in the range [1,8]\");\n        }\n        if (pixelSkipping < 0) {\n            throw new Error(\"pixelSkipping must be >= 0\");\n        }\n        this.significantBits = significantBits;\n        const sigShift = 8 - this.significantBits;\n        this.minRed = 255 >>> sigShift;\n        this.maxRed = 0;\n        this.minGreen = 255 >>> sigShift;\n        this.maxGreen = 0;\n        this.minBlue = 255 >>> sigShift;\n        this.maxBlue = 0;\n        const histoSize = 1 << (significantBits * 3);\n        this.data = new Uint32Array(histoSize);\n        this.data.fill(0);\n        this.total = 0;\n        let pixelIndex = 0;\n        for (let y = 0; y < source.height; y++) {\n            for (let x = 0; x < source.width; x++) {\n                if (pixelSkipping > 0 && pixelIndex++ % pixelSkipping !== 0) {\n                    continue;\n                }\n                const rgba = source.getPixelRGBA(x, y);\n                if (isHistogramPixelValid !== null) {\n                    if (!isHistogramPixelValid(rgba)) {\n                        continue;\n                    }\n                }\n                // Shift the pixel data into the range determined by significantBits\n                // after checking minAlpha the alpha data is no longer needed\n                rgba[0] = rgba[0] >>> sigShift;\n                rgba[1] = rgba[1] >>> sigShift;\n                rgba[2] = rgba[2] >>> sigShift;\n                this.minRed = Math.min(rgba[0], this.minRed);\n                this.maxRed = Math.max(rgba[0], this.maxRed);\n                this.minGreen = Math.min(rgba[1], this.minGreen);\n                this.maxGreen = Math.max(rgba[1], this.maxGreen);\n                this.minBlue = Math.min(rgba[2], this.minBlue);\n                this.maxBlue = Math.max(rgba[2], this.maxBlue);\n                const histoIndex = this.getHistogramIndex(rgba[0], rgba[1], rgba[2]);\n                this.data[histoIndex] += 1;\n                this.total++;\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}