{"ast":null,"code":"import { mergeWith } from \"lodash-es\";\nimport React from \"react\";\nimport { designSystemContext } from \"./context\";\nimport SheetManager from \"./sheet-manager\";\nexport function mergeClassNames(a, b) {\n  if (typeof a === \"string\" && typeof b === \"string\") {\n    return a.concat(\" \", b);\n  } else if (typeof a === \"string\") {\n    return a;\n  } else if (typeof b === \"string\") {\n    return b;\n  }\n}\n\nclass JSSManager extends React.Component {\n  constructor(props, context) {\n    super(props, context);\n    /**\n     * Simple switch to track the initial creation of styles.\n     * Because the \"styles\" property is abstract and abstract properties\n     * are not accessible in the constructor,  we need to compile styles\n     * inside the first call of the render function\n     */\n\n    this.hasCreatedIntialStyleSheets = false;\n    this.index = JSSManager.index -= 1;\n    this.designSystem = context;\n  }\n  /**\n   * Sets the JSS instance used by all JSSManger instances\n   */\n\n\n  static set jss(instance) {\n    JSSManager.sheetManager.jss = instance;\n  }\n  /**\n   * Get the JSS instance used by all JSSManger instances\n   */\n\n\n  static get jss() {\n    return JSSManager.sheetManager.jss;\n  }\n\n  render() {\n    if (!this.hasCreatedIntialStyleSheets) {\n      if (!!this.styles) {\n        const options = {\n          meta: this.managedComponent.displayName || this.managedComponent.name,\n          index: this.index\n        };\n\n        if (typeof JSSManager.createGenerateClassName === \"function\") {\n          options.generateClassName = JSSManager.createGenerateClassName(this.designSystem);\n        }\n\n        JSSManager.sheetManager.add(this.styles, this.designSystem, options);\n      }\n\n      if (this.props.jssStyleSheet) {\n        this.createPropStyleSheet();\n      }\n\n      this.hasCreatedIntialStyleSheets = true;\n    }\n\n    return React.createElement(this.managedComponent, this.managedComponentProps());\n  }\n\n  componentDidUpdate(prevProps) {\n    const hasSheetProps = !!this.props.jssStyleSheet;\n    const hadSheetProps = !!prevProps.jssStyleSheet;\n\n    if (this.designSystem !== this.context) {\n      if (!!this.styles) {\n        JSSManager.sheetManager.update(this.styles, this.designSystem, this.context);\n        this.forceUpdate();\n      }\n\n      if (hadSheetProps && hasSheetProps) {\n        if (prevProps.jssStyleSheet === this.props.jssStyleSheet) {\n          JSSManager.sheetManager.update(this.props.jssStyleSheet, this.designSystem, this.context);\n        } else {\n          JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);\n          this.createPropStyleSheet(this.context);\n        }\n\n        this.forceUpdate();\n      } else if (hadSheetProps && !hasSheetProps) {\n        JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);\n      } else if (!hadSheetProps && hasSheetProps) {\n        this.createPropStyleSheet(this.context);\n        this.forceUpdate();\n      }\n\n      this.designSystem = this.context;\n    } else if (hadSheetProps && hasSheetProps && prevProps.jssStyleSheet !== this.props.jssStyleSheet) {\n      JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);\n      this.createPropStyleSheet();\n      this.forceUpdate();\n    }\n\n    if (hadSheetProps && !hasSheetProps) {\n      JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);\n    } else if (!hadSheetProps && hasSheetProps) {\n      this.createPropStyleSheet();\n      this.forceUpdate();\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.styles) {\n      JSSManager.sheetManager.remove(this.styles, this.designSystem);\n    }\n\n    if (this.props.jssStyleSheet) {\n      JSSManager.sheetManager.remove(this.props.jssStyleSheet, this.designSystem);\n    }\n\n    JSSManager.index++; // reset style creation tracker in case the instance is re-used\n\n    this.hasCreatedIntialStyleSheets = false;\n  }\n  /**\n   * Return the JSSStyleSheet associated with the current designSystem and style\n   */\n\n\n  primaryStyleSheet() {\n    if (!!this.styles) {\n      return JSSManager.sheetManager.get(this.styles, this.designSystem);\n    }\n  }\n  /**\n   * Return the JSSStylesheet associated with the jssStyleSheet prop\n   */\n\n\n  secondaryStyleSheet() {\n    if (!!this.props.jssStyleSheet) {\n      return JSSManager.sheetManager.get(this.props.jssStyleSheet, this.designSystem);\n    }\n  }\n  /**\n   * Generate a prop object to give to the managed component\n   */\n\n\n  managedComponentProps() {\n    const props = Object.assign({}, this.props, {\n      managedClasses: this.getManagedClassNames(),\n      ref: this.props.innerRef\n    });\n    delete props.jssStyleSheet;\n    delete props.innerRef;\n    return props;\n  }\n  /**\n   * Returns the classes to pass down to the managed component\n   */\n\n\n  getManagedClassNames() {\n    let primaryClasses = {};\n    let secondaryClasses = {};\n    const primarySheet = this.primaryStyleSheet();\n    const secondarySheet = this.secondaryStyleSheet();\n\n    if (!!primarySheet && primarySheet.hasOwnProperty(\"classes\")) {\n      primaryClasses = Object.assign({}, primarySheet.classes);\n    }\n\n    if (!!secondarySheet && secondarySheet.hasOwnProperty(\"classes\")) {\n      secondaryClasses = Object.assign({}, secondarySheet.classes);\n    }\n\n    return mergeWith(primaryClasses, secondaryClasses, mergeClassNames);\n  }\n\n  createPropStyleSheet(designSystem = this.designSystem) {\n    const stylesheet = this.primaryStyleSheet();\n    const options = {\n      meta: `${this.managedComponent.displayName || this.managedComponent.name} - jssStyleSheet`,\n      index: stylesheet ? stylesheet.options.index + 1 : this.index + 1\n    };\n\n    if (typeof JSSManager.createGenerateClassName === \"function\") {\n      options.generateClassName = JSSManager.createGenerateClassName(designSystem);\n    }\n\n    JSSManager.sheetManager.add(this.props.jssStyleSheet, designSystem, options);\n  }\n\n}\n/**\n * Define the contextType for the manager to be the design system context\n */\n\n\nJSSManager.contextType = designSystemContext;\n/**\n * JSS allows us to use an index to order the created style elements. The higher the index,\n * the later in the document the style element will be created.\n *\n * This static index allows us to globally track every stylesheet created by the JSSManager. Each\n * instance decrements this index and assigns itself the decremented value. The effect of this is that\n * a React parent will always have a higher index than it's children because react constructs trees\n * recursively starting at the root. With a parent always having a higher index then it's children,\n * we can inform JSS of this order preference and ensure parent stylesheets always come later in the DOM.\n *\n * Inspiration for this approach to style element ordering comes from\n * https://github.com/cssinjs/react-jss/blob/master/src/injectSheet.js\n */\n\nJSSManager.index = -1000;\n/**\n * Manages stylesheets\n */\n\nJSSManager.sheetManager = new SheetManager();\nexport { JSSManager };","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-jss-manager-react/dist/jss-manager.js"],"names":["mergeWith","React","designSystemContext","SheetManager","mergeClassNames","a","b","concat","JSSManager","Component","constructor","props","context","hasCreatedIntialStyleSheets","index","designSystem","jss","instance","sheetManager","render","styles","options","meta","managedComponent","displayName","name","createGenerateClassName","generateClassName","add","jssStyleSheet","createPropStyleSheet","createElement","managedComponentProps","componentDidUpdate","prevProps","hasSheetProps","hadSheetProps","update","forceUpdate","remove","componentWillUnmount","primaryStyleSheet","get","secondaryStyleSheet","Object","assign","managedClasses","getManagedClassNames","ref","innerRef","primaryClasses","secondaryClasses","primarySheet","secondarySheet","hasOwnProperty","classes","stylesheet","contextType"],"mappings":"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","sourcesContent":["import { mergeWith } from \"lodash-es\";\nimport React from \"react\";\nimport { designSystemContext } from \"./context\";\nimport SheetManager from \"./sheet-manager\";\nexport function mergeClassNames(a, b) {\n    if (typeof a === \"string\" && typeof b === \"string\") {\n        return a.concat(\" \", b);\n    }\n    else if (typeof a === \"string\") {\n        return a;\n    }\n    else if (typeof b === \"string\") {\n        return b;\n    }\n}\nclass JSSManager extends React.Component {\n    constructor(props, context) {\n        super(props, context);\n        /**\n         * Simple switch to track the initial creation of styles.\n         * Because the \"styles\" property is abstract and abstract properties\n         * are not accessible in the constructor,  we need to compile styles\n         * inside the first call of the render function\n         */\n        this.hasCreatedIntialStyleSheets = false;\n        this.index = JSSManager.index -= 1;\n        this.designSystem = context;\n    }\n    /**\n     * Sets the JSS instance used by all JSSManger instances\n     */\n    static set jss(instance) {\n        JSSManager.sheetManager.jss = instance;\n    }\n    /**\n     * Get the JSS instance used by all JSSManger instances\n     */\n    static get jss() {\n        return JSSManager.sheetManager.jss;\n    }\n    render() {\n        if (!this.hasCreatedIntialStyleSheets) {\n            if (!!this.styles) {\n                const options = {\n                    meta: this.managedComponent.displayName || this.managedComponent.name,\n                    index: this.index,\n                };\n                if (typeof JSSManager.createGenerateClassName === \"function\") {\n                    options.generateClassName = JSSManager.createGenerateClassName(this.designSystem);\n                }\n                JSSManager.sheetManager.add(this.styles, this.designSystem, options);\n            }\n            if (this.props.jssStyleSheet) {\n                this.createPropStyleSheet();\n            }\n            this.hasCreatedIntialStyleSheets = true;\n        }\n        return React.createElement(this.managedComponent, this.managedComponentProps());\n    }\n    componentDidUpdate(prevProps) {\n        const hasSheetProps = !!this.props.jssStyleSheet;\n        const hadSheetProps = !!prevProps.jssStyleSheet;\n        if (this.designSystem !== this.context) {\n            if (!!this.styles) {\n                JSSManager.sheetManager.update(this.styles, this.designSystem, this.context);\n                this.forceUpdate();\n            }\n            if (hadSheetProps && hasSheetProps) {\n                if (prevProps.jssStyleSheet === this.props.jssStyleSheet) {\n                    JSSManager.sheetManager.update(this.props.jssStyleSheet, this.designSystem, this.context);\n                }\n                else {\n                    JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);\n                    this.createPropStyleSheet(this.context);\n                }\n                this.forceUpdate();\n            }\n            else if (hadSheetProps && !hasSheetProps) {\n                JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);\n            }\n            else if (!hadSheetProps && hasSheetProps) {\n                this.createPropStyleSheet(this.context);\n                this.forceUpdate();\n            }\n            this.designSystem = this.context;\n        }\n        else if (hadSheetProps &&\n            hasSheetProps &&\n            prevProps.jssStyleSheet !== this.props.jssStyleSheet) {\n            JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);\n            this.createPropStyleSheet();\n            this.forceUpdate();\n        }\n        if (hadSheetProps && !hasSheetProps) {\n            JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);\n        }\n        else if (!hadSheetProps && hasSheetProps) {\n            this.createPropStyleSheet();\n            this.forceUpdate();\n        }\n    }\n    componentWillUnmount() {\n        if (this.styles) {\n            JSSManager.sheetManager.remove(this.styles, this.designSystem);\n        }\n        if (this.props.jssStyleSheet) {\n            JSSManager.sheetManager.remove(this.props.jssStyleSheet, this.designSystem);\n        }\n        JSSManager.index++;\n        // reset style creation tracker in case the instance is re-used\n        this.hasCreatedIntialStyleSheets = false;\n    }\n    /**\n     * Return the JSSStyleSheet associated with the current designSystem and style\n     */\n    primaryStyleSheet() {\n        if (!!this.styles) {\n            return JSSManager.sheetManager.get(this.styles, this.designSystem);\n        }\n    }\n    /**\n     * Return the JSSStylesheet associated with the jssStyleSheet prop\n     */\n    secondaryStyleSheet() {\n        if (!!this.props.jssStyleSheet) {\n            return JSSManager.sheetManager.get(this.props.jssStyleSheet, this.designSystem);\n        }\n    }\n    /**\n     * Generate a prop object to give to the managed component\n     */\n    managedComponentProps() {\n        const props = Object.assign({}, this.props, { managedClasses: this.getManagedClassNames(), ref: this.props.innerRef });\n        delete props.jssStyleSheet;\n        delete props.innerRef;\n        return props;\n    }\n    /**\n     * Returns the classes to pass down to the managed component\n     */\n    getManagedClassNames() {\n        let primaryClasses = {};\n        let secondaryClasses = {};\n        const primarySheet = this.primaryStyleSheet();\n        const secondarySheet = this.secondaryStyleSheet();\n        if (!!primarySheet && primarySheet.hasOwnProperty(\"classes\")) {\n            primaryClasses = Object.assign({}, primarySheet.classes);\n        }\n        if (!!secondarySheet && secondarySheet.hasOwnProperty(\"classes\")) {\n            secondaryClasses = Object.assign({}, secondarySheet.classes);\n        }\n        return mergeWith(primaryClasses, secondaryClasses, mergeClassNames);\n    }\n    createPropStyleSheet(designSystem = this.designSystem) {\n        const stylesheet = this.primaryStyleSheet();\n        const options = {\n            meta: `${this.managedComponent.displayName ||\n                this.managedComponent.name} - jssStyleSheet`,\n            index: stylesheet ? stylesheet.options.index + 1 : this.index + 1,\n        };\n        if (typeof JSSManager.createGenerateClassName === \"function\") {\n            options.generateClassName = JSSManager.createGenerateClassName(designSystem);\n        }\n        JSSManager.sheetManager.add(this.props.jssStyleSheet, designSystem, options);\n    }\n}\n/**\n * Define the contextType for the manager to be the design system context\n */\nJSSManager.contextType = designSystemContext;\n/**\n * JSS allows us to use an index to order the created style elements. The higher the index,\n * the later in the document the style element will be created.\n *\n * This static index allows us to globally track every stylesheet created by the JSSManager. Each\n * instance decrements this index and assigns itself the decremented value. The effect of this is that\n * a React parent will always have a higher index than it's children because react constructs trees\n * recursively starting at the root. With a parent always having a higher index then it's children,\n * we can inform JSS of this order preference and ensure parent stylesheets always come later in the DOM.\n *\n * Inspiration for this approach to style element ordering comes from\n * https://github.com/cssinjs/react-jss/blob/master/src/injectSheet.js\n */\nJSSManager.index = -1000;\n/**\n * Manages stylesheets\n */\nJSSManager.sheetManager = new SheetManager();\nexport { JSSManager };\n"]},"metadata":{},"sourceType":"module"}