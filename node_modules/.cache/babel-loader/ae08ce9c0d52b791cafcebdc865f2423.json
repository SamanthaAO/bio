{"ast":null,"code":"import { checkDesignSystemResolver } from \"../../design-system\";\nimport { backgroundColor } from \"../../utilities/design-system\";\nimport { accentPalette, neutralPalette } from \"../design-system\";\nimport { clamp, colorMatches, contrast, isValidColor, luminance } from \"./common\";\n/**\n * The named palettes of the MSFT design system\n * @deprecated - use neutralPalette and accentPalette functions instead\n */\n\nexport var PaletteType;\n\n(function (PaletteType) {\n  PaletteType[\"neutral\"] = \"neutral\";\n  PaletteType[\"accent\"] = \"accent\";\n})(PaletteType || (PaletteType = {}));\n/**\n * Retrieves a palette by name. This function returns a function that accepts\n * a design system, returning a palette a palette or null\n * @deprecated - use neutralPalette and accentPalette functions instead\n */\n\n\nexport function palette(paletteType) {\n  return function (designSystem) {\n    switch (paletteType) {\n      case PaletteType.accent:\n        return accentPalette(designSystem);\n\n      case PaletteType.neutral:\n      default:\n        return neutralPalette(designSystem);\n    }\n  };\n}\n/**\n * A function to find the index of a swatch in a specified palette. If the color is found,\n * otherwise it will return -1\n */\n\nexport function findSwatchIndex(paletteResolver, swatch) {\n  return function (designSystem) {\n    if (!isValidColor(swatch)) {\n      return -1;\n    }\n\n    var colorPalette = checkDesignSystemResolver(paletteResolver, designSystem);\n    var index = colorPalette.indexOf(swatch); // If we don't find the string exactly, it might be because of color formatting differences\n\n    return index !== -1 ? index : colorPalette.findIndex(function (paletteSwatch) {\n      return isValidColor(paletteSwatch) && colorMatches(swatch, paletteSwatch);\n    });\n  };\n}\n/**\n * Returns the closest swatch in a palette to an input swatch.\n * If the input swatch cannot be converted to a color, 0 will be returned\n */\n\nexport function findClosestSwatchIndex(paletteResolver, swatch) {\n  return function (designSystem) {\n    var resolvedPalette = checkDesignSystemResolver(paletteResolver, designSystem);\n    var resolvedSwatch = checkDesignSystemResolver(swatch, designSystem);\n    var index = findSwatchIndex(resolvedPalette, resolvedSwatch)(designSystem);\n    var swatchLuminance;\n\n    if (index !== -1) {\n      return index;\n    }\n\n    try {\n      swatchLuminance = luminance(resolvedSwatch);\n    } catch (e) {\n      swatchLuminance = -1;\n    }\n\n    if (swatchLuminance === -1) {\n      return 0;\n    }\n\n    return resolvedPalette.map(function (mappedSwatch, mappedIndex) {\n      return {\n        luminance: luminance(mappedSwatch),\n        index: mappedIndex\n      };\n    }).reduce(function (previousValue, currentValue) {\n      return Math.abs(currentValue.luminance - swatchLuminance) < Math.abs(previousValue.luminance - swatchLuminance) ? currentValue : previousValue;\n    }).index;\n  };\n}\n/**\n * Determines if the design-system should be considered in \"dark mode\".\n * We're in dark mode if we have more contrast between #000000 and our background\n * color than #FFFFFF and our background color. That threshold can be expressed as a relative luminance\n * using the contrast formula as (1 + 0.5) / (bg + 0.05) === (bg + 0.05) / (0 + 0.05),\n * which reduces to the following, where bg is the relative luminance of the background color\n */\n\nexport function isDarkMode(designSystem) {\n  return luminance(backgroundColor(designSystem)) <= (-0.1 + Math.sqrt(0.21)) / 2;\n}\n/**\n * Determines if the design-system should be considered in \"light mode\".\n */\n\nexport function isLightMode(designSystem) {\n  return !isDarkMode(designSystem);\n}\nexport function getSwatch(index, colorPalette) {\n  if (typeof index === \"function\") {\n    return function (designSystem) {\n      return colorPalette(designSystem)[clamp(index(designSystem), 0, colorPalette(designSystem).length - 1)];\n    };\n  } else {\n    return colorPalette[clamp(index, 0, colorPalette.length - 1)];\n  }\n}\nexport function swatchByMode(paletteResolver) {\n  return function (valueA, valueB) {\n    return function (designSystem) {\n      return getSwatch(isDarkMode(designSystem) ? checkDesignSystemResolver(valueB, designSystem) : checkDesignSystemResolver(valueA, designSystem), paletteResolver(designSystem));\n    };\n  };\n} // disable type-defs because this a deeply curried function and the call-signature is pretty complicated\n// and typescript can work it out automatically for consumers\n\n/* tslint:disable:typedef */\n\n/**\n * Retrieves a swatch from an input palette, where the swatch's contrast against the reference color\n * passes an input condition. The direction to search in the palette is determined by an input condition.\n * Where to begin the search in the palette will be determined another input function that should return the starting index.\n * example: swatchByContrast(\n *              \"#FFF\" // compare swatches against \"#FFF\"\n *          )(\n *              neutralPalette // use the neutral palette from the DesignSystem - since this is a function, it will be evaluated with the DesignSystem\n *          )(\n *              () => 0 // begin searching for a swatch at the beginning of the neutral palette\n *          )(\n *              () => 1 // While searching, search in the direction toward the end of the array (-1 moves towards the beginning of the array)\n *          )(\n *              minContrastTargetFactory(4.5) // A swatch is only valid if the contrast is greater than 4.5\n *          )(\n *              designSystem // Pass the design-system. The first swatch that passes the previous condition will be returned from this function\n *          )\n */\n\nexport function swatchByContrast(referenceColor) {\n  /**\n   * A function that expects a function that resolves a palette\n   */\n  return function (paletteResolver) {\n    /**\n     * A function that expects a function that resolves the index\n     * of the palette that the algorithm should begin looking for a swatch at\n     */\n    return function (indexResolver) {\n      /**\n       * A function that expects a function that determines which direction in the\n       * palette we should look for a swatch relative to the initial index\n       */\n      return function (directionResolver) {\n        /**\n         * A function that expects a function that determines if the contrast\n         * between the reference color and color from the palette are acceptable\n         */\n        return function (contrastCondition) {\n          /**\n           * A function that accepts a design-system. It resolves all of the curried arguments\n           * and loops over the palette until we reach the bounds of the palette or the condition\n           * is satisfied. Once either the condition is satisfied or we reach the end of the palette,\n           * we return the color\n           */\n          return function (designSystem) {\n            var color = checkDesignSystemResolver(referenceColor, designSystem);\n            var sourcePalette = checkDesignSystemResolver(paletteResolver, designSystem);\n            var length = sourcePalette.length;\n            var initialSearchIndex = clamp(indexResolver(color, sourcePalette, designSystem), 0, length - 1);\n            var direction = directionResolver(initialSearchIndex, sourcePalette, designSystem);\n\n            function contrastSearchCondition(valueToCheckAgainst) {\n              return contrastCondition(contrast(color, valueToCheckAgainst));\n            }\n\n            var constrainedSourcePalette = [].concat(sourcePalette);\n            var endSearchIndex = length - 1;\n            var startSearchIndex = initialSearchIndex;\n\n            if (direction === -1) {\n              // reverse the palette array when the direction that\n              // the contrast resolves for is reversed\n              constrainedSourcePalette.reverse();\n              startSearchIndex = endSearchIndex - startSearchIndex;\n            }\n\n            return binarySearch(constrainedSourcePalette, contrastSearchCondition, startSearchIndex, endSearchIndex);\n          };\n        };\n      };\n    };\n  };\n}\n\nfunction binarySearch(valuesToSearch, searchCondition) {\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var endIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : valuesToSearch.length - 1;\n\n  if (endIndex === startIndex) {\n    return valuesToSearch[startIndex];\n  }\n\n  var middleIndex = Math.floor((endIndex - startIndex) / 2) + startIndex; // Check to see if this passes on the item in the center of the array\n  // if it does check the previous values\n\n  if (searchCondition(valuesToSearch[middleIndex])) {\n    return binarySearch(valuesToSearch, searchCondition, startIndex, middleIndex // include this index because it passed the search condition\n    );\n  } else {\n    return binarySearch(valuesToSearch, searchCondition, middleIndex + 1, // exclude this index because it failed the search condition\n    endIndex);\n  }\n}\n/**\n * Resolves the index that the contrast search algorithm should start at\n */\n\n\nexport function referenceColorInitialIndexResolver(referenceColor, sourcePalette, designSystem) {\n  return findClosestSwatchIndex(sourcePalette, referenceColor)(designSystem);\n}\n/* tslint:enable:typedef */\n\nexport function findClosestBackgroundIndex(designSystem) {\n  return findClosestSwatchIndex(neutralPalette, backgroundColor(designSystem))(designSystem);\n}\nexport function minContrastTargetFactory(targetContrast) {\n  return function (instanceContrast) {\n    return instanceContrast >= targetContrast;\n  };\n}","map":{"version":3,"sources":["/Users/samorcutt/Desktop/bio/node_modules/@microsoft/fast-components-styles-msft/dist/utilities/color/palette.js"],"names":["checkDesignSystemResolver","backgroundColor","accentPalette","neutralPalette","clamp","colorMatches","contrast","isValidColor","luminance","PaletteType","palette","paletteType","designSystem","accent","neutral","findSwatchIndex","paletteResolver","swatch","colorPalette","index","indexOf","findIndex","paletteSwatch","findClosestSwatchIndex","resolvedPalette","resolvedSwatch","swatchLuminance","e","map","mappedSwatch","mappedIndex","reduce","previousValue","currentValue","Math","abs","isDarkMode","sqrt","isLightMode","getSwatch","length","swatchByMode","valueA","valueB","swatchByContrast","referenceColor","indexResolver","directionResolver","contrastCondition","color","sourcePalette","initialSearchIndex","direction","contrastSearchCondition","valueToCheckAgainst","constrainedSourcePalette","concat","endSearchIndex","startSearchIndex","reverse","binarySearch","valuesToSearch","searchCondition","startIndex","endIndex","middleIndex","floor","referenceColorInitialIndexResolver","findClosestBackgroundIndex","minContrastTargetFactory","targetContrast","instanceContrast"],"mappings":"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","sourcesContent":["import { checkDesignSystemResolver, } from \"../../design-system\";\nimport { backgroundColor } from \"../../utilities/design-system\";\nimport { accentPalette, neutralPalette } from \"../design-system\";\nimport { clamp, colorMatches, contrast, isValidColor, luminance, } from \"./common\";\n/**\n * The named palettes of the MSFT design system\n * @deprecated - use neutralPalette and accentPalette functions instead\n */\nexport var PaletteType;\n(function (PaletteType) {\n    PaletteType[\"neutral\"] = \"neutral\";\n    PaletteType[\"accent\"] = \"accent\";\n})(PaletteType || (PaletteType = {}));\n/**\n * Retrieves a palette by name. This function returns a function that accepts\n * a design system, returning a palette a palette or null\n * @deprecated - use neutralPalette and accentPalette functions instead\n */\nexport function palette(paletteType) {\n    return (designSystem) => {\n        switch (paletteType) {\n            case PaletteType.accent:\n                return accentPalette(designSystem);\n            case PaletteType.neutral:\n            default:\n                return neutralPalette(designSystem);\n        }\n    };\n}\n/**\n * A function to find the index of a swatch in a specified palette. If the color is found,\n * otherwise it will return -1\n */\nexport function findSwatchIndex(paletteResolver, swatch) {\n    return (designSystem) => {\n        if (!isValidColor(swatch)) {\n            return -1;\n        }\n        const colorPalette = checkDesignSystemResolver(paletteResolver, designSystem);\n        const index = colorPalette.indexOf(swatch);\n        // If we don't find the string exactly, it might be because of color formatting differences\n        return index !== -1\n            ? index\n            : colorPalette.findIndex((paletteSwatch) => {\n                return (isValidColor(paletteSwatch) &&\n                    colorMatches(swatch, paletteSwatch));\n            });\n    };\n}\n/**\n * Returns the closest swatch in a palette to an input swatch.\n * If the input swatch cannot be converted to a color, 0 will be returned\n */\nexport function findClosestSwatchIndex(paletteResolver, swatch) {\n    return (designSystem) => {\n        const resolvedPalette = checkDesignSystemResolver(paletteResolver, designSystem);\n        const resolvedSwatch = checkDesignSystemResolver(swatch, designSystem);\n        const index = findSwatchIndex(resolvedPalette, resolvedSwatch)(designSystem);\n        let swatchLuminance;\n        if (index !== -1) {\n            return index;\n        }\n        try {\n            swatchLuminance = luminance(resolvedSwatch);\n        }\n        catch (e) {\n            swatchLuminance = -1;\n        }\n        if (swatchLuminance === -1) {\n            return 0;\n        }\n        return resolvedPalette\n            .map((mappedSwatch, mappedIndex) => {\n            return {\n                luminance: luminance(mappedSwatch),\n                index: mappedIndex,\n            };\n        })\n            .reduce((previousValue, currentValue) => {\n            return Math.abs(currentValue.luminance - swatchLuminance) <\n                Math.abs(previousValue.luminance - swatchLuminance)\n                ? currentValue\n                : previousValue;\n        }).index;\n    };\n}\n/**\n * Determines if the design-system should be considered in \"dark mode\".\n * We're in dark mode if we have more contrast between #000000 and our background\n * color than #FFFFFF and our background color. That threshold can be expressed as a relative luminance\n * using the contrast formula as (1 + 0.5) / (bg + 0.05) === (bg + 0.05) / (0 + 0.05),\n * which reduces to the following, where bg is the relative luminance of the background color\n */\nexport function isDarkMode(designSystem) {\n    return luminance(backgroundColor(designSystem)) <= (-0.1 + Math.sqrt(0.21)) / 2;\n}\n/**\n * Determines if the design-system should be considered in \"light mode\".\n */\nexport function isLightMode(designSystem) {\n    return !isDarkMode(designSystem);\n}\nexport function getSwatch(index, colorPalette) {\n    if (typeof index === \"function\") {\n        return (designSystem) => {\n            return colorPalette(designSystem)[clamp(index(designSystem), 0, colorPalette(designSystem).length - 1)];\n        };\n    }\n    else {\n        return colorPalette[clamp(index, 0, colorPalette.length - 1)];\n    }\n}\nexport function swatchByMode(paletteResolver) {\n    return (valueA, valueB) => {\n        return (designSystem) => {\n            return getSwatch(isDarkMode(designSystem)\n                ? checkDesignSystemResolver(valueB, designSystem)\n                : checkDesignSystemResolver(valueA, designSystem), paletteResolver(designSystem));\n        };\n    };\n}\n// disable type-defs because this a deeply curried function and the call-signature is pretty complicated\n// and typescript can work it out automatically for consumers\n/* tslint:disable:typedef */\n/**\n * Retrieves a swatch from an input palette, where the swatch's contrast against the reference color\n * passes an input condition. The direction to search in the palette is determined by an input condition.\n * Where to begin the search in the palette will be determined another input function that should return the starting index.\n * example: swatchByContrast(\n *              \"#FFF\" // compare swatches against \"#FFF\"\n *          )(\n *              neutralPalette // use the neutral palette from the DesignSystem - since this is a function, it will be evaluated with the DesignSystem\n *          )(\n *              () => 0 // begin searching for a swatch at the beginning of the neutral palette\n *          )(\n *              () => 1 // While searching, search in the direction toward the end of the array (-1 moves towards the beginning of the array)\n *          )(\n *              minContrastTargetFactory(4.5) // A swatch is only valid if the contrast is greater than 4.5\n *          )(\n *              designSystem // Pass the design-system. The first swatch that passes the previous condition will be returned from this function\n *          )\n */\nexport function swatchByContrast(referenceColor) {\n    /**\n     * A function that expects a function that resolves a palette\n     */\n    return (paletteResolver) => {\n        /**\n         * A function that expects a function that resolves the index\n         * of the palette that the algorithm should begin looking for a swatch at\n         */\n        return (indexResolver) => {\n            /**\n             * A function that expects a function that determines which direction in the\n             * palette we should look for a swatch relative to the initial index\n             */\n            return (directionResolver) => {\n                /**\n                 * A function that expects a function that determines if the contrast\n                 * between the reference color and color from the palette are acceptable\n                 */\n                return (contrastCondition) => {\n                    /**\n                     * A function that accepts a design-system. It resolves all of the curried arguments\n                     * and loops over the palette until we reach the bounds of the palette or the condition\n                     * is satisfied. Once either the condition is satisfied or we reach the end of the palette,\n                     * we return the color\n                     */\n                    return (designSystem) => {\n                        const color = checkDesignSystemResolver(referenceColor, designSystem);\n                        const sourcePalette = checkDesignSystemResolver(paletteResolver, designSystem);\n                        const length = sourcePalette.length;\n                        const initialSearchIndex = clamp(indexResolver(color, sourcePalette, designSystem), 0, length - 1);\n                        const direction = directionResolver(initialSearchIndex, sourcePalette, designSystem);\n                        function contrastSearchCondition(valueToCheckAgainst) {\n                            return contrastCondition(contrast(color, valueToCheckAgainst));\n                        }\n                        const constrainedSourcePalette = [].concat(sourcePalette);\n                        const endSearchIndex = length - 1;\n                        let startSearchIndex = initialSearchIndex;\n                        if (direction === -1) {\n                            // reverse the palette array when the direction that\n                            // the contrast resolves for is reversed\n                            constrainedSourcePalette.reverse();\n                            startSearchIndex = endSearchIndex - startSearchIndex;\n                        }\n                        return binarySearch(constrainedSourcePalette, contrastSearchCondition, startSearchIndex, endSearchIndex);\n                    };\n                };\n            };\n        };\n    };\n}\nfunction binarySearch(valuesToSearch, searchCondition, startIndex = 0, endIndex = valuesToSearch.length - 1) {\n    if (endIndex === startIndex) {\n        return valuesToSearch[startIndex];\n    }\n    const middleIndex = Math.floor((endIndex - startIndex) / 2) + startIndex;\n    // Check to see if this passes on the item in the center of the array\n    // if it does check the previous values\n    if (searchCondition(valuesToSearch[middleIndex])) {\n        return binarySearch(valuesToSearch, searchCondition, startIndex, middleIndex // include this index because it passed the search condition\n        );\n    }\n    else {\n        return binarySearch(valuesToSearch, searchCondition, middleIndex + 1, // exclude this index because it failed the search condition\n        endIndex);\n    }\n}\n/**\n * Resolves the index that the contrast search algorithm should start at\n */\nexport function referenceColorInitialIndexResolver(referenceColor, sourcePalette, designSystem) {\n    return findClosestSwatchIndex(sourcePalette, referenceColor)(designSystem);\n}\n/* tslint:enable:typedef */\nexport function findClosestBackgroundIndex(designSystem) {\n    return findClosestSwatchIndex(neutralPalette, backgroundColor(designSystem))(designSystem);\n}\nexport function minContrastTargetFactory(targetContrast) {\n    return (instanceContrast) => instanceContrast >= targetContrast;\n}\n"]},"metadata":{},"sourceType":"module"}