import React from "react";
import { throttle } from "lodash-es";
import { PaneResizeDirection, } from "./pane.props";
import { west } from "../row";
import rafThrottle from "raf-throttle";
import { applyFocusVisible, toPx } from "@microsoft/fast-jss-utilities";
import Foundation from "@microsoft/fast-components-foundation-react";
import { canUseDOM } from "exenv-es6";
import { classNames, keyCodeArrowLeft, keyCodeArrowRight, } from "@microsoft/fast-web-utilities";
export const paneStyleSheet = {
    pane: {
        position: "relative",
        flex: "0 1 auto",
        display: "flex",
        "flex-direction": "column",
    },
    pane_resizeHandle: Object.assign({ position: "absolute", padding: "0", opacity: "0", top: "0", width: toPx(8), height: "100%", "z-index": "1", transition: "transform .04s ease-in-out", outline: "none", transform: "scale(.5, 1)", "&:hover": {
            cursor: "ew-resize",
        } }, applyFocusVisible({
        opacity: "1",
        transform: "scale(1)",
    }), { "&:active": {
            opacity: "1",
            transform: "scale(1)",
        } }),
    pane__resizeWest: {
        "& $pane_resizeHandle": {
            left: "-4px",
        },
    },
    pane__resizeEast: {
        "& $pane_resizeHandle": {
            right: "-4px",
        },
    },
    pane__overlay: {
        position: "absolute",
        height: "100%",
        "z-index": "2",
    },
    pane__hidden: {
        display: "none",
    },
};
export class Pane extends Foundation {
    constructor(props) {
        super(props);
        /**
         * All handled props
         */
        this.handledProps = {
            collapsed: void 0,
            collapsedWidth: void 0,
            hidden: void 0,
            id: void 0,
            initialWidth: void 0,
            managedClasses: void 0,
            maxWidth: void 0,
            minWidth: void 0,
            onResize: void 0,
            overlay: void 0,
            resizeControl: void 0,
            resizable: void 0,
            resizeFrom: void 0,
            width: void 0,
        };
        /**
         * Handle keyPress
         */
        this.onKeyDown = (e) => {
            const isShift = e.shiftKey;
            const offset = isShift ? 10 : 1;
            let width;
            switch (e.keyCode) {
                case keyCodeArrowLeft:
                    width = this.rootElement.current.clientWidth - offset;
                    break;
                case keyCodeArrowRight:
                    width = this.rootElement.current.clientWidth + offset;
                    break;
                default:
                    break;
            }
            this.setWidth(width);
            // Fire the resize callback
            this.onResize(e, width);
        };
        /**
         * Handle mouseDown
         */
        this.onMouseDown = (e) => {
            // only listen for left click
            if (e.button !== 0) {
                return;
            }
            this.setState({
                resizing: true,
                dragReference: e.pageX,
            });
        };
        /**
         * Handle mouseUp
         */
        this.onMouseUp = (e) => {
            // only listen for left click
            if (e.button !== 0) {
                return;
            }
            this.setState({
                resizing: false,
                dragReference: null,
            });
        };
        this.onMouseMove = (e) => {
            if (!this.state.resizing) {
                return;
            }
            const offset = this.state.dragReference - e.pageX;
            const updatedWidth = this.props.resizeFrom === west
                ? this.width() + offset
                : this.width() - offset;
            if (updatedWidth <= this.props.minWidth || updatedWidth >= this.props.maxWidth) {
                return;
            }
            // Fire the resize callback
            this.onResize(e, updatedWidth);
            this.setState({
                dragReference: e.pageX,
            });
            this.setWidth(updatedWidth);
        };
        this.onWindowResize = (e) => {
            this.setWidth(this.rootElement.current.clientWidth);
        };
        this.onResize = (e, width) => {
            if (typeof this.props.onResize === "function") {
                this.props.onResize(e, width);
            }
        };
        this.state = {
            resizing: false,
            dragReference: null,
            width: this.props.initialWidth,
        };
        this.onResize = throttle(this.onResize, 16);
        this.onMouseMove = throttle(this.onMouseMove, 16);
        this.onWindowResize = rafThrottle(this.onWindowResize);
        this.rootElement = React.createRef();
    }
    /**
     * Return the width of Pane. Sources from props first, and then state if props.width is undefined
     */
    width() {
        return this.props.width || this.state.width;
    }
    /**
     * Handle when component is mounted to the DOM
     */
    componentDidMount() {
        if (canUseDOM()) {
            window.addEventListener("resize", this.onWindowResize);
        }
    }
    /**
     * Handle when component is removed from the DOM
     */
    componentWillUnmount() {
        if (canUseDOM()) {
            window.removeEventListener("resize", this.onWindowResize);
        }
    }
    /**
     * Handle when component updates
     */
    componentDidUpdate(prevProps, prevState) {
        if (canUseDOM()) {
            if (this.state.resizing && !prevState.resizing) {
                document.addEventListener("mouseup", this.onMouseUp);
                document.addEventListener("mousemove", this.onMouseMove);
            }
            else if (!this.state.resizing && prevState.resizing) {
                document.removeEventListener("mouseup", this.onMouseUp);
                document.removeEventListener("mousemove", this.onMouseMove);
            }
        }
    }
    /**
     * Gets the generated width of the grid pane depending on minWidth, maxWidth, and collapsed state.
     */
    getWidth() {
        if (this.props.collapsed) {
            return this.props.collapsedWidth;
        }
        else if (this.width() < this.props.minWidth) {
            return this.props.minWidth;
        }
        else if (this.width() > this.props.maxWidth) {
            return this.props.maxWidth;
        }
        else {
            return this.width();
        }
    }
    /**
     * generates the inline style property
     */
    generateStyleAttribute() {
        const width = toPx(this.getWidth());
        const styles = {};
        styles.minWidth = this.props.collapsed
            ? toPx(this.props.collapsedWidth)
            : this.props.resizable
                ? toPx(this.props.minWidth)
                : width;
        if (this.props.overlay) {
            styles.width = width;
        }
        else {
            styles.flexBasis = width;
        }
        return Object.assign(styles, this.props.style);
    }
    /**
     * Render the resize button
     */
    renderResizeControl() {
        if (!this.props.resizable || this.props.collapsed) {
            return null;
        }
        const resizeProps = {
            className: this.props.managedClasses.pane_resizeHandle,
            onMouseDown: this.onMouseDown,
            onKeyDown: this.onKeyDown,
            role: "separator",
        };
        if (typeof this.props.resizeControl === "function") {
            return this.props.resizeControl(resizeProps);
        }
        else {
            return React.createElement("button", Object.assign({}, resizeProps));
        }
    }
    setWidth(width) {
        this.setState({
            width,
        });
    }
    render() {
        return (React.createElement("div", Object.assign({}, this.unhandledProps(), { className: this.generateClassNames(), style: this.generateStyleAttribute(), ref: this.rootElement, id: this.props.id, "aria-hidden": this.props.hidden }),
            this.props.children,
            this.renderResizeControl()));
    }
    generateClassNames() {
        const { pane, pane__resizeEast, pane__resizeWest, pane__overlay, pane__hidden, } = this.props.managedClasses;
        const resizeFrom = this.props.resizeFrom;
        const classes = classNames(pane, [pane__resizeEast, resizeFrom === PaneResizeDirection.east], [pane__resizeWest, resizeFrom === PaneResizeDirection.west], [pane__overlay, this.props.overlay], [pane__hidden, this.props.hidden]);
        return super.generateClassNames(classes);
    }
}
Pane.displayName = "Pane";
/**
 * The default props of the Pane component
 */
Pane.defaultProps = {
    initialWidth: 300,
    collapsedWidth: 40,
    minWidth: 100,
    maxWidth: 800,
    resizable: false,
    collapsed: false,
    overlay: false,
    hidden: false,
    managedClasses: {},
};
export * from "./pane.props";
