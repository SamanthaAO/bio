import React from "react";
import BreakpointTracker from "../utilities/breakpoint-tracker";
import { identifyBreakpoint } from "../utilities/breakpoints";
import { canUseDOM } from "exenv-es6";
import Foundation from "@microsoft/fast-components-foundation-react";
import { canUseCssGrid, classNames } from "@microsoft/fast-web-utilities";
export class Column extends Foundation {
    constructor() {
        super(...arguments);
        this.handledProps = {
            managedClasses: void 0,
            span: void 0,
            position: void 0,
            row: void 0,
            order: void 0,
            gutter: void 0,
            cssGridPropertyName: void 0,
            defaultBreakpoint: void 0,
        };
        /**
         * Force the component to update
         */
        this.update = () => {
            this.forceUpdate();
        };
    }
    /**
     * Component has mounted
     */
    componentDidMount() {
        if (this.shouldTrackBreakpoints(this.props)) {
            BreakpointTracker.subscribe(this.update);
        }
    }
    /**
     * Component will be unmounted
     */
    componentWillUnmount() {
        BreakpointTracker.unsubscribe(this.update);
    }
    /**
     * Component has updated
     */
    componentDidUpdate(previousProps) {
        if (this.shouldTrackBreakpoints(this.props) &&
            !this.shouldTrackBreakpoints(previousProps)) {
            // If we should be tracking breakpoints but previously weren't, subscribe to changes
            BreakpointTracker.subscribe(this.update);
        }
        else if (!this.shouldTrackBreakpoints(this.props) &&
            this.shouldTrackBreakpoints(previousProps)) {
            // If we were tracking breakpoints but we shouldn't be now, unsubscribe from changes
            BreakpointTracker.unsubscribe(this.update);
        }
    }
    /**
     * Render the component
     */
    render() {
        return (React.createElement("div", Object.assign({}, this.unhandledProps(), { className: this.generateClassNames(), style: this.generateStyleAttribute() }), this.props.children));
    }
    /**
     * Generates the column classes
     */
    generateClassNames() {
        return super.generateClassNames(classNames(this.props.managedClasses.column));
    }
    /**
     * Gets a value from an array where the index retrieved is either the current break-point
     * or the nearest preceding break-point if no entry exists for the current break-point
     */
    getValueByBreakpoint(breakpointSet) {
        const breakpoint = canUseDOM()
            ? identifyBreakpoint(window.innerWidth)
            : this.props.defaultBreakpoint;
        return breakpointSet.slice(0, breakpoint + 1).pop();
    }
    /**
     * Generates the column-span value
     */
    generateColumnSpan() {
        if (typeof this.props.span === "number") {
            return this.props.span;
        }
        if (!Array.isArray(this.props.span)) {
            return Column.defaultProps.span;
        }
        return this.getValueByBreakpoint(this.props.span);
    }
    /**
     * Generates the position of a column
     */
    generateColumnPosition() {
        if (typeof this.props.position === "number") {
            return this.props.position;
        }
        else if (Array.isArray(this.props.position)) {
            return this.getValueByBreakpoint(this.props.position);
        }
        return null;
    }
    /**
     * Generates the row that a column should be placed in
     */
    generateRow() {
        if (typeof this.props.row === "number") {
            return this.props.row.toString();
        }
        else if (Array.isArray(this.props.row)) {
            return this.getValueByBreakpoint(this.props.row).toString();
        }
        return null;
    }
    augmentMsGrid(value) {
        if (this.props.gutter === 0 || value === null) {
            return value;
        }
        return value === 1 ? 1 : value * 2 - 1;
    }
    /**
     * Generates the style attribute of the column
     */
    generateStyleAttribute() {
        const position = this.generateColumnPosition();
        const row = this.generateRow();
        const span = this.generateColumnSpan();
        const gridColumnValue = [position, `span ${span}`]
            .filter((item) => Boolean(item))
            .join(" / ");
        const order = Array.isArray(this.props.order)
            ? this.getValueByBreakpoint(this.props.order)
            : this.props.order;
        const canUseCssGridStyle = this.props.cssGridPropertyName === "grid"
            ? true
            : this.props.cssGridPropertyName === "-ms-grid"
                ? false
                : canUseCssGrid();
        const gridStyles = canUseCssGridStyle
            ? {
                gridColumn: gridColumnValue,
                gridRowStart: row,
            }
            : {
                ["msGridColumn"]: this.augmentMsGrid(position),
                ["msGridColumnSpan"]: this.augmentMsGrid(span),
                ["msGridRow"]: row,
            };
        return Object.assign({}, gridStyles, { order: typeof order === "number" ? order : null, 
            // Fixes issue found in firefox where columns that have overflow
            // or full width content cause scroll bars
            minWidth: "0" }, this.unhandledProps().style);
    }
    /**
     * Determines if we should be tracking breakpoints based on a set of props
     */
    shouldTrackBreakpoints(props) {
        return ((Array.isArray(props.span) && props.span.length > 1) ||
            (Array.isArray(props.position) && props.position.length > 1));
    }
}
Column.displayName = "Column";
/**
 * Define default props
 */
Column.defaultProps = {
    managedClasses: {},
    span: 12,
    defaultBreakpoint: 0,
};
