import React from "react";
import BreakpointTracker from "../utilities/breakpoint-tracker";
import { getValueByBreakpoint } from "../utilities/breakpoints";
import { GridAlignment, GridTag, } from "./grid.props";
import Foundation from "@microsoft/fast-components-foundation-react";
import { Column } from "../column";
import { canUseCssGrid, classNames } from "@microsoft/fast-web-utilities";
import { toPx } from "@microsoft/fast-jss-utilities";
export class Grid extends Foundation {
    constructor() {
        super(...arguments);
        this.handledProps = {
            columnCount: void 0,
            gridColumn: void 0,
            gutter: void 0,
            horizontalAlign: void 0,
            managedClasses: void 0,
            tag: void 0,
            verticalAlign: void 0,
            cssGridPropertyName: void 0,
        };
        /**
         * Force the component to update
         */
        this.update = () => {
            this.forceUpdate();
        };
    }
    /**
     * Stores HTML tag for use in render
     */
    get tag() {
        return this.generateHTMLTag();
    }
    /**
     * Renders the Grid markup
     */
    render() {
        return (React.createElement(this.tag, Object.assign({}, this.unhandledProps(), { className: this.generateClassNames(), style: this.generateStyleAttributes() }), this.renderChildren()));
    }
    /**
     * Component has mounted
     */
    componentDidMount() {
        if (this.shouldTrackBreakpoints(this.props)) {
            BreakpointTracker.subscribe(this.update);
        }
    }
    /**
     * Component will be unmounted
     */
    componentWillUnmount() {
        BreakpointTracker.unsubscribe(this.update);
    }
    /**
     * Component has updated
     */
    componentDidUpdate(previousProps) {
        if (this.shouldTrackBreakpoints(this.props) &&
            !this.shouldTrackBreakpoints(previousProps)) {
            // If we should be tracking breakpoints but previously weren't, subscribe to changes
            BreakpointTracker.subscribe(this.update);
        }
        else if (!this.shouldTrackBreakpoints(this.props) &&
            this.shouldTrackBreakpoints(previousProps)) {
            // If we were tracking breakpoints but we shouldn't be now, unsubscribe from changes
            BreakpointTracker.unsubscribe(this.update);
        }
    }
    generateClassNames() {
        return super.generateClassNames(classNames(this.props.managedClasses.grid));
    }
    /**
     * Determines if we should be tracking breakpoints based on a set of props
     */
    shouldTrackBreakpoints(props) {
        return Array.isArray(props.gutter) && props.gutter.length > 1;
    }
    /**
     * Generates the column-span value
     */
    generateGutter() {
        if (typeof this.props.gutter === "number") {
            return this.props.gutter;
        }
        else if (Array.isArray(this.props.gutter)) {
            return getValueByBreakpoint(this.props.gutter);
        }
        return null;
    }
    generateAlignment(alignment) {
        return GridAlignment[alignment];
    }
    generateStyleAttributes() {
        const displayStyle = this.props.cssGridPropertyName || Grid.display;
        return Object.assign({ display: displayStyle }, (displayStyle === "grid" ? this.cssGridStyles() : this.msGridStyles()), this.unhandledProps().style);
    }
    cssGridStyles() {
        return {
            alignItems: this.generateAlignment(this.props.verticalAlign),
            gridAutoRows: "auto",
            gridColumn: this.props.gridColumn,
            gridColumnGap: `${this.generateGutter()}px`,
            gridRow: this.props.row,
            gridTemplateColumns: `repeat(${this.props.columnCount}, 1fr)`,
            justifyItems: this.generateAlignment(this.props.horizontalAlign),
        };
    }
    msGridStyles() {
        return {
            msGridColumns: `1fr (${toPx(this.generateGutter())} 1fr)[${this.props
                .columnCount - 1}]`,
            ["msGridRow"]: this.props.row,
            ["msGridColumn"]: this.props.gridColumn,
        };
    }
    /**
     * Creates tags for rendering based on href
     */
    generateHTMLTag() {
        return GridTag[this.props.tag] || GridTag.div;
    }
    renderChildren() {
        // We only need to communicate gutters size to ms-grid columns because
        // css grid gives us a css property to set for gutter. If we support
        // css grid, we can safely return children w/o gutter augmentation.
        if (canUseCssGrid()) {
            return this.props.children;
        }
        return React.Children.map(this.props.children, (child) => {
            if (!child ||
                child.type !== Column ||
                child.props.gutter) {
                return child;
            }
            return React.cloneElement(child, { gutter: this.props.gutter }, child.props.children);
        });
    }
}
Grid.displayName = "Grid";
Grid.defaultProps = {
    tag: GridTag.div,
    gridColumn: 2,
    gutter: 8,
    verticalAlign: GridAlignment.stretch,
    horizontalAlign: GridAlignment.stretch,
    columnCount: 12,
    managedClasses: {},
};
Grid.display = canUseCssGrid() ? "grid" : "-ms-grid";
export * from "./grid.props";
