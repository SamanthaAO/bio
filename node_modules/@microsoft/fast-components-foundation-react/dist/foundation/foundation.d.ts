import React from "react";
import { FoundationProps } from "./foundation.props";
/**
 * Describes the object that stores memoized reference resolver functions
 */
export interface ReferenceResolverStore {
    [key: string]: ReferenceResolverStore | ReferenceResolver;
}
/**
 * Describes the object that stores all resolved react element and component references
 */
export interface ReferenceStore {
    [key: string]: ReferenceStore | React.ReactNode;
}
/**
 * Describes the object that enumerates all handled props for a component. This
 * object includes all props that are in some way consumed or manipulated by component
 * code. These props will not be mapped onto the underlying root DOM node
 */
export declare type HandledProps<T> = {
    [P in keyof T]: void;
};
/**
 * Describes a function that that resolves a react reference element or component.
 */
export declare type ReferenceResolver = <T>(reference: T) => void;
/**
 * The foundation component is the component that all fast base components are built on top of. It provides a common
 * set of utilities that each component inherits.
 * @param H - These are the props that are "handled". "handled" props are not mapped automatically to the root element
 * returned by the render function. Use handled props to expose inputs that will not map directly to DOM attributes
 * (eg a custom callback) or where the DOM attribute would be required.
 * @param U - These are "unhandled" props. Any props from this interface will be mapped onto the root DOM node of the
 * render function as-is. It is advised that these props map to valid HTML attributes - otherwise you will likely have HTML errors.
 * @param S - The state interface of the component.
 */
declare abstract class Foundation<H, U, S> extends React.Component<H & U & FoundationProps, S> {
    /**
     * The props that should never be passed to the root element by unhandled props
     */
    private static defaultHandledProps;
    /**
     * An enumeration of all handled props. All props passed to the component that are not enumerated here will be
     * treated as unhandled props
     */
    protected handledProps: HandledProps<H>;
    /**
     * Store all memoized ref callbacks so they can quickly be accessed. Storing the functions
     * allows us to not create new ref functions every update cycle
     */
    protected referenceResolverStore: ReferenceResolverStore;
    /**
     * Location where all react element and component references are stored
     */
    protected referenceStore: ReferenceStore;
    /**
     * Stores a react ref callback under the path provided as arguments. Paths are resolved using lodash's get/set API.
     * The reference object itself will be stored on the referenceStore under the path provided and can be accessed via
     * the getRef method under the same path.
     *
     * Usage: <div ref={this.setRef("content-container")} />
     */
    protected setRef(...args: Array<string | number>): ReferenceResolver;
    /**
     * Get a reference by key , where function arguments are used as to create the keyname,
     * eg. getRef('foo', 'bar', 0) resolves to this.references.foo.bar[0];
     *
     * Usage: const contentContainer = this.getRef("content-container");
     */
    protected getRef(...args: Array<string | number>): React.ReactNode;
    /**
     * Returns an object containing all props that are not enumerated as handledProps
     */
    protected unhandledProps(): U;
    /**
     * Joins any string with the className prop passed to the component. Used for applying a className to the root
     * element of a component's render function.
     */
    protected generateClassNames(componentClasses?: string): string | null;
    protected withSlot<T>(slot: T | T[], nodes?: React.ReactNode): React.ReactNode;
    protected withoutSlot<T>(slot: T | T[], nodes?: React.ReactNode): React.ReactNode;
    /**
     * Determine if a single node has a slot property
     */
    private hasSlot;
    /**
     * Generates a string that conforms to object/array accessor syntax that can be used by lodash's get / set,
     * eg. => ["foo", "bar", 0] => "foo[bar][0]"
     */
    private processStorageKey;
}
export default Foundation;
export { FoundationProps };
