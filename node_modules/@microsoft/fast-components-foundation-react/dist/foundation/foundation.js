import React from "react";
import { get, isPlainObject, pick, set } from "lodash-es";
/**
 * The foundation component is the component that all fast base components are built on top of. It provides a common
 * set of utilities that each component inherits.
 * @param H - These are the props that are "handled". "handled" props are not mapped automatically to the root element
 * returned by the render function. Use handled props to expose inputs that will not map directly to DOM attributes
 * (eg a custom callback) or where the DOM attribute would be required.
 * @param U - These are "unhandled" props. Any props from this interface will be mapped onto the root DOM node of the
 * render function as-is. It is advised that these props map to valid HTML attributes - otherwise you will likely have HTML errors.
 * @param S - The state interface of the component.
 */
class Foundation extends React.Component {
    constructor() {
        super(...arguments);
        /**
         * Store all memoized ref callbacks so they can quickly be accessed. Storing the functions
         * allows us to not create new ref functions every update cycle
         */
        this.referenceResolverStore = {};
        /**
         * Location where all react element and component references are stored
         */
        this.referenceStore = {};
    }
    /**
     * Stores a react ref callback under the path provided as arguments. Paths are resolved using lodash's get/set API.
     * The reference object itself will be stored on the referenceStore under the path provided and can be accessed via
     * the getRef method under the same path.
     *
     * Usage: <div ref={this.setRef("content-container")} />
     */
    setRef(...args) {
        const storageKey = this.processStorageKey(args);
        let resolverFunction = get(this.referenceResolverStore, storageKey);
        if (!storageKey ||
            isPlainObject(resolverFunction) ||
            Array.isArray(resolverFunction)) {
            return;
        }
        if (typeof resolverFunction === "function") {
            return resolverFunction;
        }
        else {
            resolverFunction = (ref) => {
                set(this.referenceStore, storageKey, ref);
            };
            set(this.referenceResolverStore, storageKey, resolverFunction);
            return resolverFunction;
        }
    }
    /**
     * Get a reference by key , where function arguments are used as to create the keyname,
     * eg. getRef('foo', 'bar', 0) resolves to this.references.foo.bar[0];
     *
     * Usage: const contentContainer = this.getRef("content-container");
     */
    getRef(...args) {
        return get(this.referenceStore, this.processStorageKey(args));
    }
    /**
     * Returns an object containing all props that are not enumerated as handledProps
     */
    unhandledProps() {
        const unhandledPropKeys = Object.keys(this.props).filter((key) => {
            return (!(Foundation.defaultHandledProps.indexOf(key) > -1) &&
                (this.handledProps && !this.handledProps.hasOwnProperty(key)));
        });
        return pick(this.props, unhandledPropKeys);
    }
    /**
     * Joins any string with the className prop passed to the component. Used for applying a className to the root
     * element of a component's render function.
     */
    generateClassNames(componentClasses = "") {
        return (componentClasses
            .concat(` ${this.props.className || ""}`)
            .trim()
            .replace(/(\s){2,}/g, " ") || null);
    }
    /*
     * Return an array of all nodes who's slot prop matches the provided slot.
     * If no nodes are provided, `this.props.children` will be used
     */
    withSlot(slot, nodes = this.props.children) {
        return React.Children.map(nodes, (node) => {
            return this.hasSlot(slot, node) ? node : null;
        });
    }
    withoutSlot(slot, nodes = this.props.children) {
        return React.Children.map(nodes, (node) => {
            return !this.hasSlot(slot, node) ? node : null;
        });
    }
    /**
     * Determine if a single node has a slot property
     */
    hasSlot(slot, node) {
        const nodeSlot = get(node, "props.slot");
        return Array.isArray(slot) ? slot.indexOf(nodeSlot) !== -1 : slot === nodeSlot;
    }
    /**
     * Generates a string that conforms to object/array accessor syntax that can be used by lodash's get / set,
     * eg. => ["foo", "bar", 0] => "foo[bar][0]"
     */
    processStorageKey(args) {
        return args
            .filter((item) => {
            return typeof item === "string" || typeof item === "number";
        })
            .map((item, index) => {
            return index === 0 ? item : `[${item}]`;
        })
            .join("");
    }
}
/**
 * The props that should never be passed to the root element by unhandled props
 */
Foundation.defaultHandledProps = ["children"];
export default Foundation;
