import { mergeWith } from "lodash-es";
import React from "react";
import { designSystemContext } from "./context";
import SheetManager from "./sheet-manager";
export function mergeClassNames(a, b) {
    if (typeof a === "string" && typeof b === "string") {
        return a.concat(" ", b);
    }
    else if (typeof a === "string") {
        return a;
    }
    else if (typeof b === "string") {
        return b;
    }
}
class JSSManager extends React.Component {
    constructor(props, context) {
        super(props, context);
        /**
         * Simple switch to track the initial creation of styles.
         * Because the "styles" property is abstract and abstract properties
         * are not accessible in the constructor,  we need to compile styles
         * inside the first call of the render function
         */
        this.hasCreatedIntialStyleSheets = false;
        this.index = JSSManager.index -= 1;
        this.designSystem = context;
    }
    /**
     * Sets the JSS instance used by all JSSManger instances
     */
    static set jss(instance) {
        JSSManager.sheetManager.jss = instance;
    }
    /**
     * Get the JSS instance used by all JSSManger instances
     */
    static get jss() {
        return JSSManager.sheetManager.jss;
    }
    render() {
        if (!this.hasCreatedIntialStyleSheets) {
            if (!!this.styles) {
                const options = {
                    meta: this.managedComponent.displayName || this.managedComponent.name,
                    index: this.index,
                };
                if (typeof JSSManager.createGenerateClassName === "function") {
                    options.generateClassName = JSSManager.createGenerateClassName(this.designSystem);
                }
                JSSManager.sheetManager.add(this.styles, this.designSystem, options);
            }
            if (this.props.jssStyleSheet) {
                this.createPropStyleSheet();
            }
            this.hasCreatedIntialStyleSheets = true;
        }
        return React.createElement(this.managedComponent, this.managedComponentProps());
    }
    componentDidUpdate(prevProps) {
        const hasSheetProps = !!this.props.jssStyleSheet;
        const hadSheetProps = !!prevProps.jssStyleSheet;
        if (this.designSystem !== this.context) {
            if (!!this.styles) {
                JSSManager.sheetManager.update(this.styles, this.designSystem, this.context);
                this.forceUpdate();
            }
            if (hadSheetProps && hasSheetProps) {
                if (prevProps.jssStyleSheet === this.props.jssStyleSheet) {
                    JSSManager.sheetManager.update(this.props.jssStyleSheet, this.designSystem, this.context);
                }
                else {
                    JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);
                    this.createPropStyleSheet(this.context);
                }
                this.forceUpdate();
            }
            else if (hadSheetProps && !hasSheetProps) {
                JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);
            }
            else if (!hadSheetProps && hasSheetProps) {
                this.createPropStyleSheet(this.context);
                this.forceUpdate();
            }
            this.designSystem = this.context;
        }
        else if (hadSheetProps &&
            hasSheetProps &&
            prevProps.jssStyleSheet !== this.props.jssStyleSheet) {
            JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);
            this.createPropStyleSheet();
            this.forceUpdate();
        }
        if (hadSheetProps && !hasSheetProps) {
            JSSManager.sheetManager.remove(prevProps.jssStyleSheet, this.designSystem);
        }
        else if (!hadSheetProps && hasSheetProps) {
            this.createPropStyleSheet();
            this.forceUpdate();
        }
    }
    componentWillUnmount() {
        if (this.styles) {
            JSSManager.sheetManager.remove(this.styles, this.designSystem);
        }
        if (this.props.jssStyleSheet) {
            JSSManager.sheetManager.remove(this.props.jssStyleSheet, this.designSystem);
        }
        JSSManager.index++;
        // reset style creation tracker in case the instance is re-used
        this.hasCreatedIntialStyleSheets = false;
    }
    /**
     * Return the JSSStyleSheet associated with the current designSystem and style
     */
    primaryStyleSheet() {
        if (!!this.styles) {
            return JSSManager.sheetManager.get(this.styles, this.designSystem);
        }
    }
    /**
     * Return the JSSStylesheet associated with the jssStyleSheet prop
     */
    secondaryStyleSheet() {
        if (!!this.props.jssStyleSheet) {
            return JSSManager.sheetManager.get(this.props.jssStyleSheet, this.designSystem);
        }
    }
    /**
     * Generate a prop object to give to the managed component
     */
    managedComponentProps() {
        const props = Object.assign({}, this.props, { managedClasses: this.getManagedClassNames(), ref: this.props.innerRef });
        delete props.jssStyleSheet;
        delete props.innerRef;
        return props;
    }
    /**
     * Returns the classes to pass down to the managed component
     */
    getManagedClassNames() {
        let primaryClasses = {};
        let secondaryClasses = {};
        const primarySheet = this.primaryStyleSheet();
        const secondarySheet = this.secondaryStyleSheet();
        if (!!primarySheet && primarySheet.hasOwnProperty("classes")) {
            primaryClasses = Object.assign({}, primarySheet.classes);
        }
        if (!!secondarySheet && secondarySheet.hasOwnProperty("classes")) {
            secondaryClasses = Object.assign({}, secondarySheet.classes);
        }
        return mergeWith(primaryClasses, secondaryClasses, mergeClassNames);
    }
    createPropStyleSheet(designSystem = this.designSystem) {
        const stylesheet = this.primaryStyleSheet();
        const options = {
            meta: `${this.managedComponent.displayName ||
                this.managedComponent.name} - jssStyleSheet`,
            index: stylesheet ? stylesheet.options.index + 1 : this.index + 1,
        };
        if (typeof JSSManager.createGenerateClassName === "function") {
            options.generateClassName = JSSManager.createGenerateClassName(designSystem);
        }
        JSSManager.sheetManager.add(this.props.jssStyleSheet, designSystem, options);
    }
}
/**
 * Define the contextType for the manager to be the design system context
 */
JSSManager.contextType = designSystemContext;
/**
 * JSS allows us to use an index to order the created style elements. The higher the index,
 * the later in the document the style element will be created.
 *
 * This static index allows us to globally track every stylesheet created by the JSSManager. Each
 * instance decrements this index and assigns itself the decremented value. The effect of this is that
 * a React parent will always have a higher index than it's children because react constructs trees
 * recursively starting at the root. With a parent always having a higher index then it's children,
 * we can inform JSS of this order preference and ensure parent stylesheets always come later in the DOM.
 *
 * Inspiration for this approach to style element ordering comes from
 * https://github.com/cssinjs/react-jss/blob/master/src/injectSheet.js
 */
JSSManager.index = -1000;
/**
 * Manages stylesheets
 */
JSSManager.sheetManager = new SheetManager();
export { JSSManager };
