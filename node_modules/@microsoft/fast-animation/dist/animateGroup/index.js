"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var invokeFunctionForEach_1 = require("../utilities/invokeFunctionForEach");
var AnimateGroup = /** @class */ (function () {
    function AnimateGroup(animations) {
        var _this = this;
        /**
         * Pauses all animations in the group
         */
        this.pause = function () {
            invokeFunctionForEach_1.invokeFunctionForEach(_this.animations, "pause");
        };
        /**
         * Finishes all animations in the group
         */
        this.finish = function () {
            invokeFunctionForEach_1.invokeFunctionForEach(_this.animations, "finish");
        };
        /**
         * Cancels all animations in the group
         */
        this.cancel = function () {
            invokeFunctionForEach_1.invokeFunctionForEach(_this.animations, "cancel");
        };
        this.animations = animations;
    }
    Object.defineProperty(AnimateGroup.prototype, "onFinish", {
        /**
         * Expose onFinish callback
         */
        set: function (callback) {
            var _this = this;
            this._onFinish = callback;
            var longestRunning = this.getLongestAnimation();
            if (typeof longestRunning.onFinish === "function") {
                var fn_1 = longestRunning.onFinish;
                longestRunning.onFinish = function () {
                    fn_1();
                    _this._onFinish();
                };
            }
            else {
                longestRunning.onFinish = this._onFinish;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Play the group of animations
     */
    AnimateGroup.prototype.play = function () {
        invokeFunctionForEach_1.invokeFunctionForEach(this.animations, "play");
    };
    /**
     * Reverses all animations in the group
     */
    AnimateGroup.prototype.reverse = function () {
        invokeFunctionForEach_1.invokeFunctionForEach(this.animations, "reverse");
    };
    /**
     * Returns the longest running animation in the group
     */
    AnimateGroup.prototype.getLongestAnimation = function () {
        var _this = this;
        return this.animations.reduce(function (previousValue, currentValue) {
            var previousDuration = _this.getAnimationDuration(previousValue.effectTiming);
            var currentDuration = _this.getAnimationDuration(currentValue.effectTiming);
            // If two durations in the group are equal, consider the higher index the
            // longest animation - this helps ensure the group onFinish callback
            // is fired after all individual animation onFinish callbacks have fired.
            return currentDuration >= previousDuration ? currentValue : previousValue;
        });
    };
    /**
     * Returns the cumulative time it will take to complete an animation
     */
    AnimateGroup.prototype.getAnimationDuration = function (effectTiming) {
        var duration = effectTiming.duration;
        var sanitizedDuration = typeof duration === "string" ? parseFloat(duration) : duration;
        return (effectTiming.delay || 0) + (sanitizedDuration || 0);
    };
    return AnimateGroup;
}());
exports.default = AnimateGroup;
