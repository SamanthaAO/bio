"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isElementInView_1 = require("../utilities/isElementInView");
var lodash_es_1 = require("lodash-es");
var scrollY_1 = require("../utilities/scrollY");
/**
 * Scroll trigger base-class that handles event binding and element/callback registration.
 */
var ScrollTrigger = /** @class */ (function () {
    function ScrollTrigger() {
        var _this = this;
        this.subscriptions = [];
        this.scrollDistance = 0;
        this.openRequestAnimationFrame = false;
        this.useRequestAnimationFrame = false;
        /**
         * Request's an animation frame if there are currently no open animation frame requests
         */
        this.requestFrame = function () {
            if (_this.openRequestAnimationFrame) {
                return;
            }
            _this.openRequestAnimationFrame = true;
            window.requestAnimationFrame(_this.update);
        };
        this.useRequestAnimationFrame = window.hasOwnProperty("requestAnimationFrame");
        this.lastScrollY = scrollY_1.default();
        // We need to use .bind instead of lambda (fat-arrow) syntax here because
        // protected methods declared as lambda functions cannot be invoked by
        // extending classes via the `super` object
        this.update = this.update.bind(this);
    }
    /**
     * Subscribe an element and callback for scroll triggers
     */
    ScrollTrigger.prototype.subscribe = function (element, callback) {
        if (!(element instanceof HTMLElement) ||
            typeof callback !== "function" ||
            this.isSubscribed(element, callback)) {
            return;
        }
        if (this.subscriptions.length === 0) {
            if (this.useRequestAnimationFrame) {
                window.addEventListener("scroll", this.requestFrame);
            }
            else {
                // If we can't use window.requestAnimationFrame, just throttle the update method
                this.update = lodash_es_1.throttle(this.update, 1000 / 60); // 60fps
                window.addEventListener("scroll", this.update);
            }
        }
        this.subscriptions.push({
            element: element,
            callback: callback,
            inView: isElementInView_1.default(element),
        });
    };
    /**
     * Unsubscribe an element and callback for scroll triggers
     */
    ScrollTrigger.prototype.unsubscribe = function (element, callback) {
        this.subscriptions = this.subscriptions.filter(function (subscription) {
            return !(element === subscription.element && callback === subscription.callback);
        });
        if (this.subscriptions.length === 0) {
            window.removeEventListener("scroll", this.useRequestAnimationFrame ? this.requestFrame : this.update);
        }
    };
    /**
     * Make any arbitrary updates to UI
     */
    ScrollTrigger.prototype.update = function () {
        var yOffset = scrollY_1.default();
        this.openRequestAnimationFrame = false;
        this.scrollDistance = yOffset - this.lastScrollY;
        this.lastScrollY = yOffset;
    };
    /**
     * Checks to see if element/callback pairs have been registered so we don't duplicate registration.
     */
    ScrollTrigger.prototype.isSubscribed = function (element, callback) {
        return !!this.subscriptions.filter(function (subscription) {
            return (element === subscription.element && callback === subscription.callback);
        }).length;
    };
    return ScrollTrigger;
}());
exports.default = ScrollTrigger;
