"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Animation mode describes if an animation should animate toward an elements natural position or away from it
 */
var AnimationMode;
(function (AnimationMode) {
    AnimationMode[AnimationMode["animateTo"] = 0] = "animateTo";
    AnimationMode[AnimationMode["animateFrom"] = 1] = "animateFrom";
})(AnimationMode = exports.AnimationMode || (exports.AnimationMode = {}));
var Animate = /** @class */ (function () {
    function Animate(element, options, effectTiming) {
        var _this = this;
        /**
         * Stores animation timing functions
         */
        this.effectTiming = {
            fill: "forwards",
            iterations: 1,
            duration: 500,
        };
        /**
         * Stores animation keyframe sets and is accessed by a getter
         */
        this._keyframes = [];
        /**
         * plays the animation
         */
        this.play = function () {
            _this.ensureAnimationObjectExists();
            _this.animation.play();
        };
        /**
         * pauses the animation
         */
        this.pause = function () {
            _this.ensureAnimationObjectExists();
            _this.animation.pause();
        };
        /**
         * finishes the animation
         */
        this.finish = function () {
            _this.ensureAnimationObjectExists();
            _this.animation.finish();
        };
        /**
         * cancels the animation
         */
        this.cancel = function () {
            _this.ensureAnimationObjectExists();
            _this.animation.cancel();
        };
        /**
         * reverses an animation
         */
        this.reverse = function () {
            _this.ensureAnimationObjectExists();
            _this.animation.reverse();
        };
        /**
         * adds a set of keyframes to set of animation keyframes the animation should execute
         */
        this.addKeyframes = function (keyframes) {
            _this._keyframes.push(keyframes);
        };
        this.animationTarget = element;
        if (Boolean(effectTiming)) {
            this.effectTiming = Object.assign({}, this.effectTiming, effectTiming);
        }
        if (options) {
            if (options.transformOrigin) {
                element.style.transformOrigin = options.transformOrigin;
            }
            if (options.transformStyle) {
                element.style.transformStyle = options.transformStyle;
            }
        }
        this.options = options || {};
    }
    Object.defineProperty(Animate.prototype, "onFinish", {
        get: function () {
            return this._onFinish;
        },
        set: function (callback) {
            this._onFinish = callback;
            if (Boolean(this.animation)) {
                this.animation.onfinish = callback;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Ensure animation object
     */
    Animate.prototype.ensureAnimationObjectExists = function () {
        if (typeof this.animation === "undefined") {
            this.createAnimationObject();
        }
    };
    /**
     * Creates the animation object
     */
    Animate.prototype.createAnimationObject = function () {
        this.animation = new Animation(this.keyframeEffect, document.timeline);
        if (typeof this.onFinish !== "undefined") {
            this.animation.onfinish = this.onFinish;
        }
        if (typeof this.onCancel !== "undefined") {
            this.animation.oncancel = this.onCancel;
        }
    };
    /**
     * Returns a list of properties that will be animated based options
     */
    Animate.prototype.getPropertiesToAnimate = function () {
        var _this = this;
        return Object.keys(Animate.propertyMap).filter(function (property) {
            // Filter out all properties that don't need to be set based on our options
            return Animate.propertyMap[property].reduce(function (hasProperty, animationProp) {
                return (typeof _this.options[animationProp] !== "undefined" || hasProperty);
            }, false);
        });
    };
    /**
     * Current implmentations of web animations seem to have trouble animating both scale and opacity
     * from a starting value of 0. This method detects when those values are 0 and alters them slightly
     * to known-working starting values
     */
    Animate.prototype.normalizeInitialValue = function (property, value) {
        if (value === undefined) {
            return;
        }
        var coercedReturn = "0.01";
        switch (property) {
            case "transform":
                var matrixValuesRegex = /matrix\((.+)\)/;
                var matrixValues = value.match(matrixValuesRegex);
                if (Array.isArray(matrixValues)) {
                    var normalizedValues = matrixValues[1]
                        .split(",")
                        .map(function (matchedValue, index) {
                        var parsedValueIsZero = parseFloat(value) === 0;
                        if (!parsedValueIsZero) {
                            return matchedValue;
                        }
                        // If this is the scaleX index or the scaleY index, return the coerced value
                        return index === 0 || index === 3
                            ? coercedReturn
                            : matchedValue;
                    });
                    return "matrix(" + normalizedValues.join(",") + ")";
                }
                break;
            case "opacity":
                return parseFloat(value) === 0 ? coercedReturn : value;
        }
        return value;
    };
    /**
     * Returns the initial values for all properties being animated
     */
    Animate.prototype.getInitialKeyframeValues = function () {
        var _this = this;
        if (!(this.animationTarget instanceof HTMLElement) ||
            typeof window === "undefined") {
            return {};
        }
        var animatedProperties = this.getPropertiesToAnimate();
        var computedStyle = window.getComputedStyle(this.animationTarget);
        var initialKeyframeValues = {};
        animatedProperties.forEach(function (property) {
            initialKeyframeValues[property] = _this.normalizeInitialValue(property, computedStyle[property]);
        });
        return initialKeyframeValues;
    };
    /**
     * Formats a config option into a transform function
     */
    Animate.prototype.formatTransformFunction = function (functionType, value) {
        // If `functionType` can't be converted into a transform function, just return empty string
        if (Animate.propertyMap.transform.indexOf(functionType) === -1) {
            return "";
        }
        switch (functionType) {
            case "x":
            case "y":
                functionType = "translate" + functionType.toUpperCase();
                value =
                    typeof value === "number" ? (value = this.pixelify(value)) : value;
                break;
            case "rotate":
                value = value.toString() + "deg";
                break;
            case "scale":
                if (value === 0) {
                    // There is a strange bug where you can't animate from a scale 0
                    value = 0.01;
                }
        }
        if (typeof value !== "string") {
            value = value.toString();
        }
        return functionType + "(" + value + ")";
    };
    /**
     * Converts a number to a pixel string
     */
    Animate.prototype.pixelify = function (num) {
        return num + "px";
    };
    /**
     * Returns keyframe values based on option configuration
     */
    Animate.prototype.getOptionKeyframeValues = function () {
        var _this = this;
        var animateProperties = this.getPropertiesToAnimate();
        var keyframeValues = {};
        animateProperties.forEach(function (property) {
            keyframeValues[property] = Animate.propertyMap[property]
                .map(function (option) {
                var value = _this.options[option];
                if (typeof value === "undefined") {
                    return null;
                }
                switch (option) {
                    case "opacity":
                        return value.toString();
                    case "top":
                    case "right":
                    case "bottom":
                    case "left":
                        return typeof value === "number"
                            ? _this.pixelify(value)
                            : value;
                    default:
                        return _this.formatTransformFunction(option, value);
                }
            })
                .filter(function (option) { return Boolean(option); })
                .join(" ");
        });
        return keyframeValues;
    };
    /**
     * Gets all keyframes configured by options
     */
    Animate.prototype.getOptionKeyframes = function () {
        var keyframes = [
            this.getInitialKeyframeValues(),
            this.getOptionKeyframeValues(),
        ];
        return this.mode === AnimationMode.animateFrom ? keyframes.reverse() : keyframes;
    };
    /**
     * Sorts an array of offset keys in ascending order
     */
    Animate.prototype.sortOffsets = function (offsets) {
        return offsets.sort(function (a, b) {
            var A = parseFloat(a);
            var B = parseFloat(b);
            if (A < B) {
                return -1;
            }
            else if (A > B) {
                return 1;
            }
            else {
                return 0;
            }
        });
    };
    /**
     * Consolidates all keyframe arrays into a single keyframe array
     */
    Animate.prototype.consolidateKeyframes = function (keyframeSets) {
        var frames = [];
        // Merge all keyframes into a single frames object where each key is a keyframe offset
        keyframeSets.forEach(function (keyframeSet) {
            keyframeSet.forEach(function (keyframe, index) {
                var offset = keyframe.offset;
                if (typeof offset === "undefined") {
                    offset = index === 0 ? 0 : 1;
                    keyframe.offset = offset;
                }
                var offsetKey = offset.toString();
                frames[offsetKey] =
                    typeof frames[offsetKey] === "undefined"
                        ? keyframe
                        : Object.assign(frames[offsetKey], keyframe);
            });
        });
        return this.sortOffsets(Object.keys(frames)).map(function (offset) {
            return frames[offset];
        });
    };
    Object.defineProperty(Animate.prototype, "keyframes", {
        /**
         * Returns the animation's keyframes
         */
        get: function () {
            var optionKeyframes = this.getOptionKeyframes();
            return this.consolidateKeyframes(this._keyframes.concat([this.getOptionKeyframes()]));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Animate.prototype, "keyframeEffect", {
        /**
         * Returns the key frame effect object
         */
        get: function () {
            return new KeyframeEffect(this.animationTarget, this.keyframes, this.effectTiming);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * A mapping between animation options and the css property names they apply to
     */
    Animate.propertyMap = {
        opacity: ["opacity"],
        transform: ["x", "y", "rotate", "scale"],
        top: ["top"],
        left: ["left"],
        bottom: ["bottom"],
        right: ["right"],
    };
    return Animate;
}());
exports.default = Animate;
