import Foundation from "@microsoft/fast-components-foundation-react";
import { textFieldOverrides } from "@microsoft/fast-components-styles-msft";
import { classNames } from "@microsoft/fast-web-utilities";
import { get } from "lodash-es";
import React from "react";
import { TextField } from "../text-field";
import { DisplayNamePrefix } from "../utilities";
import { TextActionAppearance, TextActionButtonPosition, } from "./text-action.props";
class TextAction extends Foundation {
    constructor(props) {
        super(props);
        this.handledProps = {
            appearance: void 0,
            afterGlyph: void 0,
            beforeGlyph: void 0,
            button: void 0,
            buttonPosition: void 0,
            className: void 0,
            managedClasses: void 0,
        };
        /**
         * Adds focus state to outer wrapper and fires callback if passed
         * In order to correctly focus the input and then the
         * possible button, a class must be added instead of using
         * focus-within via style
         */
        this.handleOnFocus = (e) => {
            this.setState({ focused: true });
            if (typeof this.props.onFocus === "function") {
                this.props.onFocus(e);
            }
        };
        /**
         * Removes focus state and fires callback if passed
         */
        this.handleOnBlur = (e) => {
            this.setState({ focused: false });
            if (typeof this.props.onBlur === "function") {
                this.props.onBlur(e);
            }
        };
        this.state = {
            focused: false,
        };
    }
    /**
     * Renders the component
     */
    render() {
        return (React.createElement("div", { className: this.generateClassNames() },
            this.buttonExists() &&
                this.props.buttonPosition === TextActionButtonPosition.before
                ? this.generateButton()
                : null,
            this.generateBeforeGlyph(),
            React.createElement(TextField, Object.assign({}, this.unhandledProps(), { disabled: get(this.props, "disabled", null), placeholder: get(this.props, "placeholder", null), jssStyleSheet: textFieldOverrides, onBlur: this.handleOnBlur, onFocus: this.handleOnFocus })),
            this.generateAfterGlyph(),
            this.buttonExists() &&
                this.props.buttonPosition === TextActionButtonPosition.after
                ? this.generateButton()
                : null));
    }
    /**
     * Generates class names
     */
    generateClassNames() {
        const { textAction, textAction__disabled, textAction__focus, } = this.props.managedClasses;
        return super.generateClassNames(classNames(textAction, [
            this.props.managedClasses[`textAction__${TextActionAppearance[this.props.appearance]}`],
            !!this.props.appearance,
        ], [textAction__disabled, this.props.disabled], [textAction__focus, this.state.focused]));
    }
    /**
     * Returns truthy if button exist
     */
    buttonExists() {
        return typeof this.props.button === "function";
    }
    /**
     * Generate button
     */
    generateButton() {
        return this.props.button(classNames(this.props.managedClasses.textAction_button), this.props.disabled);
    }
    /**
     * Generates after glyph based on props
     */
    generateAfterGlyph() {
        if (typeof this.props.afterGlyph === "function") {
            return this.props.afterGlyph(classNames(this.props.managedClasses.textAction_afterGlyph));
        }
    }
    /**
     * Generates before glyph based on props
     */
    generateBeforeGlyph() {
        if (typeof this.props.beforeGlyph === "function") {
            return this.props.beforeGlyph(classNames(this.props.managedClasses.textAction_beforeGlyph));
        }
    }
}
TextAction.displayName = `${DisplayNamePrefix}TextAction`;
TextAction.defaultProps = {
    buttonPosition: TextActionButtonPosition.after,
    managedClasses: {},
};
export default TextAction;
export * from "./text-action.props";
