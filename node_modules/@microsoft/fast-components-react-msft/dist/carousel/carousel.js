import Foundation from "@microsoft/fast-components-foundation-react";
import { Tabs } from "@microsoft/fast-components-react-base";
import { classNames } from "@microsoft/fast-web-utilities";
import { canUseDOM } from "exenv-es6";
import { get, isNil } from "lodash-es";
import React from "react";
import { Flipper, FlipperDirection } from "../flipper";
import { DisplayNamePrefix } from "../utilities";
import { CarouselSlideTheme, } from "./carousel.props";
class Carousel extends Foundation {
    /**
     * Define constructor
     */
    constructor(props) {
        super(props);
        /**
         * Handled props
         */
        this.handledProps = {
            autoplay: void 0,
            autoplayInterval: void 0,
            managedClasses: void 0,
            nextFlipper: void 0,
            previousFlipper: void 0,
            label: void 0,
            loop: void 0,
            activeId: void 0,
            onActiveIdUpdate: void 0,
            items: void 0,
        };
        /**
         * Initial slide transition direction is none (on carousel load)
         */
        this.slideTransitionDirection = null;
        /**
         * Return transition direction class name
         */
        this.assignTransitionDirectionClassName = () => {
            const { carousel__slideAnimateNext, carousel__slideAnimatePrevious, } = this.props.managedClasses;
            const transitionDirection = this.slideTransitionDirection === FlipperDirection.next
                ? carousel__slideAnimateNext
                : carousel__slideAnimatePrevious;
            return ` ${transitionDirection}`;
        };
        /**
         * Return slide theme class name
         */
        this.assignSlideThemeClassName = () => {
            const { carousel__themeLight, carousel__themeDark, } = this.props.managedClasses;
            const theme = this.getSlideTheme() === CarouselSlideTheme.light
                ? carousel__themeLight
                : carousel__themeDark;
            return ` ${theme}`;
        };
        /**
         * Change active tab
         */
        this.handleUpdate = (activeTab) => {
            if (typeof this.props.onActiveIdUpdate === "function") {
                this.props.onActiveIdUpdate(activeTab, false);
            }
            this.setState({
                activeId: activeTab,
            });
            const activeTabIndex = this.slides
                .map((slide) => slide.id)
                .indexOf(activeTab);
            this.setTransitionDirection(activeTabIndex);
        };
        /**
         * Handles automation of slide movement
         */
        this.autoplayNextSlide = () => {
            let nextPosition = this.getActiveIndex() + 1;
            if (nextPosition > this.slides.length - 1) {
                nextPosition = 0;
            }
            const activeId = this.slides[nextPosition].id;
            this.setTransitionDirection(nextPosition);
            if (typeof this.props.onActiveIdUpdate === "function") {
                this.props.onActiveIdUpdate(activeId, true);
            }
            this.setState({
                activeId,
            });
        };
        /**
         * Move to next slide if applicable
         */
        this.nextSlide = () => {
            let newPosition = this.getActiveIndex() + 1;
            if (newPosition > this.slides.length - 1) {
                newPosition = 0;
            }
            this.setTransitionDirection(newPosition);
            this.setNewSlidePosition(newPosition);
        };
        /**
         * Move to previous slide if applicable
         */
        this.previousSlide = () => {
            let newPosition = this.getActiveIndex() - 1;
            if (newPosition < 0) {
                newPosition = this.slides.length - 1;
            }
            this.setTransitionDirection(newPosition);
            this.setNewSlidePosition(newPosition);
        };
        this.rootEl = React.createRef();
        if (Array.isArray(this.props.items)) {
            this.state = {
                activeId: typeof this.props.activeId === "string"
                    ? this.props.activeId
                    : get(this.props.items[0], "id", " "),
            };
        }
    }
    /**
     * React life-cycle method
     */
    static getDerivedStateFromProps(nextProps, prevState) {
        if (nextProps.activeId && nextProps.activeId !== prevState.activeId) {
            return {
                activeId: nextProps.activeId,
            };
        }
        return null;
    }
    /**
     * Renders the component
     */
    render() {
        return (React.createElement("div", Object.assign({}, this.unhandledProps(), { className: this.generateClassNames(), ref: this.rootEl }),
            this.generatePreviousFlipper(),
            React.createElement(Tabs, { label: this.props.label, activeId: this.state.activeId, onUpdate: this.handleUpdate, items: this.slides, managedClasses: this.generateTabsClassNames(), disableTabFocus: this.props.autoplay }),
            this.generateNextFlipper()));
    }
    /**
     * React lifecycle hook
     */
    componentDidMount() {
        if (canUseDOM() && this.props.autoplay) {
            // Set initial interval for autoplay
            this.autoplayTimer = window.setInterval(this.autoplayNextSlide, this.props.autoplayInterval);
        }
    }
    /**
     * React lifecycle hook
     */
    componentDidUpdate(prevProps, prevState) {
        if (this.props.autoplay && isNil(this.autoplayTimer)) {
            // Set the window interval if we are in autplay and don't have a timer
            this.autoplayTimer = window.setInterval(this.autoplayNextSlide, this.props.autoplayInterval);
        }
        else if (!this.props.autoplay && !isNil(this.autoplayTimer)) {
            // Clear the interval if we should not be autoplaying
            this.autoplayTimer = window.clearInterval(this.autoplayTimer);
        }
    }
    /**
     * React lifecycle hook
     */
    componentWillUnmount() {
        if (!isNil(this.autoplayTimer)) {
            this.autoplayTimer = window.clearInterval(this.autoplayTimer);
        }
    }
    /**
     * Generate class names
     */
    generateClassNames() {
        return super.generateClassNames(classNames(this.props.managedClasses.carousel, [this.assignSlideThemeClassName, !!this.getSlideTheme()], [
            this.assignTransitionDirectionClassName(),
            !!this.slideTransitionDirection,
        ]));
    }
    /**
     * Returns tabs managedclasses with new carousel-specific JSS
     */
    generateTabsClassNames() {
        const { carousel_slides, carousel_tabPanels, carousel_sequenceIndicators, carousel_tabPanelContent, carousel_sequenceIndicator, carousel_sequenceIndicator__active, carousel_tabPanel, carousel_tabPanel__hidden, } = this.props.managedClasses;
        return {
            tabs: carousel_slides,
            tabs_tabPanels: carousel_tabPanels,
            tabs_tabList: carousel_sequenceIndicators,
            tabs_tabPanelContent: carousel_tabPanelContent,
            tab: carousel_sequenceIndicator,
            tab__active: carousel_sequenceIndicator__active,
            tabPanel: carousel_tabPanel,
            tabPanel__hidden: carousel_tabPanel__hidden,
        };
    }
    /**
     * Get an array of slides
     * Coerce tab shape
     */
    get slides() {
        if (Array.isArray(this.props.items)) {
            return this.props.items.map((slide) => Object.assign({}, slide, {
                tab: () => React.createElement(React.Fragment, null),
            }));
        }
        else {
            return [];
        }
    }
    /**
     * Single slide carousels do not require certain interface elements
     */
    get isMultipleSlides() {
        return this.slides.length !== 1;
    }
    /**
     * Check if it is the FIRST slide for looping
     */
    get isFirstSlide() {
        if (this.slides.length) {
            const firstSlideId = this.slides[0].id;
            return firstSlideId === this.state.activeId;
        }
        else {
            return false;
        }
    }
    /**
     * Check if it is the LAST slide for looping
     */
    get isLastSlide() {
        const lastItemKey = this.slides.length - 1;
        if (lastItemKey >= 0) {
            const lastSlideId = this.slides[lastItemKey].id;
            return lastSlideId === this.state.activeId;
        }
        else {
            return false;
        }
    }
    /**
     * Get the active slide index
     */
    getActiveIndex() {
        return this.slides
            .map((slide) => slide.id)
            .indexOf(this.state.activeId);
    }
    /**
     * Get the current slide theme (needed for UI overlay contrast)
     */
    getSlideTheme() {
        if (this.slides.length <= 0) {
            return;
        }
        return this.slides[this.getActiveIndex()].theme
            ? this.slides[this.getActiveIndex()].theme
            : CarouselSlideTheme.dark;
    }
    /**
     * Set the transition direction based on incoming index
     */
    setTransitionDirection(incomingIndex) {
        if (this.getActiveIndex() < incomingIndex) {
            this.slideTransitionDirection = FlipperDirection.next;
        }
        else {
            this.slideTransitionDirection = FlipperDirection.previous;
        }
    }
    /**
     * Generates previous flipper if more than one slide
     */
    generatePreviousFlipper() {
        if (!this.isMultipleSlides || (this.isFirstSlide && !this.props.loop)) {
            return;
        }
        const previousFlipperClassName = this.props.managedClasses
            .carousel_flipperPrevious;
        if (typeof this.props.previousFlipper === "function") {
            return this.props.previousFlipper(this.previousSlide, previousFlipperClassName);
        }
        else {
            return (React.createElement(Flipper, { direction: FlipperDirection.previous, onClick: this.previousSlide, className: previousFlipperClassName }));
        }
    }
    /**
     * Generates next flipper if more than one slide
     */
    generateNextFlipper() {
        if (!this.isMultipleSlides || (this.isLastSlide && !this.props.loop)) {
            return;
        }
        const nextFlipperClassName = this.props.managedClasses
            .carousel_flipperNext;
        if (typeof this.props.nextFlipper === "function") {
            return this.props.nextFlipper(this.nextSlide, nextFlipperClassName);
        }
        else {
            return (React.createElement(Flipper, { direction: FlipperDirection.next, onClick: this.nextSlide, className: nextFlipperClassName }));
        }
    }
    /**
     * Sets new slide based on position
     */
    setNewSlidePosition(position) {
        const newActiveId = this.slides[position].id;
        if (typeof this.props.onActiveIdUpdate === "function") {
            this.props.onActiveIdUpdate(newActiveId, false);
        }
        this.setState({
            activeId: newActiveId,
        });
    }
}
Carousel.displayName = `${DisplayNamePrefix}Carousel`;
Carousel.defaultProps = {
    autoplay: false,
    autoplayInterval: 6000,
    loop: true,
    managedClasses: {},
};
export default Carousel;
export * from "./carousel.props";
