import Foundation from "@microsoft/fast-components-foundation-react";
import { classNames, Direction, getClientRectWithMargin, RtlScrollConverter, } from "@microsoft/fast-web-utilities";
import { canUseDOM } from "exenv-es6";
import { get, isNil } from "lodash-es";
import throttle from "raf-throttle";
import React from "react";
import { DisplayNamePrefix, } from "../utilities";
export var ButtonDirection;
(function (ButtonDirection) {
    ButtonDirection["previous"] = "previous";
    ButtonDirection["next"] = "next";
})(ButtonDirection || (ButtonDirection = {}));
class HorizontalOverflow extends Foundation {
    /**
     * Constructor
     */
    constructor(props) {
        super(props);
        this.handledProps = {
            scrollDuration: void 0,
            managedClasses: void 0,
            onScrollChange: void 0,
            onOverflowChange: void 0,
            nextItemPeek: void 0,
        };
        /**
         * Stores pending animation frame requests
         */
        this.openRequestAnimationFrame = null;
        /**
         * Flag indicates if a scroll animation is in progress
         */
        this.isScrollAnimating = false;
        /**
         * Stores last scroll position from scroll events
         */
        this.lastRecordedScroll = 0;
        /**
         * Track scroll position
         */
        this.onScrollCapture = (event) => {
            this.lastRecordedScroll = this.getScrollPosition();
        };
        /**
         * A child item got focus make sure it is in view
         */
        this.onItemFocus = (event) => {
            if (!this.isOverflow()) {
                return;
            }
            const itemLeft = event.currentTarget.offsetLeft;
            const itemWidth = event.currentTarget.clientWidth;
            const itemRight = itemLeft + itemWidth;
            const viewportWidth = this.getAvailableWidth();
            const peek = this.getScrollPeek(itemWidth);
            let scrollStart = this.lastRecordedScroll;
            if (this.isScrollAnimating) {
                const duration = this.props.scrollDuration
                    ? this.props.scrollDuration
                    : HorizontalOverflow.defaultScrollAnimationDuration;
                const currentDate = new Date().getTime();
                const currentTime = currentDate - this.currentScrollAnimStartTime;
                scrollStart = this.getScrollAnimationPosition(currentTime, duration);
            }
            if (itemLeft - this.lastRecordedScroll < 0) {
                this.scrollContent(scrollStart, itemLeft - peek);
            }
            else if (itemRight - scrollStart > viewportWidth) {
                this.scrollContent(scrollStart, itemRight - viewportWidth + peek);
            }
        };
        /**
         *  Compares viewport width, item width and desired peek value to come up with
         *  peek value to use. We don't want to clip focused item to get peek on next/previous item.
         */
        this.getScrollPeek = (itemWidth) => {
            const viewportWidth = this.getAvailableWidth();
            let maxPeek = viewportWidth - itemWidth;
            maxPeek = maxPeek < 0 ? 0 : maxPeek;
            const peek = this.props.nextItemPeek > maxPeek ? maxPeek : this.props.nextItemPeek;
            return peek;
        };
        /**
         * Callback for on scroll change
         */
        this.onScrollChange = () => {
            if (typeof this.props.onScrollChange === "function") {
                this.props.onScrollChange(this.getPositionData());
            }
            // If the onOverflowChange callback exists, we want to update overflow
            // based on scroll change
            if (typeof this.props.onOverflowChange === "function") {
                const positionData = this.getPositionData();
                if (this.overflowStart === !positionData.start ||
                    this.overflowEnd === !positionData.end) {
                    this.handleOverflowChange();
                }
            }
        };
        /**
         * Get the scroll change data
         */
        this.getPositionData = () => {
            if (isNil(this.horizontalOverflowItemsRef.current)) {
                return { start: true, end: true };
            }
            const scrollPosition = this.getScrollPosition();
            const isAtBeginning = scrollPosition === 0;
            const isAtEnd = this.horizontalOverflowItemsRef.current.scrollWidth - scrollPosition ===
                this.horizontalOverflowItemsRef.current.clientWidth;
            return { start: isAtBeginning, end: isAtEnd };
        };
        /**
         * onLoad handler to make sure any children affecting height are accounted for
         */
        this.itemsOnLoad = () => {
            const itemsHeight = this.getItemMaxHeight();
            if (itemsHeight !== this.state.itemsHeight) {
                this.setState({
                    itemsHeight,
                });
            }
            if (this.overflow !== this.isOverflow()) {
                this.handleOverflowChange();
            }
        };
        /**
         * Handles the resize event
         */
        this.onWindowResize = () => {
            if (this.overflow !== this.isOverflow()) {
                this.handleOverflowChange();
            }
        };
        /**
         * Callback for the horizontal overflow change
         */
        this.handleOverflowChange = () => {
            this.overflow = this.isOverflow();
            if (this.overflow) {
                const positionData = this.getPositionData();
                this.overflowStart = !positionData.start;
                this.overflowEnd = !positionData.end;
            }
            else {
                this.overflowStart = false;
                this.overflowEnd = false;
            }
            if (typeof this.props.onOverflowChange === "function") {
                this.props.onOverflowChange({
                    overflowStart: this.overflowStart,
                    overflowEnd: this.overflowEnd,
                });
            }
        };
        /**
         * Handler for the previous click event
         */
        this.handlePreviousClick = () => {
            this.handleClick(ButtonDirection.previous);
        };
        /**
         * Handler for the next click event
         */
        this.handleNextClick = () => {
            this.handleClick(ButtonDirection.next);
        };
        /**
         * Request's an animation frame if there are currently no open animation frame requests
         */
        this.requestFrame = () => {
            if (this.openRequestAnimationFrame === null) {
                this.openRequestAnimationFrame = window.requestAnimationFrame(this.updateScrollAnimation);
            }
        };
        /**
         *  Animate one frame of scrolling
         */
        this.updateScrollAnimation = () => {
            this.openRequestAnimationFrame = null;
            const duration = this.props.scrollDuration
                ? this.props.scrollDuration
                : HorizontalOverflow.defaultScrollAnimationDuration;
            const currentDate = new Date().getTime();
            const currentTime = currentDate - this.currentScrollAnimStartTime;
            this.setScrollPosition(this.getScrollAnimationPosition(currentTime, duration));
            if (currentTime < duration) {
                this.requestFrame();
            }
            else {
                this.isScrollAnimating = false;
            }
        };
        /**
         *  get scroll animation position for the provided time
         */
        this.getScrollAnimationPosition = (currentTime, duration) => {
            if (currentTime < duration) {
                return this.easeInOutQuad(currentTime, this.currentScrollAnimStartPosition, this.currentScrollAnimEndPosition - this.currentScrollAnimStartPosition, duration);
            }
            else {
                return this.currentScrollAnimEndPosition;
            }
        };
        /**
         *  Gets the scroll position and accounts for direction
         */
        this.getScrollPosition = () => {
            if (isNil(this.horizontalOverflowItemsRef.current)) {
                return 0;
            }
            const scrollLeft = RtlScrollConverter.getScrollLeft(this.horizontalOverflowItemsRef.current, this.state.direction);
            return this.state.direction === Direction.rtl ? -scrollLeft : scrollLeft;
        };
        /**
         *  Sets the scroll position and accounts for direction
         */
        this.setScrollPosition = (scrollValue) => {
            if (!isNil(this.horizontalOverflowItemsRef.current)) {
                RtlScrollConverter.setScrollLeft(this.horizontalOverflowItemsRef.current, this.state.direction === Direction.rtl ? -scrollValue : scrollValue, this.state.direction);
            }
        };
        /**
         *  updates the direction in state if necessary
         */
        this.updateDirection = () => {
            const newDirection = this.getDirection();
            if (newDirection !== this.state.direction) {
                this.setState({
                    direction: newDirection,
                });
            }
        };
        /**
         *  gets the current direction
         */
        this.getDirection = () => {
            if (this.horizontalOverflowItemsRef.current === null) {
                return Direction.ltr;
            }
            const closest = this.horizontalOverflowItemsRef.current.closest(`[${HorizontalOverflow.DirectionAttributeName}]`);
            return closest === null ||
                closest.getAttribute(HorizontalOverflow.DirectionAttributeName) ===
                    Direction.ltr
                ? Direction.ltr
                : Direction.rtl;
        };
        this.horizontalOverflowItemsRef = React.createRef();
        this.throttledScroll = throttle(this.onScrollChange);
        this.throttledResize = throttle(this.onWindowResize);
        this.overflow = false;
        this.state = {
            direction: Direction.ltr,
            itemsHeight: null,
        };
    }
    /**
     * Renders the Horizontal Overflow markup
     */
    render() {
        const { horizontalOverflow_contentRegion, horizontalOverflow_previous, horizontalOverflow_next, } = this.props.managedClasses;
        return (React.createElement("div", Object.assign({}, this.unhandledProps(), { className: this.generateClassNames(), onLoad: this.itemsOnLoad }),
            React.createElement("div", { style: {
                    height: this.state.itemsHeight !== null
                        ? `${this.state.itemsHeight}px`
                        : "auto",
                    position: "relative",
                    overflow: "hidden",
                } },
                React.createElement("ul", { className: classNames(horizontalOverflow_contentRegion), style: this.getListStyle(), ref: this.horizontalOverflowItemsRef, onScrollCapture: this.onScrollCapture }, this.getItems())),
            React.createElement("div", { className: classNames(horizontalOverflow_previous), onClick: this.handlePreviousClick }, this.withSlot(ButtonDirection.previous)),
            React.createElement("div", { className: classNames(horizontalOverflow_next), onClick: this.handleNextClick }, this.withSlot(ButtonDirection.next))));
    }
    /**
     * React life-cycle method
     */
    componentDidMount() {
        if (!this.props.children) {
            return;
        }
        const itemsHeight = this.getItemMaxHeight();
        this.setState({
            itemsHeight,
        });
        if (canUseDOM() && this.horizontalOverflowItemsRef.current) {
            this.updateDirection();
            this.lastRecordedScroll = this.getScrollPosition();
            this.horizontalOverflowItemsRef.current.addEventListener("scroll", this.throttledScroll);
            window.addEventListener("resize", this.throttledResize);
            // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142
            // Full browser support imminent
            // Revisit usage once Safari and Firefox adapt
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409
            // https://bugs.webkit.org/show_bug.cgi?id=157743
            if (window.ResizeObserver) {
                this.resizeObserver = new window.ResizeObserver((entries) => {
                    if (this.overflow !== this.isOverflow()) {
                        this.handleOverflowChange();
                    }
                });
                this.resizeObserver.observe(this.horizontalOverflowItemsRef.current);
            }
        }
    }
    /**
     * React life-cycle method
     */
    componentWillUnmount() {
        if (canUseDOM() && this.horizontalOverflowItemsRef.current) {
            this.horizontalOverflowItemsRef.current.removeEventListener("scroll", this.throttledScroll);
            window.removeEventListener("resize", this.throttledResize);
            // TODO #1142 https://github.com/Microsoft/fast-dna/issues/1142
            // Full browser support imminent
            // Revisit usage once Safari and Firefox adapt
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1272409
            // https://bugs.webkit.org/show_bug.cgi?id=157743
            if (this.resizeObserver &&
                typeof this.resizeObserver.disconnect === "function") {
                this.resizeObserver.disconnect();
                this.resizeObserver = null;
            }
            // Cancel any pending calls
            this.throttledResize.cancel();
            this.throttledScroll.cancel();
        }
    }
    /**
     * React life-cycle method
     */
    getSnapshotBeforeUpdate(prevProps) {
        if (React.Children.toArray(prevProps.children).length <
            React.Children.toArray(this.props.children).length) {
            return true;
        }
        return null;
    }
    /**
     * React life-cycle method
     */
    componentDidUpdate(prevProps, prevState, snapshot) {
        if (snapshot !== null) {
            this.handleOverflowChange();
        }
        this.updateDirection();
    }
    /**
     * Generates class names
     */
    generateClassNames() {
        return super.generateClassNames(classNames(this.props.managedClasses.horizontalOverflow));
    }
    /**
     * Gets the style for the `ul` element containing the items
     */
    getListStyle() {
        return {
            position: "relative",
            whiteSpace: "nowrap",
            overflowX: "scroll",
            padding: 0,
            margin: 0,
        };
    }
    /**
     * Checks if overflow is occuring
     */
    isOverflow() {
        const availableWidth = this.getAvailableWidth();
        const itemWidths = this.getItemWidths();
        const totalItemWidth = itemWidths.reduce((a, b) => a + b);
        return totalItemWidth > availableWidth;
    }
    /**
     * Identifies and returns the tallest child height
     */
    getItemMaxHeight() {
        let itemMaxHeight = 0;
        const children = get(this.horizontalOverflowItemsRef, "current.childNodes");
        if (!canUseDOM() || !children) {
            return itemMaxHeight;
        }
        const childNodes = Array.prototype.slice.call(children);
        for (const childNode of childNodes) {
            const childNodeHeight = getClientRectWithMargin(childNode).height;
            if (childNodeHeight > itemMaxHeight) {
                itemMaxHeight = childNodeHeight;
            }
        }
        return itemMaxHeight;
    }
    /**
     * Gets the children displayed as items to be scrolled
     */
    getItems() {
        return React.Children.map(this.withoutSlot([ButtonDirection.previous, ButtonDirection.next]), (child, index) => {
            return (React.createElement("li", { onFocusCapture: this.onItemFocus, className: classNames(this.props.managedClasses.horizontalOverflow_item), style: { display: "inline-block" } }, child));
        });
    }
    /**
     * Gets the distance to scroll based on the direction
     */
    getScrollDistanceFromButtonDirection(buttonDirection, itemWidths, scrollPosition) {
        if (itemWidths.length === 0 || !canUseDOM()) {
            return 0;
        }
        let distance = 0;
        if (buttonDirection === ButtonDirection.next) {
            distance = this.getWithinMaxDistance(scrollPosition, itemWidths);
        }
        else {
            distance = this.getWithinMinDistance(scrollPosition, itemWidths);
        }
        return Math.ceil(distance);
    }
    /**
     * Gets the distance unless it is over the maximum distance, then use maximum distance instead
     */
    getWithinMaxDistance(scrollPosition, itemWidths) {
        const maxDistance = this.getMaxScrollDistance();
        if (scrollPosition === maxDistance) {
            return maxDistance;
        }
        const distance = this.getNextDistance(itemWidths, scrollPosition);
        return distance >= maxDistance ? maxDistance : distance;
    }
    /**
     * Gets the distance unless it is under the minimum distance, then use minimum distance instead
     */
    getWithinMinDistance(scrollPosition, itemWidths) {
        if (scrollPosition === 0) {
            return 0;
        }
        const distance = this.getPreviousDistance(itemWidths, scrollPosition);
        return distance <= 0 ? 0 : distance;
    }
    /**
     * Gets the distance to scroll if the next button has been clicked
     */
    getNextDistance(itemWidths, scrollPosition) {
        let distance = 0;
        for (let i = 0, itemWidthsLength = itemWidths.length; i < itemWidthsLength; i++) {
            if (distance + itemWidths[i] > scrollPosition + this.getAvailableWidth() &&
                distance !== scrollPosition) {
                return distance + this.getScrollPeek(itemWidths[i]);
            }
            distance += itemWidths[i];
        }
        return distance;
    }
    /**
     * Gets the distance to scroll if the previous button has been clicked
     */
    getPreviousDistance(itemWidths, scrollPosition) {
        const availableWidth = this.getAvailableWidth();
        let distance = this.getMaxScrollDistance() + availableWidth;
        for (let i = itemWidths.length - 1; i >= 0; i--) {
            if (distance - itemWidths[i] < scrollPosition - availableWidth &&
                distance !== scrollPosition) {
                return distance - this.getScrollPeek(itemWidths[i]);
            }
            distance -= itemWidths[i];
        }
        return distance;
    }
    /**
     * Gets the maximum distance that can be scrolled
     */
    getMaxScrollDistance() {
        if (isNil(this.horizontalOverflowItemsRef.current)) {
            return 0;
        }
        return (this.horizontalOverflowItemsRef.current.scrollWidth - this.getAvailableWidth());
    }
    /**
     * Handler for the click event fired after next or previous has been clicked
     */
    handleClick(buttonDirection) {
        this.scrollContent(this.getScrollPosition(), this.getScrollDistanceFromButtonDirection(buttonDirection, this.getItemWidths(), this.getScrollPosition()));
    }
    /**
     * Returns the available content region width
     */
    getAvailableWidth() {
        if (isNil(this.horizontalOverflowItemsRef.current)) {
            return 0;
        }
        return this.horizontalOverflowItemsRef.current.clientWidth;
    }
    /**
     * Returns the items widths
     */
    getItemWidths() {
        if (isNil(this.horizontalOverflowItemsRef.current)) {
            return null;
        }
        const items = Array.prototype.slice.call(this.horizontalOverflowItemsRef.current.childNodes);
        const itemWidths = [];
        for (const item of items) {
            itemWidths.push(getClientRectWithMargin(item).width);
        }
        return itemWidths;
    }
    /**
     * Easing animation
     * Inspired by the github gist contribution: https://gist.github.com/andjosh/6764939
     */
    easeInOutQuad(currentTime, startValue, changeInValue, duration) {
        currentTime /= duration / 2;
        if (currentTime < 1) {
            return (changeInValue / 2) * currentTime * currentTime + startValue;
        }
        currentTime--;
        return (-changeInValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;
    }
    /**
     * Scrolls the container for the items list
     */
    scrollContent(startScrollPosition, targetScrollPosition) {
        const newScrollPosition = Math.max(0, Math.min(targetScrollPosition, this.getMaxScrollDistance()));
        this.isScrollAnimating = true;
        this.currentScrollAnimStartPosition = startScrollPosition;
        this.currentScrollAnimEndPosition = newScrollPosition;
        this.currentScrollAnimStartTime = new Date().getTime();
        this.requestFrame();
    }
}
HorizontalOverflow.displayName = `${DisplayNamePrefix}HorizontalOverflow`;
HorizontalOverflow.defaultProps = {
    managedClasses: {},
    nextItemPeek: 50,
};
HorizontalOverflow.DirectionAttributeName = "dir";
HorizontalOverflow.defaultScrollAnimationDuration = 500;
export default HorizontalOverflow;
