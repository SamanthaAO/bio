import Foundation from "@microsoft/fast-components-foundation-react";
import { classNames, keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnd, keyCodeEnter, keyCodeEscape, keyCodeHome, keyCodeSpace, keyCodeTab, startsWith, } from "@microsoft/fast-web-utilities";
import { canUseDOM } from "exenv-es6";
import { inRange, isEqual } from "lodash-es";
import React from "react";
import { DisplayNamePrefix } from "../utilities";
import { ListboxContext } from "./listbox-context";
class Listbox extends Foundation {
    constructor(props) {
        super(props);
        this.handledProps = {
            children: void 0,
            defaultSelection: void 0,
            disabled: void 0,
            labelledBy: void 0,
            managedClasses: void 0,
            multiselectable: void 0,
            onItemInvoked: void 0,
            onSelectedItemsChanged: void 0,
            selectedItems: void 0,
            typeAheadEnabled: void 0,
            typeAheadPropertyKey: void 0,
            focusItemOnMount: void 0,
            selectOnFocus: void 0,
        };
        this.rootElement = React.createRef();
        this.typeAheadString = "";
        this.shiftRangeSelectStartIndex = -1;
        /**
         * Render a single child
         */
        this.renderChild = (child, index) => {
            return React.cloneElement(child, {
                tabIndex: index === this.state.focusIndex ? 0 : -1,
            });
        };
        /**
         * Determines if a given element should be focusable by the menu
         */
        this.isFocusableElement = (element) => {
            return (element instanceof HTMLElement &&
                element.getAttribute("role") === "option" &&
                !this.isDisabledElement(element) &&
                !this.props.disabled);
        };
        /**
         * Determines if a given element is disabled
         */
        this.isDisabledElement = (element) => {
            return (element instanceof HTMLElement &&
                element.getAttribute("aria-disabled") === "true");
        };
        /**
         * sets focus state and selection when component is initially mounted
         * or when default selection changes
         */
        this.setInitialFocus = (selection) => {
            let focusIndex = -1;
            focusIndex =
                selection.length > 0
                    ? Listbox.getItemIndexById(selection[0].id, this.props.children)
                    : this.domChildren().findIndex(this.isFocusableElement);
            if (focusIndex !== -1) {
                if (this.props.focusItemOnMount) {
                    this.setFocus(focusIndex, +1);
                }
                this.setState({
                    focusIndex,
                });
            }
        };
        /**
         * gets the initial selection state based on props
         */
        this.getInitialSelection = () => {
            let initialSelection;
            if (this.props.selectedItems !== undefined) {
                initialSelection = Listbox.getListboxItemDataFromIds(this.props.selectedItems, this.props.children);
            }
            else {
                initialSelection = Listbox.getListboxItemDataFromIds(this.props.defaultSelection, this.props.children);
            }
            if (!this.props.multiselectable && initialSelection.length > 1) {
                initialSelection = initialSelection.slice(0, 1);
            }
            return initialSelection;
        };
        /**
         * Function called by child select options when they have been focused
         */
        this.listboxItemfocused = (item, event) => {
            if (this.props.disabled) {
                return;
            }
            const target = event.currentTarget;
            const focusIndex = this.domChildren().indexOf(target);
            if (this.isDisabledElement(target)) {
                target.blur();
                return;
            }
            this.setState({
                focusIndex,
                focussedItemId: item.id,
            });
            if (!this.props.multiselectable && this.props.selectOnFocus) {
                this.updateSelection([item]);
            }
        };
        /**
         * Handle the keydown event of the root menu
         */
        this.handleMenuKeyDown = (event) => {
            if (typeof this.props.onKeyDown === "function") {
                this.props.onKeyDown(event);
            }
            if (event.defaultPrevented || this.props.disabled) {
                return;
            }
            let focusItemId;
            switch (event.keyCode) {
                case keyCodeEscape:
                case keyCodeEnter:
                case keyCodeSpace:
                case keyCodeTab:
                    return;
                case keyCodeArrowDown:
                case keyCodeArrowRight:
                    focusItemId = this.setFocus(this.state.focusIndex + 1, 1);
                    if (this.props.multiselectable && event.shiftKey && focusItemId !== "") {
                        const itemProps = Listbox.getItemPropsById(focusItemId, this.props.children);
                        if (itemProps !== null) {
                            this.toggleItem(itemProps);
                        }
                    }
                    event.preventDefault();
                    break;
                case keyCodeArrowUp:
                case keyCodeArrowLeft:
                    focusItemId = this.setFocus(this.state.focusIndex - 1, -1);
                    if (this.props.multiselectable && event.shiftKey && focusItemId !== "") {
                        const itemData = Listbox.getItemPropsById(focusItemId, this.props.children);
                        if (itemData !== null) {
                            this.toggleItem(itemData);
                        }
                    }
                    event.preventDefault();
                    break;
                case keyCodeEnd:
                    if (this.props.multiselectable && event.shiftKey && event.ctrlKey) {
                        this.selectRange(this.state.focusIndex, this.domChildren().length - 1);
                    }
                    this.setFocus(this.domChildren().length - 1, -1);
                    break;
                case keyCodeHome:
                    if (this.props.multiselectable && event.shiftKey && event.ctrlKey) {
                        this.selectRange(0, this.state.focusIndex);
                    }
                    this.setFocus(0, 1);
                    break;
                default:
                    if (event.key === "A") {
                        this.selectRange(0, this.domChildren().length);
                    }
                    else if (!event.ctrlKey && this.props.typeAheadEnabled) {
                        this.processTypeAhead(event);
                    }
            }
        };
        /**
         * Sets focus based on characters typed
         */
        this.processTypeAhead = (e) => {
            clearTimeout(this.typeAheadTimer);
            this.typeAheadString = this.typeAheadString + e.key.toLowerCase();
            let matchIndex = -1;
            const children = React.Children.toArray(this.props.children);
            children.some((child, index) => {
                if (child.props[this.props.typeAheadPropertyKey] === undefined) {
                    return false;
                }
                if (startsWith(child.props[this.props.typeAheadPropertyKey].toLowerCase(), this.typeAheadString)) {
                    matchIndex = index;
                    return true;
                }
            });
            if (matchIndex !== -1) {
                this.typeAheadTimer = setTimeout(() => {
                    this.typeAheadTimerExpired();
                }, 1000);
                this.setFocus(matchIndex, 1);
            }
            else {
                this.typeAheadString = "";
            }
        };
        /**
         * clears the type ahead buffer after specified time of no typing
         */
        this.typeAheadTimerExpired = () => {
            this.typeAheadString = "";
            clearTimeout(this.typeAheadTimer);
        };
        /**
         * Function called by child items when they have been invoked
         */
        this.listboxItemInvoked = (item, event) => {
            if (this.props.disabled) {
                return;
            }
            if (typeof this.props.onItemInvoked === "function") {
                this.props.onItemInvoked(item);
            }
            const target = event.currentTarget;
            const itemIndex = this.domChildren().indexOf(target);
            if (this.props.multiselectable && event.type === "click") {
                if (!event.shiftKey || this.shiftRangeSelectStartIndex === -1) {
                    this.shiftRangeSelectStartIndex = itemIndex;
                }
                if (event.ctrlKey) {
                    this.toggleItem(item);
                }
                else if (event.shiftKey) {
                    this.selectRange(this.shiftRangeSelectStartIndex, itemIndex);
                }
                else {
                    this.updateSelection([item]);
                }
            }
            else if (this.props.multiselectable && event.type === "keydown") {
                if (event.shiftKey) {
                    this.selectRange(this.shiftRangeSelectStartIndex, itemIndex);
                }
                else {
                    this.toggleItem(item);
                }
            }
            else {
                this.updateSelection([item]);
            }
        };
        /**
         * Toggle the selection state of the item
         */
        this.toggleItem = (item) => {
            const culledSelection = this.state.selectedItems.filter((listboxItem) => {
                return listboxItem.id !== item.id;
            });
            if (culledSelection.length < this.state.selectedItems.length) {
                this.updateSelection(culledSelection);
            }
            else {
                const newSelectedItems = this.state.selectedItems.concat([
                    item,
                ]);
                this.updateSelection(newSelectedItems);
            }
        };
        /**
         * Select a range of items
         */
        this.selectRange = (startIndex, endIndex) => {
            const children = React.Children.toArray(this.props.children);
            const childrenInRange = children.slice(startIndex >= endIndex ? endIndex : startIndex, startIndex >= endIndex ? startIndex + 1 : endIndex + 1);
            const newSelectedItems = childrenInRange.map((child) => {
                return child.props;
            });
            this.updateSelection(newSelectedItems);
        };
        /**
         * Updates selection state (should be the only place this is done outside of initialization)
         */
        this.updateSelection = (newSelection) => {
            const validatedSelection = Listbox.validateSelection(newSelection, this.props.children);
            if (isEqual(validatedSelection, this.state.selectedItems)) {
                return;
            }
            if (this.props.selectedItems === undefined) {
                this.setState({
                    selectedItems: validatedSelection,
                });
            }
            if (this.props.onSelectedItemsChanged) {
                this.props.onSelectedItemsChanged(validatedSelection);
            }
        };
        this.state = {
            focusIndex: -1,
            focussedItemId: "",
            selectedItems: this.getInitialSelection(),
        };
    }
    /**
     * converts an array of item id's to an array of ListboxItemProps objects populated by data
     * extracted from the provided children based on id match
     */
    static getListboxItemDataFromIds(selectedIds, children) {
        const selectedItems = Listbox.validateSelection(selectedIds, children);
        return selectedItems;
    }
    /**
     * Gets the index of an item from it's id by examining children props
     */
    static getItemIndexById(itemId, children) {
        const childrenAsArray = React.Children.toArray(children);
        return childrenAsArray.findIndex((child) => {
            if (child.props[Listbox.idPropertyKey] === undefined ||
                child.props[Listbox.idPropertyKey] !== itemId) {
                return false;
            }
            return true;
        });
    }
    /**
     * tests whether a React.ReactElement is a valid item to select
     * (ie. such an option id exists and the option is not disabled),
     * the values of the returned data objects are updated to reflect values of child object
     * with matching id.
     */
    static isValidSelectedItem(itemNode) {
        if (itemNode === undefined ||
            itemNode.props[Listbox.disabledPropertyKey] === true ||
            itemNode.props[Listbox.valuePropertyKey] === undefined) {
            return false;
        }
        return true;
    }
    /**
     * Gets a child node from it's id by examining provided children
     */
    static getNodeById(itemId, children) {
        const childrenAsArray = React.Children.toArray(children);
        const matchNode = childrenAsArray.find((child) => {
            if (child.props[Listbox.idPropertyKey] === undefined ||
                child.props[Listbox.idPropertyKey] !== itemId) {
                return false;
            }
            return true;
        });
        return matchNode;
    }
    /**
     * Gets the listItemData of an item from it's id by examining children props
     */
    static getItemPropsById(itemId, children) {
        const matchNode = this.getNodeById(itemId, children);
        if (matchNode !== undefined) {
            return matchNode.props;
        }
        return null;
    }
    /**
     * validates selected options against child props and returns only the valid ones
     * (ie. such an option id exists and the option is not disabled),
     * the values of the returned data objects are updated to reflect values of child object
     * with matching id.
     */
    static validateSelection(items, children) {
        const validSelection = items
            .map((item) => {
            let itemId = "";
            if (typeof item === "string") {
                itemId = item;
            }
            else {
                itemId = item.id;
            }
            const itemNode = this.getNodeById(itemId, children);
            if (!Listbox.isValidSelectedItem(itemNode)) {
                return null;
            }
            return itemNode.props;
        })
            .filter((listboxItem) => {
            return listboxItem !== null;
        });
        return validSelection;
    }
    /**
     * Renders the component
     */
    render() {
        return (React.createElement("div", Object.assign({}, this.unhandledProps(), { ref: this.rootElement, role: "listbox", "aria-disabled": this.props.disabled || null, "aria-multiselectable": this.props.multiselectable || null, "aria-activedescendant": this.state.focussedItemId, "aria-labelledby": this.props.labelledBy || null, className: this.generateClassNames(), onKeyDown: this.handleMenuKeyDown }),
            React.createElement(ListboxContext.Provider, { value: {
                    listboxSelectedItems: this.state.selectedItems,
                    listboxItemFocused: this.listboxItemfocused,
                    listboxItemInvoked: this.listboxItemInvoked,
                    listboxMultiselectable: this.props.multiselectable,
                } }, this.renderChildren())));
    }
    componentDidUpdate(prevProps) {
        // if default selection changes between renders we treat as a effective reset
        // of selection and focus in uncontrolled mode
        if (!isEqual(prevProps.defaultSelection, this.props.defaultSelection) &&
            this.props.selectedItems === undefined) {
            const updatedSelection = this.getInitialSelection();
            this.updateSelection(updatedSelection);
            this.setInitialFocus(updatedSelection);
        }
    }
    componentDidMount() {
        this.setInitialFocus(this.state.selectedItems);
    }
    componentWillUnmount() {
        clearTimeout(this.typeAheadTimer);
    }
    /**
     * Create class names
     */
    generateClassNames() {
        const { listbox, listbox__disabled, } = this.props.managedClasses;
        return super.generateClassNames(classNames(listbox, [listbox__disabled, this.props.disabled]));
    }
    /**
     * Render all child elements
     */
    renderChildren() {
        return React.Children.map(this.props.children, this.renderChild);
    }
    /**
     * Return an array of all focusabled elements that are children
     * of the context menu
     */
    domChildren() {
        return canUseDOM() && this.rootElement.current instanceof HTMLElement
            ? Array.from(this.rootElement.current.children)
            : [];
    }
    /**
     * Sets focus to the nearest focusable element to the supplied focusIndex.
     * The adjustment controls how the function searches for other focusable elements
     * if the element at the focusIndex is not focusable. A positive number will search
     * towards the end of the children array, whereas a negative number will search towards
     * the beginning of the children array.  Returns the focussed item id or an empty string
     * if none found
     */
    setFocus(focusIndex, adjustment) {
        const children = this.domChildren();
        let focusItemId = "";
        while (inRange(focusIndex, children.length)) {
            const child = children[focusIndex];
            focusItemId = child.id;
            if (this.isFocusableElement(child)) {
                if (!this.props.disabled) {
                    child.focus();
                }
                break;
            }
            focusIndex += adjustment;
        }
        return focusItemId;
    }
}
Listbox.displayName = `${DisplayNamePrefix}Listbox`;
Listbox.defaultProps = {
    multiselectable: false,
    defaultSelection: [],
    typeAheadPropertyKey: "displayString",
    typeAheadEnabled: true,
    focusItemOnMount: false,
    managedClasses: {},
    selectOnFocus: true,
};
/**
 * returns the first selectable item in the provided array of children
 */
Listbox.getFirstValidOptionInRange = (startIndex, endIndex, childrenAsArray, increment) => {
    for (let i = startIndex; i !== endIndex + increment; i = i + increment) {
        const thisOption = childrenAsArray[i];
        if (Listbox.isValidSelectedItem(thisOption)) {
            return thisOption;
        }
        return null;
    }
};
/**
 * returns all the selectable items in the provided array of children
 */
Listbox.getValidOptions = (childrenAsArray) => {
    return childrenAsArray.filter((itemNode) => {
        return Listbox.isValidSelectedItem(itemNode);
    });
};
Listbox.valuePropertyKey = "value";
Listbox.idPropertyKey = "id";
Listbox.displayStringPropertyKey = "displayString";
Listbox.disabledPropertyKey = "disabled";
export default Listbox;
export { ListboxContext };
