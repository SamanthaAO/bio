import Foundation from "@microsoft/fast-components-foundation-react";
import { classNames, keyCodeEscape, keyCodeTab } from "@microsoft/fast-web-utilities";
import { canUseDOM } from "exenv-es6";
import React from "react";
import { DisplayNamePrefix } from "../utilities";
import Tabbable from "tabbable";
class Dialog extends Foundation {
    constructor() {
        super(...arguments);
        this.handledProps = {
            describedBy: void 0,
            label: void 0,
            labelledBy: void 0,
            contentWidth: void 0,
            contentHeight: void 0,
            modal: void 0,
            managedClasses: void 0,
            onDismiss: void 0,
            visible: void 0,
        };
        this.rootElement = React.createRef();
        /**
         * Check if props demand a key listener
         */
        this.shouldAddKeyListener = (props) => {
            if (props.modal || props.onDismiss) {
                return true;
            }
            return false;
        };
        /**
         * handles document key down events
         */
        this.handleDocumentKeyDown = (event) => {
            if (!event.defaultPrevented && this.props.visible) {
                switch (event.keyCode) {
                    case keyCodeEscape:
                        this.checkForSoftDismiss(event);
                        break;
                    case keyCodeTab:
                        this.handleTabKeyDown(event);
                        break;
                }
            }
        };
        /**
         * Invokes dialog soft dismiss if appropriate
         */
        this.checkForSoftDismiss = (event) => {
            if (this.props.onDismiss &&
                typeof this.props.onDismiss === "function" &&
                this.props.visible) {
                this.props.onDismiss(event);
            }
        };
        /**
         * process tab key down events
         */
        this.handleTabKeyDown = (event) => {
            if (!this.props.modal) {
                // only handle tab keystrokes when modal
                return;
            }
            const tabbableElements = Tabbable(this.rootElement.current);
            const tabbableElementCount = tabbableElements.length;
            if (tabbableElementCount === 0) {
                this.tryFocusOnRootElement();
                event.preventDefault();
                return;
            }
            // intervene in normal tab order for first and last items in list
            if (event.shiftKey && event.target === tabbableElements[0]) {
                tabbableElements[tabbableElementCount - 1].focus();
                event.preventDefault();
            }
            else if (!event.shiftKey &&
                event.target === tabbableElements[tabbableElementCount - 1]) {
                tabbableElements[0].focus();
                event.preventDefault();
            }
        };
        /**
         * forces focus to first tabbable element of modal dialog if document gains focus while dialog is open
         */
        this.handleDocumentFocus = (event) => {
            if (!event.defaultPrevented &&
                this.shouldForceFocus(event.target)) {
                this.focusOnFirstElement();
                event.preventDefault();
            }
        };
        /**
         * test to avoid forcing focus when focus is already within
         */
        this.shouldForceFocus = (currentFocusElement) => {
            return (this.props.visible &&
                this.rootElement.current instanceof HTMLElement &&
                !this.rootElement.current.contains(currentFocusElement));
        };
        /**
         * focus on first element of tab queue
         */
        this.focusOnFirstElement = () => {
            if (canUseDOM() && this.rootElement.current instanceof HTMLElement) {
                const tabbableElements = Tabbable(this.rootElement.current);
                if (tabbableElements.length === 0) {
                    this.tryFocusOnRootElement();
                }
                else {
                    tabbableElements[0].focus();
                }
            }
        };
        /**
         * if no tabbable elements try to focus root element
         * generally a modal dialog should be expected to have a focusable element
         */
        this.tryFocusOnRootElement = () => {
            if (this.rootElement.current instanceof HTMLElement) {
                this.rootElement.current.focus();
            }
        };
    }
    /**
     * Renders the component
     */
    render() {
        const { dialog_positioningRegion, dialog_contentRegion, } = this.props.managedClasses;
        return (React.createElement("div", Object.assign({ ref: this.rootElement }, this.unhandledProps(), { className: this.generateClassNames(), "aria-hidden": !this.props.visible }),
            React.createElement("div", { className: classNames(dialog_positioningRegion) },
                this.renderModalOverlay(),
                React.createElement("div", { role: "dialog", tabIndex: -1, className: classNames(dialog_contentRegion), style: {
                        height: this.props.contentHeight,
                        width: this.props.contentWidth,
                    }, "aria-describedby": this.props.describedBy, "aria-labelledby": this.props.labelledBy, "aria-label": this.props.label }, this.props.children))));
    }
    /**
     * React life-cycle method
     */
    componentDidMount() {
        if (canUseDOM()) {
            if (this.shouldAddKeyListener(this.props)) {
                document.addEventListener("keydown", this.handleDocumentKeyDown);
            }
            if (this.props.modal) {
                document.addEventListener("focusin", this.handleDocumentFocus);
                if (this.shouldForceFocus(document.activeElement)) {
                    this.focusOnFirstElement();
                }
            }
        }
    }
    /**
     * React life-cycle method
     */
    componentDidUpdate(prevProps) {
        if (canUseDOM()) {
            if (!prevProps.modal && this.props.modal) {
                document.addEventListener("focusin", this.handleDocumentFocus);
                this.focusOnFirstElement();
            }
            else if (prevProps.modal && !this.props.modal) {
                document.removeEventListener("focusin", this.handleDocumentFocus);
            }
            if (!this.shouldAddKeyListener(prevProps) &&
                this.shouldAddKeyListener(this.props)) {
                document.addEventListener("keydown", this.handleDocumentKeyDown);
            }
            else if (this.shouldAddKeyListener(prevProps) &&
                !this.shouldAddKeyListener(this.props)) {
                document.removeEventListener("keydown", this.handleDocumentKeyDown);
            }
        }
    }
    /**
     * React life-cycle method
     */
    componentWillUnmount() {
        if (canUseDOM()) {
            if (this.shouldAddKeyListener(this.props)) {
                document.removeEventListener("keydown", this.handleDocumentKeyDown);
            }
            if (this.props.modal) {
                document.removeEventListener("focusin", this.handleDocumentFocus);
            }
        }
    }
    /**
     * Generates class names
     */
    generateClassNames() {
        return super.generateClassNames(classNames(this.props.managedClasses.dialog));
    }
    /**
     * Renders the modal overlay
     */
    renderModalOverlay() {
        if (!this.props.modal) {
            return;
        }
        return (React.createElement("div", { className: classNames(this.props.managedClasses.dialog_modalOverlay), onClick: this.checkForSoftDismiss, onTouchStart: this.checkForSoftDismiss, role: "presentation", tabIndex: -1, style: {
                touchAction: "none",
            } }));
    }
}
Dialog.defaultProps = {
    contentHeight: "480px",
    contentWidth: "640px",
    visible: false,
    managedClasses: {},
};
Dialog.displayName = `${DisplayNamePrefix}Dialog`;
export default Dialog;
