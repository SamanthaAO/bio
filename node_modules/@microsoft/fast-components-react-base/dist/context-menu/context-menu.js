import Foundation from "@microsoft/fast-components-foundation-react";
import { classNames, keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnd, keyCodeHome, } from "@microsoft/fast-web-utilities";
import { canUseDOM } from "exenv-es6";
import { inRange, invert } from "lodash-es";
import React from "react";
import { ContextMenuItemRole } from "../context-menu-item";
import { DisplayNamePrefix } from "../utilities";
class ContextMenu extends Foundation {
    constructor(props) {
        super(props);
        this.handledProps = {
            children: void 0,
            managedClasses: void 0,
            enableAutoFocus: void 0,
        };
        this.rootElement = React.createRef();
        /**
         * Render a single child
         */
        this.renderChild = (child, index) => {
            return React.cloneElement(child, {
                tabIndex: index === this.state.focusIndex ? 0 : -1,
                onFocus: this.handleMenuItemFocus,
            });
        };
        /**
         * Determines if a given element should be focusable by the menu
         */
        this.isFocusableElement = (element) => {
            return this.isMenuItemElement(element) && !this.isDisabledElement(element);
        };
        this.isDisabledElement = (element) => {
            return (this.isMenuItemElement(element) &&
                element.getAttribute("aria-disabled") === "true");
        };
        /**
         * Ensure we always validate our internal state on item focus events, otherwise
         * the component can get out of sync from click events
         */
        this.handleMenuItemFocus = (e) => {
            const target = e.currentTarget;
            const focusIndex = this.domChildren().indexOf(target);
            if (this.isDisabledElement(target)) {
                target.blur();
                return;
            }
            if (focusIndex !== this.state.focusIndex && focusIndex !== -1) {
                this.setFocus(focusIndex, focusIndex > this.state.focusIndex ? 1 : -1);
            }
        };
        /**
         * Handle the keydown event of the root menu
         */
        this.handleMenuKeyDown = (e) => {
            switch (e.keyCode) {
                case keyCodeArrowDown:
                case keyCodeArrowRight:
                    e.preventDefault();
                    this.setFocus(this.state.focusIndex + 1, 1);
                    break;
                case keyCodeArrowUp:
                case keyCodeArrowLeft:
                    e.preventDefault();
                    this.setFocus(this.state.focusIndex - 1, -1);
                    break;
                case keyCodeEnd:
                    e.preventDefault();
                    this.setFocus(this.domChildren().length - 1, -1);
                    break;
                case keyCodeHome:
                    e.preventDefault();
                    this.setFocus(0, 1);
                    break;
            }
            if (typeof this.props.onKeyDown === "function") {
                this.props.onKeyDown(e);
            }
        };
        this.handleContextMenu = (e) => {
            e.preventDefault(); // prevent browser context-menu becuase this *is* a context menu
            if (typeof this.props.onContextMenu === "function") {
                this.props.onContextMenu(e);
            }
        };
        this.state = {
            focusIndex: -1,
        };
    }
    /**
     * Renders the component
     */
    render() {
        return (React.createElement("div", Object.assign({}, this.unhandledProps(), { ref: this.rootElement, role: "menu", className: this.generateClassNames(), onKeyDown: this.handleMenuKeyDown, onContextMenu: this.handleContextMenu }), this.renderChildren()));
    }
    componentDidMount() {
        const children = this.domChildren();
        const focusIndex = children.findIndex(this.isFocusableElement);
        if (focusIndex !== -1) {
            this.setState({
                focusIndex,
            });
        }
        if (this.props.enableAutoFocus) {
            this.focus();
        }
    }
    /**
     * Brings focus to the appropriate menu-item
     */
    focus() {
        this.setFocus(this.state.focusIndex === -1 ? 0 : this.state.focusIndex, 1);
    }
    /**
     * Create class names
     */
    generateClassNames() {
        return super.generateClassNames(classNames(this.props.managedClasses.contextMenu));
    }
    /**
     * Render all child elements
     */
    renderChildren() {
        return React.Children.map(this.props.children, this.renderChild);
    }
    isMenuItemElement(element) {
        return (element instanceof HTMLElement &&
            ContextMenu.focusableElementRoles.hasOwnProperty(element.getAttribute("role")));
    }
    /**
     * Return an array of all focusabled elements that are children
     * of the context menu
     */
    domChildren() {
        return canUseDOM() && this.rootElement.current instanceof HTMLElement
            ? Array.from(this.rootElement.current.children)
            : [];
    }
    /**
     * Sets focus to the nearest focusable element to the supplied focusIndex.
     * The adjustment controls how the function searches for other focusable elements
     * if the element at the focusIndex is not focusable. A positive number will search
     * towards the end of the children array, whereas a negative number will search towards
     * the beginning of the children array.
     */
    setFocus(focusIndex, adjustment) {
        const children = this.domChildren();
        while (inRange(focusIndex, children.length)) {
            const child = children[focusIndex];
            if (this.isFocusableElement(child)) {
                child.focus();
                this.setState({
                    focusIndex,
                });
                break;
            }
            focusIndex += adjustment;
        }
    }
}
ContextMenu.displayName = `${DisplayNamePrefix}ContextMenu`;
ContextMenu.defaultProps = {
    managedClasses: {},
};
ContextMenu.focusableElementRoles = invert(ContextMenuItemRole);
export default ContextMenu;
