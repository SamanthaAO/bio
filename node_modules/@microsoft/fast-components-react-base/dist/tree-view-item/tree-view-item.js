import React from "react";
import Foundation from "@microsoft/fast-components-foundation-react";
import { classNames, keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnter, keyCodeSpace, } from "@microsoft/fast-web-utilities";
import { getDisplayedNodes, isHTMLElement } from "@microsoft/fast-web-utilities";
import { canUseDOM } from "exenv-es6";
import { TreeViewContext } from "../tree-view/tree-view";
import { DisplayNamePrefix } from "../utilities";
class TreeViewItem extends Foundation {
    constructor(props) {
        super(props);
        this.handledProps = {
            dragConnect: void 0,
            expandCollapseGlyph: void 0,
            titleContent: void 0,
            children: void 0,
            managedClasses: void 0,
            selected: void 0,
            defaultExpanded: void 0,
            onExpandedChange: void 0,
            onSelected: void 0,
        };
        this.rootElement = React.createRef();
        this.expandCollapseButton = React.createRef();
        /**
         * Handles the focus event of the root element
         */
        this.handleFocus = (e) => {
            // Only change focusability if the event is on the node itself
            // and not a child node
            if (e.target === e.currentTarget) {
                this.setState({ focusable: true });
                // Notify the parent TreeView component that a new item has been focused,
                // and should tree this item as the last-focused item
                if (typeof this.context.setLastFocused === "function") {
                    this.context.setLastFocused(this.rootElement);
                }
            }
        };
        /**
         * Handles the blur event on the root element
         */
        this.handleBlur = (e) => {
            // Ignore the event if the event happened on a child node
            if (!canUseDOM() || e.target !== e.currentTarget) {
                return;
            }
            this.setState({ focusable: false });
        };
        /**
         * handles the keydown event of the tree view item
         */
        this.handleKeyDown = (e) => {
            if (e.target !== e.currentTarget) {
                return;
            }
            switch (e.keyCode) {
                case keyCodeArrowLeft:
                    this.handleArrowLeft();
                    break;
                case keyCodeArrowRight:
                    this.handleArrowRight();
                    break;
                case keyCodeArrowDown:
                    // Prevent scrolling
                    e.preventDefault();
                    this.focusNextNode(1);
                    break;
                case keyCodeArrowUp:
                    // Prevent scrolling
                    e.preventDefault();
                    this.focusNextNode(-1);
                    break;
                case keyCodeEnter:
                    this.handleSelected(e);
                    break;
                case keyCodeSpace:
                    this.handleSpaceBar();
                    break;
            }
        };
        /**
         * Click handler for expand/collapse button
         */
        this.handleExpandCollapseButtonClick = () => {
            this.setExpanded(!this.state.expanded);
        };
        /**
         * Call the onSelected callback if it exists
         */
        this.handleSelected = (e) => {
            if (typeof this.props.onSelected === "function") {
                this.props.onSelected(this.props, e);
            }
        };
        /**
         * Handles the click event of the tree view item, except for the expand/collapse button
         */
        this.handleContentContainerClick = (e) => {
            const expandButton = this.expandCollapseButton.current;
            if (!isHTMLElement(expandButton) ||
                (isHTMLElement(expandButton) && expandButton !== e.target)) {
                this.handleSelected(e);
            }
        };
        this.state = {
            focusable: false,
            expanded: this.hasChildNodes() ? this.props.defaultExpanded : undefined,
        };
    }
    componentDidMount() {
        if (this.hasChildNodes()) {
            this.adjustNestedTreeItemCount(1);
            if (this.hasSelectedChild() && !this.state.expanded) {
                this.setExpanded(true);
            }
        }
    }
    componentDidUpdate(prevProps) {
        // if we become selected, call the selected callback
        if (this.props.selected && !prevProps.selected) {
            this.handleSelected();
        }
        const hadChildNodes = this.hasChildNodes(prevProps);
        const hasChildNodes = this.hasChildNodes();
        if (hasChildNodes && !hadChildNodes) {
            // if defaultExpanded is false and a child node is selected, set expanded (triggers callback)
            // if not, set expanded state to this.props.defaultExpanded
            this.props.defaultExpanded === false && this.hasSelectedChild()
                ? this.setExpanded(true)
                : this.setState({ expanded: this.props.defaultExpanded });
            this.adjustNestedTreeItemCount(1);
        }
        else if (hadChildNodes && !hasChildNodes) {
            this.adjustNestedTreeItemCount(-1);
        }
    }
    componentWillUnmount() {
        if (this.hasChildNodes()) {
            this.adjustNestedTreeItemCount(-1);
        }
    }
    render() {
        return (React.createElement("div", Object.assign({}, this.unhandledProps(), { role: "treeitem", "aria-expanded": this.state.expanded, "aria-selected": !!this.props.selected, tabIndex: this.state.focusable ? 0 : -1, className: this.generateClassNames(), onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown, ref: this.rootElement }),
            this.renderItem(),
            this.renderChildNodes()));
    }
    generateClassNames() {
        const { treeViewItem, treeViewItem__expanded, treeViewItem__nested, treeViewItem__selected, } = this.props.managedClasses;
        return super.generateClassNames(classNames(treeViewItem, [treeViewItem__expanded, this.state.expanded], [treeViewItem__nested, this.context.nested], [treeViewItem__selected, this.props.selected]));
    }
    renderItem() {
        const { treeViewItem_contentRegion, treeViewItem_innerContentRegion, } = this.props.managedClasses;
        const node = (React.createElement("div", { className: classNames(treeViewItem_contentRegion), onClick: this.handleContentContainerClick },
            React.createElement("div", { className: classNames(treeViewItem_innerContentRegion) },
                this.renderExpandCollapseButton(),
                this.props.titleContent)));
        return typeof this.props.dragConnect === "function"
            ? this.props.dragConnect(node)
            : node;
    }
    adjustNestedTreeItemCount(count) {
        if (typeof this.context.adjustNestedTreeItemCount === "function") {
            this.context.adjustNestedTreeItemCount(count);
        }
    }
    /**
     * Determines if the item has sub-items and should be collapse/expandable
     */
    hasChildNodes(props = this.props) {
        return !!props.children;
    }
    /**
     * Determines if the item has sub-items which are selected
     */
    hasSelectedChild() {
        const currentNode = this.rootElement.current;
        if (!isHTMLElement(currentNode) || !canUseDOM()) {
            return null;
        }
        return !!currentNode.querySelector("[aria-selected='true'");
    }
    /**
     * Handles when the left arrow is pressed
     */
    handleArrowLeft() {
        if (this.state.expanded) {
            this.setExpanded(false);
        }
        else if (canUseDOM() &&
            isHTMLElement(this.rootElement.current) &&
            isHTMLElement(this.rootElement.current.parentElement)) {
            const parentElement = this.rootElement.current.parentElement;
            if (isHTMLElement(parentElement)) {
                const parentNode = parentElement.closest("[role='treeitem']");
                if (isHTMLElement(parentNode)) {
                    parentNode.focus();
                }
            }
        }
    }
    /**
     * Handles when the space bar is pressed
     */
    handleSpaceBar() {
        if (typeof this.state.expanded !== "boolean") {
            return;
        }
        this.setExpanded(!this.state.expanded);
    }
    /**
     * Handles when the right arrow is pressed
     */
    handleArrowRight() {
        if (typeof this.state.expanded !== "boolean") {
            return;
        }
        if (!this.state.expanded) {
            this.setExpanded(true);
        }
        else {
            this.focusNextNode(1);
        }
    }
    focusNextNode(delta) {
        if (!canUseDOM()) {
            return;
        }
        const visibleNodes = this.getVisibleNodes();
        if (!visibleNodes) {
            return;
        }
        const currentIndex = visibleNodes.indexOf(this.rootElement.current);
        if (currentIndex !== -1) {
            const nextElement = visibleNodes[currentIndex + delta];
            if (isHTMLElement(nextElement)) {
                nextElement.focus();
            }
        }
    }
    /**
     * Returns an array of all tree item nodes that are
     * currently visible (not hidden under a collapsed node)
     */
    getVisibleNodes() {
        return canUseDOM()
            ? getDisplayedNodes(this.getTreeRoot(), "[role='treeitem']")
            : [];
    }
    /**
     * Get the root element of the tree. This will always be the
     * closest element with [role='tree']
     */
    getTreeRoot() {
        const currentNode = this.rootElement.current;
        if (!isHTMLElement(currentNode) || !canUseDOM()) {
            return null;
        }
        return currentNode.closest("[role='tree']");
    }
    wrapChildOnSelected(childOnSelected) {
        return (props, e) => {
            if (childOnSelected) {
                childOnSelected(props, e);
            }
            this.setExpanded(true);
        };
    }
    wrapChildOnExpandedChange(childOnExpandedChange) {
        return (childExpanded, childProps) => {
            if (childOnExpandedChange) {
                childOnExpandedChange(childExpanded, childProps);
            }
            if (childExpanded) {
                this.setExpanded(true);
            }
        };
    }
    renderChildNodes() {
        return this.hasChildNodes() ? (React.createElement("div", { role: "group", className: classNames(this.props.managedClasses.treeViewItem_childNodeRegion) }, React.Children.map(this.props.children, (child) => {
            if (!React.isValidElement(child) || !child.props) {
                return child;
            }
            return React.cloneElement(child, Object.assign({}, child.props, { onSelected: this.wrapChildOnSelected(child.props.onSelected), onExpandedChange: this.wrapChildOnExpandedChange(child.props.onExpandedChange) }));
        }))) : null;
    }
    renderExpandCollapseButton() {
        const { treeViewItem_expandCollapseButton, treeViewItem_expandCollapseGlyph, } = this.props.managedClasses;
        return this.hasChildNodes() ? (
        // This really should render a button but Narrator sometimes still brings it focus
        // in scan-mode, so making this a div
        React.createElement("div", { "aria-hidden": true, className: classNames(treeViewItem_expandCollapseButton), onClick: this.handleExpandCollapseButtonClick, ref: this.expandCollapseButton }, typeof this.props.expandCollapseGlyph === "function"
            ? this.props.expandCollapseGlyph(treeViewItem_expandCollapseGlyph)
            : null)) : null;
    }
    /**
     * Sets the expanded state of the component if necessary and
     * notifies listeners of the state change.
     */
    setExpanded(expanded) {
        if (this.hasChildNodes()) {
            this.setState({
                expanded,
            }, () => {
                if (typeof this.props.onExpandedChange === "function") {
                    this.props.onExpandedChange(expanded, this.props);
                }
            });
        }
    }
}
TreeViewItem.displayName = `${DisplayNamePrefix}TreeViewItem`;
TreeViewItem.defaultProps = {
    defaultExpanded: false,
    managedClasses: {},
};
TreeViewItem.contextType = TreeViewContext;
export default TreeViewItem;
