import React from "react";
import Foundation from "@microsoft/fast-components-foundation-react";
import { classNames, getDisplayedNodes, isHTMLElement, keyCodeEnd, keyCodeHome, } from "@microsoft/fast-web-utilities";
import { canUseDOM } from "exenv-es6";
import { DisplayNamePrefix } from "../utilities";
export const TreeViewContext = React.createContext({
    setLastFocused: null,
    adjustNestedTreeItemCount: null,
    nested: false,
});
/**
 * Simple state machine to track how many nodes have nested nodes
 */
class ChildNodeCountTracker {
    constructor() {
        this._count = 0;
    }
    get count() {
        return this._count;
    }
    adjust(delta) {
        this._count += delta;
    }
}
/* tslint:disable-next-line */
class TreeView extends Foundation {
    constructor(props) {
        super(props);
        this.handledProps = {
            managedClasses: void 0,
            children: void 0,
        };
        this.rootElement = React.createRef();
        /**
         * Track how many tree-items have children
         */
        this.nestedTreeItemTracker = new ChildNodeCountTracker();
        this.setLastFocused = (ref) => {
            this.setState({
                lastFocused: ref,
            });
        };
        this.adjustNestedTreeItemCount = (delta) => {
            this.nestedTreeItemTracker.adjust(delta);
            if (this.nestedTreeItemTracker.count > 0 && !this.state.nested) {
                this.setState({ nested: true });
            }
            else if (this.nestedTreeItemTracker.count === 0 && this.state.nested) {
                this.setState({ nested: false });
            }
        };
        this.handleBlur = (e) => {
            const root = this.rootElement.current;
            /**
             * If we focus outside of the tree
             */
            if (isHTMLElement(root) && !root.contains(e.relatedTarget)) {
                this.setState({
                    focusable: true,
                });
            }
        };
        this.handleFocus = (e) => {
            if (!canUseDOM() || !isHTMLElement(this.rootElement.current)) {
                return;
            }
            const root = this.rootElement.current;
            const lastFocused = this.state
                .lastFocused;
            /**
             * If the tree view is receiving focus
             */
            if (isHTMLElement(root) && root === e.target) {
                // If we have a last focused item, focus it - otherwise check for an initially selected item or focus the first "[role='treeitem']"
                // If there is no "[role='treeitem']" to be focused AND no last-focused, then there are likely no children
                // or children are malformed so keep the tree in the tab-order in the hopes that the author cleans up
                // the children
                const selectedChild = root.querySelector("[aria-selected='true']");
                const toBeFocused = !!lastFocused
                    ? lastFocused.current
                    : !!selectedChild
                        ? selectedChild
                        : root.querySelector("[role='treeitem']");
                if (isHTMLElement(toBeFocused)) {
                    toBeFocused.focus();
                    if (this.state.focusable) {
                        this.setState({ focusable: false });
                    }
                }
            }
            else {
                // A child is receiving focus. While focus is within the tree, we simply need to ensure
                // that the tree is not focusable.
                if (this.state.focusable) {
                    this.setState({
                        focusable: false,
                    });
                }
            }
        };
        this.handleKeyDown = (e) => {
            let nodes;
            if (canUseDOM()) {
                switch (e.keyCode) {
                    case keyCodeHome:
                        nodes = this.getVisibleNodes();
                        if (nodes && nodes.length) {
                            nodes[0].focus();
                        }
                        break;
                    case keyCodeEnd:
                        nodes = this.getVisibleNodes();
                        if (nodes && nodes.length) {
                            nodes[nodes.length - 1].focus();
                        }
                        break;
                }
            }
        };
        this.state = {
            focusable: true,
            lastFocused: null,
            nested: false,
        };
    }
    render() {
        return (React.createElement("div", Object.assign({}, this.unhandledProps(), { role: "tree", tabIndex: this.state.focusable ? 0 : -1, className: this.generateClassNames(), ref: this.rootElement, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown }),
            React.createElement(TreeViewContext.Provider, { value: {
                    setLastFocused: this.setLastFocused,
                    adjustNestedTreeItemCount: this.adjustNestedTreeItemCount,
                    nested: this.state.nested,
                } }, this.props.children)));
    }
    componentDidUpdate() {
        this.ensureFocusability();
    }
    generateClassNames() {
        return super.generateClassNames(classNames(this.props.managedClasses.treeView));
    }
    /**
     * Verifies that the tree has a focusable child.
     * If it does not, the tree will begin to accept focus
     */
    ensureFocusability() {
        if (canUseDOM() &&
            !this.state.focusable &&
            isHTMLElement(this.rootElement.current)) {
            const focusableChild = this.rootElement.current.querySelector("[role='treeitem'][tabindex='0']");
            if (!isHTMLElement(focusableChild)) {
                this.setState({
                    focusable: true,
                });
            }
        }
    }
    getVisibleNodes() {
        return canUseDOM()
            ? getDisplayedNodes(this.rootElement.current, "[role='treeitem']")
            : [];
    }
}
TreeView.displayName = `${DisplayNamePrefix}TreeView`;
TreeView.defaultProps = {
    managedClasses: {},
};
export default TreeView;
