import Foundation from "@microsoft/fast-components-foundation-react";
import { classNames, keyCodeArrowDown, keyCodeArrowUp, keyCodeEnter, keyCodeEscape, keyCodeTab, } from "@microsoft/fast-web-utilities";
import React from "react";
import { Listbox, TextField, TextFieldType } from "../index";
import { DisplayNamePrefix } from "../utilities";
import { AutoSuggestContext } from "./auto-suggest-context";
import { isNil } from "lodash-es";
class AutoSuggest extends Foundation {
    /**
     * constructor
     */
    constructor(props) {
        super(props);
        /**
         * Handled props instantiation
         */
        this.handledProps = {
            isMenuOpen: void 0,
            disabled: void 0,
            label: void 0,
            inputRegion: void 0,
            managedClasses: void 0,
            initialValue: void 0,
            value: void 0,
            onValueChange: void 0,
            onInvoked: void 0,
            placeholder: void 0,
            listboxId: void 0,
            filterSuggestions: void 0,
        };
        this.rootElement = React.createRef();
        this.shouldFocusMenuOnNextRender = false;
        /**
         * The default function that renders an unstyled content display
         */
        this.defaultInputRegionRenderFunction = (props, state, onChange, onClick, onKeyDown) => {
            const listboxId = state.isMenuOpen ? props.listboxId : null;
            const activedescendantId = state.focusedItem !== null ? state.focusedItem.id : null;
            return (React.createElement(TextField, { disabled: props.disabled, onChange: onChange, onClick: onClick, onKeyDown: onKeyDown, value: state.value, type: TextFieldType.text, role: "combobox", "aria-label": props.label || null, "aria-autocomplete": "both", "aria-activedescendant": activedescendantId || null, "aria-owns": listboxId || null, "aria-controls": listboxId || null }));
        };
        /**
         * Updates selection state and associated values
         */
        this.updateFocusedItem = (newSelection) => {
            if (newSelection.length === 0) {
                this.setState({
                    focusedItem: null,
                });
            }
            else {
                this.setState({
                    focusedItem: newSelection[0],
                });
                this.updateValue(newSelection[0].value, true);
            }
        };
        /**
         * Handles clicks
         */
        this.handleInputRegionClick = (e) => {
            if (this.props.disabled || e.defaultPrevented) {
                return;
            }
            this.toggleMenu(true);
        };
        /**
         * Handles item invoked
         */
        this.handleItemInvoked = (item) => {
            this.invoke(item.value, item);
            this.storedValueString = this.state.value;
            this.toggleMenu(false);
        };
        /**
         * Invokes the auto-select component
         */
        this.invoke = (value, item) => {
            if (typeof this.props.onInvoked === "function") {
                this.props.onInvoked(value, item);
            }
        };
        /**
         * Handles value changes from input element
         */
        this.handleChange = (e) => {
            const newValue = e.target.value;
            this.storedValueString = newValue;
            this.updateValue(newValue, false);
        };
        /**
         * Update the currentValue of the component
         */
        this.updateValue = (newValue, isFromSuggestedOption) => {
            if (typeof this.props.onValueChange === "function") {
                this.props.onValueChange(newValue, isFromSuggestedOption);
            }
            if (isNil(this.props.value) && newValue !== this.state.value) {
                this.toggleMenu(true);
                this.setState({
                    value: newValue,
                });
            }
        };
        /**
         * Handles input region key events
         */
        this.handleInputRegionKeydown = (e) => {
            if (this.props.disabled || e.defaultPrevented) {
                return;
            }
            switch (e.keyCode) {
                case keyCodeEnter:
                    this.invoke(this.state.value, null);
                    break;
                case keyCodeEscape:
                    this.toggleMenu(false);
                    break;
                case keyCodeArrowDown:
                    this.focusOnMenu(1);
                    e.preventDefault();
                    break;
                case keyCodeArrowUp:
                    this.focusOnMenu(-1);
                    e.preventDefault();
                    break;
                case keyCodeTab:
                    // Prevent default case handling for tab
                    break;
                default:
                    if (e.target instanceof HTMLInputElement) {
                        const newValue = e.target.value;
                        this.updateValue(newValue, false);
                        this.focusOnInput();
                        break;
                    }
            }
        };
        /**
         * Handles menu key events
         */
        this.handleMenuKeydown = (e) => {
            if (this.props.disabled || e.defaultPrevented) {
                return;
            }
            switch (e.keyCode) {
                case keyCodeEscape:
                    this.toggleMenu(false);
                    break;
                case keyCodeArrowDown:
                    if (this.checkForMenuEnd(1) === true) {
                        e.preventDefault();
                    }
                    break;
                case keyCodeArrowUp:
                    if (this.checkForMenuEnd(-1) === true) {
                        e.preventDefault();
                    }
                    break;
                default:
                    if (this.isValidInput(e)) {
                        this.focusOnInput();
                    }
                    break;
            }
        };
        /**
         * test if a key press is a valid input
         */
        this.isValidInput = (e) => {
            if (e.keyCode < 8 ||
                (e.keyCode > 8 && e.keyCode < 48) ||
                (e.keyCode > 90 && e.keyCode < 96) ||
                (e.keyCode > 111 && e.keyCode < 186) ||
                e.keyCode > 222) {
                return false;
            }
            return true;
        };
        /**
         * Passes focus to the input element if focus would bump up against the ends of the menu,
         * return true if result was focusing on input region
         */
        this.checkForMenuEnd = (increment) => {
            if (this.state.focusedItem === null) {
                return false;
            }
            const childrenAsArray = React.Children.toArray(this.renderChildren());
            const currentItemIndex = Listbox.getItemIndexById(this.state.focusedItem.id, this.renderChildren());
            const startIndex = currentItemIndex + increment;
            if (startIndex > childrenAsArray.length - 1 || startIndex < 0) {
                this.setState({
                    value: this.storedValueString,
                });
                // at the end of the list, focus on input
                this.focusOnInput();
                return true;
            }
            const endIndex = increment > -1 ? childrenAsArray.length - 1 : 0;
            const nextFocusableItem = Listbox.getFirstValidOptionInRange(startIndex, endIndex, childrenAsArray, increment).props;
            if (nextFocusableItem === null ||
                nextFocusableItem.id === this.state.focusedItem.id) {
                this.setState({
                    value: this.storedValueString,
                });
                // at the end of the list, focus on input
                this.focusOnInput();
                return true;
            }
            return false;
        };
        /**
         * Opens menu and focuses on first or last valid item
         */
        this.focusOnMenu = (increment) => {
            this.storedValueString = this.state.value;
            const childrenAsArray = React.Children.toArray(this.renderChildren());
            if (childrenAsArray.length === 0) {
                return;
            }
            const startIndex = increment > -1 ? 0 : childrenAsArray.length - 1;
            const endIndex = increment > -1 ? childrenAsArray.length - 1 : 0;
            this.focusFirstItemInRange(startIndex, endIndex, childrenAsArray, increment);
            this.toggleMenu(true);
            this.shouldFocusMenuOnNextRender = true;
        };
        /**
         * Gets first child in a range
         */
        this.focusFirstItemInRange = (startIndex, endIndex, childrenAsArray, increment) => {
            const validOption = Listbox.getFirstValidOptionInRange(startIndex, endIndex, childrenAsArray, increment);
            if (validOption !== null) {
                this.updateFocusedItem([validOption.props]);
            }
        };
        /**
         * Toggles the menu
         */
        this.toggleMenu = (desiredMenuState) => {
            const updatedIsMenuOpen = this.validateMenuState(desiredMenuState);
            if (updatedIsMenuOpen !== this.state.isMenuOpen) {
                this.setState({
                    isMenuOpen: updatedIsMenuOpen,
                });
                if (this.state.isMenuOpen && !updatedIsMenuOpen) {
                    this.setState({
                        value: this.storedValueString,
                    });
                    this.focusOnInput();
                }
            }
        };
        /**
         * Focus on the input element
         */
        this.focusOnInput = () => {
            if (this.rootElement.current === null) {
                return;
            }
            const inputElements = this.rootElement.current.getElementsByTagName("input");
            if (inputElements.length > 0) {
                inputElements[0].focus();
            }
            this.updateFocusedItem([]);
        };
        /**
         * Determine menu state by comparing desired state to props
         */
        this.validateMenuState = (desiredMenuState) => {
            return typeof this.props.isMenuOpen === "boolean"
                ? this.props.isMenuOpen
                : React.Children.count(this.renderChildren()) === 0
                    ? false
                    : desiredMenuState;
        };
        /**
         * Close the menu when when there are clicks outside
         */
        this.handleWindowClick = (event) => {
            if (this.state.isMenuOpen &&
                this.rootElement.current !== null &&
                !this.rootElement.current.contains(event.target)) {
                this.toggleMenu(false);
            }
        };
        const value = this.props.value === undefined ? this.props.initialValue : this.props.value;
        this.state = {
            value,
            focusedItem: null,
            isMenuOpen: this.validateMenuState(false),
        };
        this.storedValueString = value;
    }
    componentDidUpdate(prevProps) {
        const updatedMenuVisibility = this.validateMenuState(this.state.isMenuOpen);
        if (updatedMenuVisibility !== this.state.isMenuOpen) {
            this.toggleMenu(updatedMenuVisibility);
        }
        if (this.props.value !== prevProps.value) {
            this.setState({
                value: this.props.value,
            });
        }
    }
    componentDidMount() {
        window.addEventListener("click", this.handleWindowClick);
    }
    componentWillUnmount() {
        window.removeEventListener("click", this.handleWindowClick);
    }
    /**
     * Renders the component
     */
    render() {
        return (React.createElement("div", Object.assign({}, this.unhandledProps(), { ref: this.rootElement, className: this.generateClassNames() }),
            React.createElement(AutoSuggestContext.Provider, { value: {
                    currentValue: this.storedValueString,
                } },
                this.renderInputRegion(),
                this.renderMenu())));
    }
    /**
     * Create class names
     */
    generateClassNames() {
        const { autoSuggest, autoSuggest__disabled, autoSuggest__menuOpen, } = this.props.managedClasses;
        return super.generateClassNames(classNames(autoSuggest, [autoSuggest__disabled, this.props.disabled], [autoSuggest__menuOpen, this.state.isMenuOpen]));
    }
    /**
     * Determine which function to use to render content display (ie. the part of the control that shows when the menu isn't open)
     * and invokes it
     */
    renderInputRegion() {
        if (typeof this.props.inputRegion === "function") {
            return this.props.inputRegion(this.props, this.state, this.handleChange, this.handleInputRegionClick, this.handleInputRegionKeydown);
        }
        else {
            return this.defaultInputRegionRenderFunction(this.props, this.state, this.handleChange, this.handleInputRegionClick, this.handleInputRegionKeydown);
        }
    }
    /**
     * Determine which function to use to render the menu and invokes it
     */
    renderMenu() {
        const shouldFocusOnMenu = this.shouldFocusMenuOnNextRender;
        const { autoSuggest_menu, autoSuggest__disabled, } = this.props.managedClasses;
        this.shouldFocusMenuOnNextRender = false;
        if (!this.state.isMenuOpen) {
            return;
        }
        const focusedItem = this.state.focusedItem !== null ? [this.state.focusedItem] : [];
        return (React.createElement(Listbox, { id: this.props.listboxId, typeAheadEnabled: false, disabled: this.props.disabled, focusItemOnMount: shouldFocusOnMenu, defaultSelection: focusedItem, onSelectedItemsChanged: this.updateFocusedItem, onItemInvoked: this.handleItemInvoked, onKeyDown: this.handleMenuKeydown, managedClasses: {
                listbox: autoSuggest_menu,
                listbox__disabled: autoSuggest__disabled,
            } }, this.renderChildren()));
    }
    renderChildren() {
        if (this.props.filterSuggestions) {
            const children = this.props.children;
            return React.Children.map(children, (node) => {
                if (!isNil(node.props)) {
                    if (node.props[AutoSuggest.valuePropertyKey] === undefined) {
                        return node;
                    }
                    return this.isMatch(node.props) ? node : null;
                }
            });
        }
        else {
            return this.props.children;
        }
    }
    /**
     * Determine if a single node is a match
     */
    isMatch(node) {
        if (!isNil(this.storedValueString)) {
            return node.value
                .toLowerCase()
                .includes(this.storedValueString.toLowerCase());
        }
    }
}
AutoSuggest.displayName = `${DisplayNamePrefix}AutoSuggest`;
AutoSuggest.defaultProps = {
    initialValue: "",
    disabled: false,
    placeholder: "",
    managedClasses: {},
    filterSuggestions: false,
};
AutoSuggest.valuePropertyKey = "value";
export default AutoSuggest;
export { AutoSuggestContext };
