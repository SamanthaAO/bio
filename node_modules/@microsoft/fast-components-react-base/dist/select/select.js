import Foundation from "@microsoft/fast-components-foundation-react";
import { classNames, keyCodeArrowDown, keyCodeArrowLeft, keyCodeArrowRight, keyCodeArrowUp, keyCodeEnter, keyCodeEscape, keyCodeSpace, } from "@microsoft/fast-web-utilities";
import { canUseDOM } from "exenv-es6";
import { get, isEqual, isNil, uniqueId } from "lodash-es";
import React from "react";
import Listbox from "../listbox";
import { DisplayNamePrefix } from "../utilities";
import ViewportPositioner from "../viewport-positioner";
class Select extends Foundation {
    /**
     * constructor
     */
    constructor(props) {
        super(props);
        /**
         * Handled props instantiation
         */
        this.handledProps = {
            isMenuOpen: void 0,
            disabled: void 0,
            displayStringFormatter: void 0,
            form: void 0,
            labelledBy: void 0,
            multiselectable: void 0,
            trigger: void 0,
            menu: void 0,
            required: void 0,
            managedClasses: void 0,
            selectedItems: void 0,
            defaultSelection: void 0,
            onValueChange: void 0,
            placeholder: void 0,
            autoFocus: void 0,
            menuFlyoutConfig: void 0,
            onMenuSelectionChange: void 0,
        };
        this.rootElement = React.createRef();
        this.triggerId = uniqueId(Select.triggerUniqueIdPrefix);
        /**
         * Determine menu state based on props
         */
        this.checkPropsForMenuState = () => {
            let shouldMenuBeOpen = false;
            if (this.props.isMenuOpen !== undefined) {
                shouldMenuBeOpen = this.props.isMenuOpen;
            }
            else if (this.props.multiselectable === true) {
                shouldMenuBeOpen = true;
            }
            return shouldMenuBeOpen;
        };
        /**
         * This exists only to suppress a build warning
         */
        this.onSelectValueChange = (event) => {
            return null;
        };
        /**
         * Handles selection changes from menu
         */
        this.menuSelectionChange = (newSelection) => {
            if (typeof this.props.onMenuSelectionChange === "function") {
                this.props.onMenuSelectionChange(newSelection);
            }
            this.updateSelection(newSelection);
        };
        /**
         * Updates selection state and associated values
         */
        this.updateSelection = (newSelection) => {
            newSelection = this.trimSelection(newSelection);
            const newValue = this.getValueFromSelection(newSelection);
            if (this.state.value === newValue) {
                // no change, abort
                return;
            }
            const newDisplayString = this.getFormattedDisplayString(newSelection);
            if (typeof this.props.onValueChange === "function" &&
                !isEqual(newSelection, this.state.selectedItems)) {
                this.props.onValueChange(newValue, newSelection, newDisplayString);
            }
            if (this.props.selectedItems === undefined) {
                const validOptions = this.getValidOptions();
                this.setState({
                    selectedItems: newSelection,
                    value: newValue,
                    displayString: newDisplayString,
                    selectedItemIndex: this.getSelectedItemPosInSet(validOptions, newSelection),
                    selectableItemCount: validOptions.length,
                });
            }
        };
        /**
         * Updates selection state and associated values from props
         */
        this.updateSelectionFromProps = () => {
            const controlledSelection = this.trimSelection(Listbox.getListboxItemDataFromIds(this.props.selectedItems, this.props.children));
            this.setState({
                selectedItems: controlledSelection,
                value: this.getValueFromSelection(controlledSelection),
                displayString: this.getFormattedDisplayString(controlledSelection),
            });
        };
        /**
         * Trims the selection for single item mode
         */
        this.trimSelection = (selection) => {
            return this.props.multiselectable === false && selection.length > 1
                ? [this.state.selectedItems[0]]
                : selection;
        };
        /**
         * Extracts values in the correct format (string in single select and string[] in multi-select) from an array of items.
         */
        this.getValueFromSelection = (newSelection) => {
            if (this.props.multiselectable) {
                return newSelection.map((thisItem) => {
                    return thisItem.value;
                });
            }
            else {
                if (newSelection.length === 0) {
                    return "";
                }
                return newSelection[0].value;
            }
        };
        /**
         * get the index of the provided selection
         * (excludes children that aren't valid options)
         */
        this.getSelectedItemPosInSet = (options, selection) => {
            if (!this.props.multiselectable && selection.length === 1) {
                const selectionId = selection[0].id;
                const optionCount = options.length;
                for (let i = 0; i < optionCount; i++) {
                    if (options[i].props[Select.idPropertyKey] === selectionId) {
                        return i + 1;
                    }
                }
            }
            return 0;
        };
        /**
         * The default function that renders an unstyled content display
         */
        this.defaultTriggerRenderFunction = (props, state, triggerId) => {
            if (props.multiselectable) {
                return null;
            }
            const labelledBy = `${this.props.labelledBy} ${triggerId}`;
            return (React.createElement("button", { disabled: props.disabled, id: triggerId, "aria-haspopup": "listbox", "aria-labelledby": labelledBy, "aria-expanded": state.isMenuOpen, "aria-live": "polite" }, state.displayString));
        };
        /**
         * The default function that formats the display string generated based on selection.
         * This implementation should match the default formatting a base html select control applies.
         * Developers can provide an alternate formatter if desired.
         */
        this.defaultDisplayStringFormatter = (selectedOptions, placeholder) => {
            const optionValues = selectedOptions.map((selectedOption) => {
                return selectedOption.displayString || selectedOption.value;
            });
            return selectedOptions.length > 0 ? optionValues.join(", ") : placeholder;
        };
        /**
         * Handles clicks
         */
        this.handleClick = (e) => {
            if (this.props.disabled || e.defaultPrevented) {
                return;
            }
            this.toggleMenu(!this.state.isMenuOpen);
        };
        /**
         * Handles key events
         */
        this.handleKeydown = (e) => {
            if (this.props.disabled || e.defaultPrevented) {
                return;
            }
            switch (e.keyCode) {
                case keyCodeEnter:
                case keyCodeSpace:
                    // preventing default here because when we change focus to the trigger the keydown event gets
                    // emitted from the button again which otherwise toggles the menu a second time on a single key press
                    e.preventDefault();
                    this.toggleMenu(!this.state.isMenuOpen);
                    if (this.validateMenuState(!this.state.isMenuOpen) === false) {
                        this.focusTriggerElement();
                    }
                    break;
                case keyCodeEscape:
                    e.preventDefault();
                    this.toggleMenu(false);
                    this.focusTriggerElement();
                    break;
                case keyCodeArrowDown:
                case keyCodeArrowRight:
                    e.preventDefault();
                    if (!this.props.multiselectable && !this.state.isMenuOpen) {
                        this.incrementSelectedOption(+1);
                    }
                    break;
                case keyCodeArrowUp:
                case keyCodeArrowLeft:
                    e.preventDefault();
                    if (!this.props.multiselectable && !this.state.isMenuOpen) {
                        this.incrementSelectedOption(-1);
                    }
                    break;
            }
        };
        /**
         * Increment selection
         */
        this.incrementSelectedOption = (increment) => {
            const childrenAsArray = React.Children.toArray(this.props.children);
            if (this.state.selectedItems.length === 1) {
                const selectedItemIndex = Listbox.getItemIndexById(this.state.selectedItems[0].id, this.props.children);
                if (selectedItemIndex !== -1) {
                    const startIndex = selectedItemIndex + increment;
                    const endIndex = increment > -1 ? childrenAsArray.length - 1 : 0;
                    this.selectItemInRange(startIndex, endIndex, childrenAsArray, increment);
                }
            }
            else {
                const isLastChild = increment > -1;
                const lastChildIndex = childrenAsArray.length - 1;
                this.selectItemInRange(isLastChild ? 0 : lastChildIndex, isLastChild ? lastChildIndex : 0, childrenAsArray, increment);
            }
        };
        /**
         * Select a child in a range
         */
        this.selectItemInRange = (startIndex, endIndex, childrenAsArray, increment) => {
            const validOption = Listbox.getFirstValidOptionInRange(startIndex, endIndex, childrenAsArray, increment);
            if (!isNil(validOption)) {
                this.updateSelection([validOption.props]);
            }
        };
        /**
         * Toggles the menu
         */
        this.toggleMenu = (desiredMenuState) => {
            const updatedIsMenuOpen = this.validateMenuState(desiredMenuState);
            if (updatedIsMenuOpen !== this.state.isMenuOpen) {
                this.setState({
                    isMenuOpen: updatedIsMenuOpen,
                });
            }
        };
        /**
         * Validate desired menu state against props
         */
        this.validateMenuState = (desiredMenuState) => {
            let shouldOpenMenu = desiredMenuState;
            if (this.props.isMenuOpen !== undefined) {
                shouldOpenMenu = this.props.isMenuOpen;
            }
            else if (this.props.multiselectable === true) {
                shouldOpenMenu = true;
            }
            return shouldOpenMenu;
        };
        /**
         * handle menu blur
         */
        this.handleMenuBlur = (event) => {
            if (this.state.isMenuOpen &&
                !this.props.multiselectable &&
                this.rootElement.current !== null &&
                !this.rootElement.current.contains(event.relatedTarget)) {
                this.toggleMenu(false);
            }
        };
        /**
         * Determines what function needs to be called to format the result string and
         * calls it with the appropriate params
         */
        this.getFormattedDisplayString = (selectedOptions) => {
            return this.props.displayStringFormatter === undefined
                ? this.defaultDisplayStringFormatter(selectedOptions, this.props.placeholder)
                : this.props.displayStringFormatter(selectedOptions, this.props.placeholder);
        };
        /**
         * Determines if a given element is a focusable button
         */
        this.isFocusableButton = (element) => {
            return (element instanceof HTMLButtonElement &&
                element.getAttribute("aria-disabled") !== "true");
        };
        /**
         * focus on the trigger button
         */
        this.focusTriggerElement = () => {
            const triggerButton = this.getTriggerButton();
            if (triggerButton !== null) {
                triggerButton.focus();
            }
        };
        /**
         * get valid options
         */
        this.getValidOptions = () => {
            return Listbox.getValidOptions(React.Children.toArray(this.props.children));
        };
        let initialSelection = this.trimSelection(Listbox.getListboxItemDataFromIds(this.props.selectedItems !== undefined
            ? this.props.selectedItems
            : this.props.defaultSelection, this.props.children));
        if (!this.props.multiselectable && initialSelection.length > 1) {
            initialSelection = initialSelection.slice(0, 1);
        }
        const validOptions = this.getValidOptions();
        this.state = {
            selectedItems: initialSelection,
            value: this.getValueFromSelection(initialSelection),
            displayString: this.getFormattedDisplayString(initialSelection),
            isMenuOpen: this.validateMenuState(false),
            selectedItemIndex: this.getSelectedItemPosInSet(validOptions, initialSelection),
            selectableItemCount: validOptions.length,
        };
    }
    componentDidUpdate(prevProps) {
        let shouldUpdateSelection = false;
        let updatedMenuVisibility = this.state.isMenuOpen;
        if (prevProps.multiselectable !== this.props.multiselectable) {
            shouldUpdateSelection = true;
            updatedMenuVisibility = this.checkPropsForMenuState();
        }
        if (prevProps.isMenuOpen !== this.props.isMenuOpen) {
            updatedMenuVisibility = this.checkPropsForMenuState();
        }
        if (updatedMenuVisibility !== this.state.isMenuOpen) {
            this.toggleMenu(updatedMenuVisibility);
        }
        if (prevProps.selectedItems !== this.props.selectedItems) {
            this.updateSelectionFromProps();
            return;
        }
        if (shouldUpdateSelection) {
            this.updateSelection(this.state.selectedItems.map((thisItem) => {
                return thisItem;
            }));
        }
    }
    componentDidMount() {
        this.toggleMenu(this.checkPropsForMenuState());
        if (this.props.autoFocus &&
            !this.state.isMenuOpen &&
            !this.props.multiselectable) {
            this.focusTriggerElement();
        }
    }
    /**
     * Renders the component
     */
    render() {
        return (React.createElement("div", Object.assign({}, this.unhandledProps(), { ref: this.rootElement, className: this.generateClassNames(), onKeyDown: this.handleKeydown, onClick: this.handleClick, tabIndex: -1 }),
            this.renderTrigger(),
            this.renderHiddenSelectElement(),
            this.renderMenu()));
    }
    /**
     * Create class names
     */
    generateClassNames() {
        const { select, select__disabled, select_menu__open, select__multiSelectable, } = this.props.managedClasses;
        return super.generateClassNames(classNames(select, [select__disabled, this.props.disabled], [select_menu__open, this.state.isMenuOpen], [select__multiSelectable, this.props.multiselectable]));
    }
    /**
     * Renders a hidden select element which can interact with a
     * form hosting this component
     */
    renderHiddenSelectElement() {
        return (React.createElement("select", { required: this.props.required || null, name: this.props.name || null, form: this.props.form || null, value: this.state.value, multiple: this.props.multiselectable || null, disabled: this.props.disabled || null, onChange: this.onSelectValueChange, style: {
                display: "none",
            } }));
    }
    /**
     * Determine which function to use to render the trigger (ie. the part of the control that shows when the menu isn't open)
     * and invokes it
     */
    renderTrigger() {
        if (this.props.trigger !== undefined) {
            return this.props.trigger(this.props, this.state, this.triggerId);
        }
        else {
            return this.defaultTriggerRenderFunction(this.props, this.state, this.triggerId);
        }
    }
    /**
     * Determine which function to use to render the menu and invokes it
     */
    renderMenu() {
        if (!this.state.isMenuOpen) {
            return;
        }
        // in single select mode we always focus on an item when menu is opened,
        // multi-select lists only auto focus on an item if explicitly set to do so via props
        let shouldFocusOnMount = !this.props.multiselectable;
        if (this.props.multiselectable && this.props.autoFocus) {
            shouldFocusOnMount = this.props.multiselectable;
        }
        const defaultMenu = (React.createElement(Listbox, { labelledBy: this.props.labelledBy, disabled: this.props.disabled, focusItemOnMount: shouldFocusOnMount, multiselectable: this.props.multiselectable, defaultSelection: this.state.selectedItems, selectedItems: this.props.selectedItems, onSelectedItemsChanged: this.menuSelectionChange, onBlur: this.handleMenuBlur, selectOnFocus: false, managedClasses: {
                listbox: get(this.props.managedClasses, "select_menu", ""),
                listbox__disabled: get(this.props.managedClasses, "select_menuDisabled", ""),
            } }, this.props.children));
        const customMenu = typeof this.props.menu === "function"
            ? this.props.menu(this.props, this.state, defaultMenu)
            : defaultMenu;
        if (isNil(this.props.menuFlyoutConfig)) {
            return customMenu;
        }
        else {
            return (React.createElement(ViewportPositioner, Object.assign({ anchor: this.rootElement }, this.props.menuFlyoutConfig, { managedClasses: this.generateViewportPositionerClassNames() }), customMenu));
        }
    }
    /**
     * Returns viewport positioner managedclasses for select
     */
    generateViewportPositionerClassNames() {
        const { select__menuPositioningRegion, select__menuPositionLeft, select__menuPositionRight, select__menuPositionTop, select__menuPositionBottom, select__menuPositionHorizontalInset, select__menuPositionVerticalInset, } = this.props.managedClasses;
        return {
            viewportPositioner: select__menuPositioningRegion,
            viewportPositioner__left: select__menuPositionLeft,
            viewportPositioner__right: select__menuPositionRight,
            viewportPositioner__top: select__menuPositionTop,
            viewportPositioner__bottom: select__menuPositionBottom,
            viewportPositioner__horizontalInset: select__menuPositionHorizontalInset,
            viewportPositioner__verticalInset: select__menuPositionVerticalInset,
        };
    }
    /**
     * Return the first child of the select that is a non-disabled button
     */
    getTriggerButton() {
        const children = canUseDOM() && this.rootElement.current instanceof HTMLElement
            ? Array.from(this.rootElement.current.children)
            : [];
        const focusChildIndex = children.findIndex(this.isFocusableButton);
        return focusChildIndex !== -1
            ? children[focusChildIndex]
            : null;
    }
}
Select.displayName = `${DisplayNamePrefix}Select`;
Select.defaultProps = {
    multiselectable: false,
    disabled: false,
    defaultSelection: [],
    placeholder: "",
    managedClasses: {},
};
Select.idPropertyKey = "id";
Select.triggerUniqueIdPrefix = "selecttrigger-";
export default Select;
