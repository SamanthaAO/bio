import { accentBaseColor, accentFillActiveDelta, accentFillFocusDelta, accentFillHoverDelta, accentFillSelectedDelta, accentPalette, neutralFillActiveDelta, neutralFillHoverDelta, neutralFillRestDelta, } from "../design-system";
import { accentForegroundCut } from "./accent-foreground-cut";
import { colorRecipeFactory, contrast, designSystemResolverMax, swatchFamilyToSwatchRecipeFactory, SwatchFamilyType, } from "./common";
import { findClosestBackgroundIndex, findClosestSwatchIndex, getSwatch, isDarkMode, } from "./palette";
import { inRange } from "lodash-es";
const neutralFillThreshold = designSystemResolverMax(neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta);
function accentFillAlgorithm(contrastTarget) {
    return (designSystem) => {
        const palette = accentPalette(designSystem);
        const paletteLength = palette.length;
        const accent = accentBaseColor(designSystem);
        const textColor = accentForegroundCut(Object.assign({}, designSystem, {
            backgroundColor: accent,
        }));
        const hoverDelta = accentFillHoverDelta(designSystem);
        // Use the hover direction that matches the neutral fill recipe.
        const backgroundIndex = findClosestBackgroundIndex(designSystem);
        const swapThreshold = neutralFillThreshold(designSystem);
        const direction = backgroundIndex >= swapThreshold ? -1 : 1;
        const maxIndex = paletteLength - 1;
        const accentIndex = findClosestSwatchIndex(accentPalette, accent)(designSystem);
        let accessibleOffset = 0;
        // Move the accent color the direction of hover, while maintaining the foreground color.
        while (accessibleOffset < direction * hoverDelta &&
            inRange(accentIndex + accessibleOffset + direction, 0, paletteLength) &&
            contrast(palette[accentIndex + accessibleOffset + direction], textColor) >=
                contrastTarget &&
            inRange(accentIndex + accessibleOffset + direction + direction, 0, maxIndex)) {
            accessibleOffset += direction;
        }
        const hoverIndex = accentIndex + accessibleOffset;
        const restIndex = hoverIndex + direction * -1 * hoverDelta;
        const activeIndex = restIndex + direction * accentFillActiveDelta(designSystem);
        const focusIndex = restIndex + direction * accentFillFocusDelta(designSystem);
        return {
            rest: getSwatch(restIndex, palette),
            hover: getSwatch(hoverIndex, palette),
            active: getSwatch(activeIndex, palette),
            focus: getSwatch(focusIndex, palette),
            selected: getSwatch(restIndex +
                (isDarkMode(designSystem)
                    ? accentFillSelectedDelta(designSystem) * -1
                    : accentFillSelectedDelta(designSystem)), palette),
        };
    };
}
export const accentFill = colorRecipeFactory(accentFillAlgorithm(4.5));
export const accentFillLarge = colorRecipeFactory(accentFillAlgorithm(3));
export const accentFillRest = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, accentFill);
export const accentFillHover = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, accentFill);
export const accentFillActive = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, accentFill);
export const accentFillFocus = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, accentFill);
export const accentFillSelected = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.selected, accentFill);
export const accentFillLargeRest = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, accentFillLarge);
export const accentFillLargeHover = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, accentFillLarge);
export const accentFillLargeActive = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, accentFillLarge);
export const accentFillLargeFocus = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, accentFillLarge);
export const accentFillLargeSelected = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.selected, accentFillLarge);
